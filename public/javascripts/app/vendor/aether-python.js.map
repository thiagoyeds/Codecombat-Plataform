{"version":3,"sources":["bower_components/aether/build/python.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"public/javascripts/app/vendor/aether-python.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\r\n(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(typeof exports === 'object' && typeof module === 'object')\r\n\t\tmodule.exports = factory();\r\n\telse if(typeof define === 'function' && define.amd)\r\n\t\tdefine([], factory);\r\n\telse if(typeof exports === 'object')\r\n\t\texports[\"filbert\"] = factory();\r\n\telse\r\n\t\troot[\"filbert\"] = factory();\r\n})(this, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n\r\n/******/ \t// The require function\r\n/******/ \tfunction __webpack_require__(moduleId) {\r\n\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId])\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\texports: {},\r\n/******/ \t\t\tid: moduleId,\r\n/******/ \t\t\tloaded: false\r\n/******/ \t\t};\r\n\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\r\n\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.loaded = true;\r\n\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n\r\n\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__webpack_require__.m = modules;\r\n\r\n/******/ \t// expose the module cache\r\n/******/ \t__webpack_require__.c = installedModules;\r\n\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__webpack_require__.p = \"\";\r\n\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __webpack_require__(0);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ function(module, exports, __webpack_require__) {\r\n\r\n\t'use strict';\r\n\r\n\tvar Sk = __webpack_require__(1);\r\n\tvar transform = __webpack_require__(2);\r\n\tvar improveError = __webpack_require__(3);\r\n\r\n\tvar defaultOptions = {\r\n\t\tlocations: true,\r\n\t\tranges: true,\r\n\t\tsippets: true,\r\n\t\tfilename: 'file.py',\r\n\t\tuseLet: false,\r\n\t\tfriendlyErrors: true\r\n\t};\r\n\r\n\tfunction rangeToLoc(x, offsets) {\r\n\t\tvar best = -1;\r\n\t\tfor ( var i = 0; i < offsets.length; ++i ) {\r\n\t\t\tif ( offsets[i] > x ) break;\r\n\t\t\tbest = i;\r\n\t\t}\r\n\t\tvar off = best >= 0 ? offsets[best] : 0;\r\n\t\treturn {line: best+2, column: x - off, pos: x };\r\n\t}\r\n\r\n\tfunction locToRange(line, col, offsets) {\r\n\t\tvar loff = 0;\r\n\t\tif ( line > 2 && (line-2) < offsets.length ) loff = offsets[line-2];\r\n\t\treturn loff + col;\r\n\t}\r\n\r\n\tfunction decorate(n, code, offsets, options) {\r\n\t\tvar numrange = locToRange(n.lineno, n.col_offset, offsets);\r\n\r\n\t\tvar range = [\r\n\t\t\tnumrange === numrange ? numrange : Infinity,\r\n\t\t\tnumrange === numrange ? numrange : -Infinity\r\n\t\t];\r\n\t\t\r\n\t\tif ( n.value ) range[1] += (n.value.length);\r\n\r\n\t\tif ( n.children )\r\n\t\tfor ( var i = 0; i < n.children.length; ++i ) {\r\n\t\t\tvar r = decorate(n.children[i], code, offsets, options);\r\n\t\t\trange[0] = Math.min(range[0], r[0]);\r\n\t\t\trange[1] = Math.max(range[1], r[1]);\r\n\t\t}\r\n\r\n\t\tif ( options.ranges ) n.range = range;\r\n\t\tif ( options.locations ) {\r\n\t\t\tn.loc = {\r\n\t\t\t\tstart: rangeToLoc(range[0], offsets),\r\n\t\t\t\tend: rangeToLoc(range[1], offsets),\r\n\t\t\t};\r\n\t\t}\r\n\t\tif ( options.snippets ) n.str = code.substring(range[0], range[1]);\r\n\r\n\t\treturn range;\r\n\t}\r\n\r\n\tfunction parser(code, options) {\r\n\t\tvar lineOffsets = [];\r\n\t\tvar idx = -1;\r\n\t\tvar parse, ast;\r\n\t\toptions = options || {};\r\n\t\tfor ( var opt in defaultOptions ) {\r\n\t\t\tif ( !(opt in options) ) options[opt] = defaultOptions[opt];\r\n\t\t}\r\n\r\n\t\twhile ( true ) {\r\n\t\t\tidx = code.indexOf(\"\\n\", idx+1);\r\n\t\t\tif ( idx < 0 ) break;\r\n\t\t\tlineOffsets.push(idx+1);\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tparse = Sk.parse(options.filename, code);\r\n\t\t\tdecorate(parse.cst, code, lineOffsets, options);\r\n\t\t\tparse.flags = parse.flags | Sk.Parser.CO_FUTURE_UNICODE_LITERALS; //Enable future unicode literals\r\n\t\t\tast = Sk.astFromParse(parse.cst, options.filename, parse.flags);\r\n\t\t} catch ( e ) {\r\n\t\t\tif ( e.extra && e.extra.node ) decorate(e.extra.node, code, lineOffsets, options);\r\n\t\t\timproveError(e, options, code);\r\n\t\t\tif ( e.loc ) {\r\n\t\t\t\te.pos = locToRange(e.loc.line, e.loc.column, lineOffsets);\r\n\t\t\t}\r\n\t\t\tthrow e;\r\n\t\t}\r\n\r\n\t\t//console.log(JSON.stringify(ast, null, \"  \"));\r\n\t\tvar ctx = {varType: (options.useLet ? 'let' : 'var')};\r\n\t\tvar js = transform(ast, ctx);\r\n\t\treturn js;\r\n\t}\r\n\r\n\tmodule.exports = {\r\n\t\tparse: parser,\r\n\t\tpythonRuntime: __webpack_require__(4),\r\n\t\tdefaultOptions: {runtimeParamName: '__pythonRuntime'}\r\n\t};\r\n\r\n/***/ },\r\n/* 1 */\r\n/***/ function(module, exports) {\r\n\r\n\t/* WEBPACK VAR INJECTION */(function(global) {\r\n\t/* ---- /Users/rob/skulpty/lib/preamble.js ---- */ \r\n\r\n\tvar goog = {\r\n\t\tglobal: global\r\n\t};\r\n\r\n\tvar COMPILED = false;\r\n\r\n\tgoog.exportSymbol = function() {};\r\n\tgoog.require = function() {};\r\n\r\n\tgoog.inherits = function(childCtor, parentCtor) {\r\n\t  if ( !parentCtor ) throw new Error(\"Cant inherit from undefined?\");\r\n\t  /** @constructor */\r\n\t  function tempCtor() {};\r\n\t  tempCtor.prototype = parentCtor.prototype;\r\n\t  childCtor.superClass_ = parentCtor.prototype;\r\n\t  childCtor.prototype = new tempCtor();\r\n\t  /** @override */\r\n\t  childCtor.prototype.constructor = childCtor;\r\n\t};\r\n\r\n\tgoog.asserts = {\r\n\t\tassert: function(what, why) {\r\n\t        if ( !what ) throw new Error(\"AssertionFailed:\" + why);\r\n\t    }\r\n\t};\r\n\r\n\tvar Sk = Sk || {};\r\n\r\n\tSk.builtin = Sk.builtin  ||  {};\r\n\r\n\tSk.builtin.bool = Boolean;\r\n\tSk.builtin.int_ = function Int(x) {\r\n\t  this.v = x;\r\n\t};\r\n\r\n\tSk.builtin.int_.prototype.threshold$ = Infinity;\r\n\tSk.builtin.int_.prototype.valueOf = function() { return this.v.valueOf(); };\r\n\r\n\tSk.builtin.tuple = function(x) {\r\n\t  this.v = Array.prototype.slice.call(x, 0);\r\n\t};\r\n\tSk.builtin.tuple.prototype.sq$length = function() { return this.length; };\r\n\r\n\tSk.builtin.float_ = Number;\r\n\tSk.builtin.long = Number;\r\n\tSk.builtin.func = function(fx) { return fx; };\r\n\r\n\r\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/type.js ---- */ \r\n\r\n\tif(Sk.builtin === undefined) {\r\n\t    Sk.builtin = {};\r\n\t}\r\n\r\n\t/**\r\n\t * Maps Python dunder names to the Skulpt Javascript function names that\r\n\t * implement them.\r\n\t *\r\n\t * Note: __add__, __mul__, and __rmul__ can be used for either numeric or\r\n\t * sequence types. Here, they default to the numeric versions (i.e. nb$add,\r\n\t * nb$multiply, and nb$reflected_multiply). This works because Sk.abstr.binary_op_\r\n\t * checks for the numeric shortcuts and not the sequence shortcuts when computing\r\n\t * a binary operation.\r\n\t *\r\n\t * Because many of these functions are used in contexts in which Skulpt does not\r\n\t * [yet] handle suspensions, the assumption is that they must not suspend. However,\r\n\t * some of these built-in functions are acquiring 'canSuspend' arguments to signal\r\n\t * where this is not the case. These need to be spliced out of the argument list before\r\n\t * it is passed to python. Array values in this map contain [dunderName, argumentIdx],\r\n\t * where argumentIdx specifies the index of the 'canSuspend' boolean argument.\r\n\t *\r\n\t * @type {Object}\r\n\t */\r\n\tSk.dunderToSkulpt = {\r\n\t    \"__eq__\": \"ob$eq\",\r\n\t    \"__ne__\": \"ob$ne\",\r\n\t    \"__lt__\": \"ob$lt\",\r\n\t    \"__le__\": \"ob$le\",\r\n\t    \"__gt__\": \"ob$gt\",\r\n\t    \"__ge__\": \"ob$ge\",\r\n\t    \"__hash__\": \"tp$hash\",\r\n\t    \"__abs__\": \"nb$abs\",\r\n\t    \"__neg__\": \"nb$negative\",\r\n\t    \"__pos__\": \"nb$positive\",\r\n\t    \"__int__\": \"nb$int_\",\r\n\t    \"__long__\": \"nb$lng\",\r\n\t    \"__float__\": \"nb$float_\",\r\n\t    \"__add__\": \"nb$add\",\r\n\t    \"__radd__\": \"nb$reflected_add\",\r\n\t    \"__sub__\": \"nb$subtract\",\r\n\t    \"__rsub__\": \"nb$reflected_subtract\",\r\n\t    \"__mul__\": \"nb$multiply\",\r\n\t    \"__rmul__\": \"nb$reflected_multiply\",\r\n\t    \"__div__\": \"nb$divide\",\r\n\t    \"__rdiv__\": \"nb$reflected_divide\",\r\n\t    \"__floordiv__\": \"nb$floor_divide\",\r\n\t    \"__rfloordiv__\": \"nb$reflected_floor_divide\",\r\n\t    \"__mod__\": \"nb$remainder\",\r\n\t    \"__rmod__\": \"nb$reflected_remainder\",\r\n\t    \"__divmod__\": \"nb$divmod\",\r\n\t    \"__rdivmod__\": \"nb$reflected_divmod\",\r\n\t    \"__pow__\": \"nb$power\",\r\n\t    \"__rpow__\": \"nb$reflected_power\",\r\n\t    \"__contains__\": \"sq$contains\",\r\n\t    \"__len__\": [\"sq$length\", 0]\r\n\t};\r\n\r\n\t/**\r\n\t *\r\n\t * @constructor\r\n\t *\r\n\t * @param {*} name name or object to get type of, if only one arg\r\n\t *\r\n\t * @param {Sk.builtin.tuple=} bases\r\n\t *\r\n\t * @param {Object=} dict\r\n\t *\r\n\t *\r\n\t * This type represents the type of `type'. *Calling* an instance of\r\n\t * this builtin type named \"type\" creates class objects. The resulting\r\n\t * class objects will have various tp$xyz attributes on them that allow\r\n\t * for the various operations on that object.\r\n\t *\r\n\t * calling the type or calling an instance of the type? or both?\r\n\t */\r\n\tSk.builtin.type = function (name, bases, dict) {\r\n\t    var mro;\r\n\t    var obj;\r\n\t    var klass;\r\n\t    var v;\r\n\t    if (bases === undefined && dict === undefined) {\r\n\t        // 1 arg version of type()\r\n\t        // the argument is an object, not a name and returns a type object\r\n\t        obj = name;\r\n\t        return obj.ob$type;\r\n\t    } else {\r\n\r\n\t        // argument dict must be of type dict\r\n\t        if(dict.tp$name !== \"dict\") {\r\n\t            throw new Sk.builtin.TypeError(\"type() argument 3 must be dict, not \" + Sk.abstr.typeName(dict));\r\n\t        }\r\n\r\n\t        // checks if name must be string\r\n\t        if(!Sk.builtin.checkString(name)) {\r\n\t            throw new Sk.builtin.TypeError(\"type() argument 1 must be str, not \" + Sk.abstr.typeName(name));\r\n\t        }\r\n\r\n\t        // argument bases must be of type tuple\r\n\t        if(bases.tp$name !== \"tuple\") {\r\n\t            throw new Sk.builtin.TypeError(\"type() argument 2 must be tuple, not \" + Sk.abstr.typeName(bases));\r\n\t        }\r\n\r\n\t        // type building version of type\r\n\r\n\t        // dict is the result of running the classes code object\r\n\t        // (basically the dict of functions). those become the prototype\r\n\t        // object of the class).\r\n\t        /**\r\n\t        * @constructor\r\n\t        */\r\n\t        klass = function (kwdict, varargseq, kws, args, canSuspend) {\r\n\t            var init;\r\n\t            var self = this;\r\n\t            var s;\r\n\t            var args_copy;\r\n\t            if (!(this instanceof klass)) {\r\n\t                return new klass(kwdict, varargseq, kws, args, canSuspend);\r\n\t            }\r\n\r\n\t            args = args || [];\r\n\t            self[\"$d\"] = new Sk.builtin.dict([]);\r\n\t            self[\"$d\"].mp$ass_subscript(new Sk.builtin.str(\"__dict__\"), self[\"$d\"]);\r\n\r\n\t            if (klass.prototype.tp$base !== undefined) {\r\n\t                if (klass.prototype.tp$base.sk$klass) {\r\n\t                    klass.prototype.tp$base.call(this, kwdict, varargseq, kws, args.slice(), canSuspend);\r\n\t                } else {\r\n\t                    // Call super constructor if subclass of a builtin\r\n\t                    args_copy = args.slice();\r\n\t                    args_copy.unshift(klass, this);\r\n\t                    Sk.abstr.superConstructor.apply(undefined, args_copy);\r\n\t                }\r\n\t            }\r\n\r\n\t            init = Sk.builtin.type.typeLookup(self.ob$type, \"__init__\");\r\n\t            if (init !== undefined) {\r\n\t                // return should be None or throw a TypeError otherwise\r\n\t                args.unshift(self);\r\n\t                s = Sk.misceval.applyOrSuspend(init, kwdict, varargseq, kws, args);\r\n\r\n\t                return (function doSusp(s) {\r\n\t                    if (s instanceof Sk.misceval.Suspension) {\r\n\t                        // TODO I (Meredydd) don't know whether we are ever called\r\n\t                        // from anywhere except Sk.misceval.applyOrSuspend().\r\n\t                        // If we're not, we don't need a canSuspend parameter at all.\r\n\t                        if (canSuspend) {\r\n\t                            return new Sk.misceval.Suspension(doSusp, s);\r\n\t                        } else {\r\n\t                            return Sk.misceval.retryOptionalSuspensionOrThrow(s);\r\n\t                        }\r\n\t                    } else {\r\n\t                        return self;\r\n\t                    }\r\n\t                })(s);\r\n\t            }\r\n\r\n\t            return self;\r\n\t        };\r\n\r\n\t        var _name = Sk.ffi.remapToJs(name); // unwrap name string to js for latter use\r\n\r\n\t        var inheritsFromObject = false, inheritsBuiltin = false;\r\n\r\n\t        if (bases.v.length === 0 && Sk.python3) {\r\n\t            // new style class, inherits from object by default\r\n\t            inheritsFromObject = true;\r\n\t            Sk.abstr.setUpInheritance(_name, klass, Sk.builtin.object);\r\n\t        }\r\n\r\n\t        var parent, it, firstAncestor, builtin_bases = [];\r\n\t        // Set up inheritance from any builtins\r\n\t        for (it = bases.tp$iter(), parent = it.tp$iternext(); parent !== undefined; parent = it.tp$iternext()) {\r\n\t            if (firstAncestor === undefined) {\r\n\t                firstAncestor = parent;\r\n\t            }\r\n\t            if (parent.prototype instanceof Sk.builtin.object || parent === Sk.builtin.object) {\r\n\r\n\t                while (parent.sk$klass && parent.prototype.tp$base) {\r\n\t                    parent = parent.prototype.tp$base;\r\n\t                }\r\n\r\n\t                if (!parent.sk$klass && builtin_bases.indexOf(parent) < 0) {\r\n\t                    builtin_bases.push(parent);\r\n\t                }\r\n\r\n\t                // This class inherits from Sk.builtin.object at some level\r\n\t                inheritsFromObject = true;\r\n\t            }\r\n\t        }\r\n\r\n\t        if (builtin_bases.length > 1) {\r\n\t            throw new Sk.builtin.TypeError(\"Multiple inheritance with more than one builtin type is unsupported\");\r\n\t        }\r\n\r\n\t        // Javascript does not support multiple inheritance, so only the first\r\n\t        // base (if any) will directly inherit in Javascript\r\n\t        if (firstAncestor !== undefined) {\r\n\t            goog.inherits(klass, firstAncestor);\r\n\r\n\t            if (firstAncestor.prototype instanceof Sk.builtin.object || firstAncestor === Sk.builtin.object) {\r\n\t                klass.prototype.tp$base = firstAncestor;\r\n\t            }\r\n\t        }\r\n\r\n\t        klass.prototype.tp$name = _name;\r\n\t        klass.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(_name, klass);\r\n\r\n\t        if (!inheritsFromObject) {\r\n\t            // old style class, does not inherit from object\r\n\t            klass.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\r\n\t            klass.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\r\n\t        }\r\n\r\n\t        // set __module__ if not present (required by direct type(name, bases, dict) calls)\r\n\t        var module_lk = new Sk.builtin.str(\"__module__\");\r\n\t        if(dict.mp$lookup(module_lk) === undefined) {\r\n\t            dict.mp$ass_subscript(module_lk, Sk.globals[\"__name__\"]);\r\n\t        }\r\n\r\n\t        // copy properties into our klass object\r\n\t        // uses python iter methods\r\n\t        var k;\r\n\t        for (it = dict.tp$iter(), k = it.tp$iternext(); k !== undefined; k = it.tp$iternext()) {\r\n\t            v = dict.mp$subscript(k);\r\n\t            if (v === undefined) {\r\n\t                v = null;\r\n\t            }\r\n\t            klass.prototype[k.v] = v;\r\n\t            klass[k.v] = v;\r\n\t        }\r\n\r\n\t        klass[\"__class__\"] = klass;\r\n\t        klass[\"__name__\"] = name;\r\n\t        klass.sk$klass = true;\r\n\t        klass.prototype.tp$descr_get = function () {\r\n\t            goog.asserts.fail(\"in type tp$descr_get\");\r\n\t        };\r\n\t        klass.prototype[\"$r\"] = function () {\r\n\t            var cname;\r\n\t            var mod;\r\n\t            // TODO use Sk.abstr.gattr() here so __repr__ can be dynamically provided (eg by __getattr__())\r\n\t            var reprf = this.tp$getattr(\"__repr__\");\r\n\t            if (reprf !== undefined && reprf.im_func !== Sk.builtin.object.prototype[\"__repr__\"]) {\r\n\t                return Sk.misceval.apply(reprf, undefined, undefined, undefined, []);\r\n\t            }\r\n\r\n\t            if ((klass.prototype.tp$base !== undefined) &&\r\n\t                (klass.prototype.tp$base !== Sk.builtin.object) &&\r\n\t                (klass.prototype.tp$base.prototype[\"$r\"] !== undefined)) {\r\n\t                // If subclass of a builtin which is not object, use that class' repr\r\n\t                return klass.prototype.tp$base.prototype[\"$r\"].call(this);\r\n\t            } else {\r\n\t                // Else, use default repr for a user-defined class instance\r\n\t                mod = dict.mp$subscript(module_lk); // lookup __module__\r\n\t                cname = \"\";\r\n\t                if (mod) {\r\n\t                    cname = mod.v + \".\";\r\n\t                }\r\n\t                return new Sk.builtin.str(\"<\" + cname + _name + \" object>\");\r\n\t            }\r\n\t        };\r\n\t        klass.prototype.tp$str = function () {\r\n\t            // TODO use Sk.abstr.gattr() here so __str__ can be dynamically provided (eg by __getattr__())\r\n\t            var strf = this.tp$getattr(\"__str__\");\r\n\t            if (strf !== undefined && strf.im_func !== Sk.builtin.object.prototype[\"__str__\"]) {\r\n\t                return Sk.misceval.apply(strf, undefined, undefined, undefined, []);\r\n\t            }\r\n\t            if ((klass.prototype.tp$base !== undefined) &&\r\n\t                (klass.prototype.tp$base !== Sk.builtin.object) &&\r\n\t                (klass.prototype.tp$base.prototype.tp$str !== undefined)) {\r\n\t                // If subclass of a builtin which is not object, use that class' repr\r\n\t                return klass.prototype.tp$base.prototype.tp$str.call(this);\r\n\t            }\r\n\t            return this[\"$r\"]();\r\n\t        };\r\n\t        klass.prototype.tp$length = function (canSuspend) {\r\n\t            var r = Sk.misceval.chain(Sk.abstr.gattr(this, \"__len__\", canSuspend), function(lenf) {\r\n\t                return Sk.misceval.applyOrSuspend(lenf, undefined, undefined, undefined, []);\r\n\t            });\r\n\t            return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\r\n\t        };\r\n\t        klass.prototype.tp$call = function (args, kw) {\r\n\t            return Sk.misceval.chain(Sk.abstr.gattr(this, \"__call__\", true), function(callf) {\r\n\t                return Sk.misceval.applyOrSuspend(callf, undefined, undefined, kw, args);\r\n\t            });\r\n\t        };\r\n\t        klass.prototype.tp$iter = function () {\r\n\t            var iterf = Sk.abstr.gattr(this, \"__iter__\", false);\r\n\t            return Sk.misceval.callsim(iterf);\r\n\t        };\r\n\t        klass.prototype.tp$iternext = function (canSuspend) {\r\n\t            var self = this;\r\n\t            var r = Sk.misceval.chain(\r\n\t                Sk.misceval.tryCatch(function() {\r\n\t                    return Sk.abstr.gattr(self, \"next\", canSuspend);\r\n\t                }, function(e) {\r\n\t                    if (e instanceof Sk.builtin.AttributeError) {\r\n\t                        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(self) + \"' object is not iterable\");\r\n\t                    } else {\r\n\t                        throw e;\r\n\t                    }\r\n\t                }),\r\n\t            function(/** {Object} */ iternextf) {\r\n\t                return Sk.misceval.tryCatch(function() {\r\n\t                    return Sk.misceval.callsimOrSuspend(iternextf);\r\n\t                }, function(e) {\r\n\t                    if (e instanceof Sk.builtin.StopIteration) {\r\n\t                        return undefined;\r\n\t                    } else {\r\n\t                        throw e;\r\n\t                    }\r\n\t                });\r\n\t            });\r\n\r\n\t            return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\r\n\t        };\r\n\r\n\t        klass.prototype.tp$getitem = function (key, canSuspend) {\r\n\t            var getf = Sk.abstr.gattr(this, \"__getitem__\", canSuspend), r;\r\n\t            if (getf !== undefined) {\r\n\t                r = Sk.misceval.applyOrSuspend(getf, undefined, undefined, undefined, [key]);\r\n\t                return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\r\n\t            }\r\n\t            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(this) + \"' object does not support indexing\");\r\n\t        };\r\n\t        klass.prototype.tp$setitem = function (key, value, canSuspend) {\r\n\t            var setf = Sk.abstr.gattr(this, \"__setitem__\", canSuspend), r;\r\n\t            if (setf !== undefined) {\r\n\t                r = Sk.misceval.applyOrSuspend(setf, undefined, undefined, undefined, [key, value]);\r\n\t                return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\r\n\t            }\r\n\t            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(this) + \"' object does not support item assignment\");\r\n\t        };\r\n\r\n\t        if (bases) {\r\n\t            //print(\"building mro for\", name);\r\n\t            //for (var i = 0; i < bases.length; ++i)\r\n\t            //print(\"base[\" + i + \"]=\" + bases[i].tp$name);\r\n\t            klass[\"$d\"] = new Sk.builtin.dict([]);\r\n\t            klass[\"$d\"].mp$ass_subscript(Sk.builtin.type.basesStr_, bases);\r\n\t            mro = Sk.builtin.type.buildMRO(klass);\r\n\t            klass[\"$d\"].mp$ass_subscript(Sk.builtin.type.mroStr_, mro);\r\n\t            klass.tp$mro = mro;\r\n\t            //print(\"mro result\", Sk.builtin.repr(mro).v);\r\n\t        }\r\n\r\n\t        // fix for class attributes\r\n\t        klass.tp$setattr = Sk.builtin.type.prototype.tp$setattr;\r\n\r\n\t        var shortcutDunder = function (skulpt_name, magic_name, magic_func, canSuspendIdx) {\r\n\t            klass.prototype[skulpt_name] = function () {\r\n\t                var args = Array.prototype.slice.call(arguments), canSuspend;\r\n\t                args.unshift(magic_func, this);\r\n\r\n\t                if (canSuspendIdx) {\r\n\t                    canSuspend = args[canSuspendIdx+1];\r\n\t                    args.splice(canSuspendIdx+1, 1);\r\n\t                    if (canSuspend) {\r\n\t                        return Sk.misceval.callsimOrSuspend.apply(undefined, args);\r\n\t                    }\r\n\t                }\r\n\t                return Sk.misceval.callsim.apply(undefined, args);\r\n\t            };\r\n\t        };\r\n\r\n\t        // Register skulpt shortcuts to magic methods defined by this class.\r\n\t        // TODO: This is somewhat problematic, as it means that dynamically defined\r\n\t        // methods (eg those returned by __getattr__()) cannot be used by these magic\r\n\t        // functions.\r\n\t        var dunder, skulpt_name, canSuspendIdx;\r\n\t        for (dunder in Sk.dunderToSkulpt) {\r\n\t            skulpt_name = Sk.dunderToSkulpt[dunder];\r\n\t            if (typeof(skulpt_name) === \"string\") {\r\n\t                canSuspendIdx = null;\r\n\t            } else {\r\n\t                canSuspendIdx = skulpt_name[1];\r\n\t                skulpt_name = skulpt_name[0];\r\n\t            }\r\n\r\n\t            if (klass[dunder]) {\r\n\t                // scope workaround\r\n\t                shortcutDunder(skulpt_name, dunder, klass[dunder], canSuspendIdx);\r\n\t            }\r\n\t        }\r\n\r\n\t        return klass;\r\n\t    }\r\n\r\n\t};\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\tSk.builtin.type.makeTypeObj = function (name, newedInstanceOfType) {\r\n\t    Sk.builtin.type.makeIntoTypeObj(name, newedInstanceOfType);\r\n\t    return newedInstanceOfType;\r\n\t};\r\n\r\n\tSk.builtin.type.makeIntoTypeObj = function (name, t) {\r\n\t    goog.asserts.assert(name !== undefined);\r\n\t    goog.asserts.assert(t !== undefined);\r\n\t    t.ob$type = Sk.builtin.type;\r\n\t    t.tp$name = name;\r\n\t    t[\"$r\"] = function () {\r\n\t        var ctype;\r\n\t        var mod = t.__module__;\r\n\t        var cname = \"\";\r\n\t        if (mod) {\r\n\t            cname = mod.v + \".\";\r\n\t        }\r\n\t        ctype = \"class\";\r\n\t        if (!mod && !t.sk$klass && !Sk.python3) {\r\n\t            ctype = \"type\";\r\n\t        }\r\n\t        return new Sk.builtin.str(\"<\" + ctype + \" '\" + cname + t.tp$name + \"'>\");\r\n\t    };\r\n\t    t.tp$str = undefined;\r\n\t    t.tp$getattr = Sk.builtin.type.prototype.tp$getattr;\r\n\t    t.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\r\n\t    t.tp$richcompare = Sk.builtin.type.prototype.tp$richcompare;\r\n\t    t.sk$type = true;\r\n\r\n\t    return t;\r\n\t};\r\n\r\n\tSk.builtin.type.ob$type = Sk.builtin.type;\r\n\tSk.builtin.type.tp$name = \"type\";\r\n\tSk.builtin.type[\"$r\"] = function () {\r\n\t    if(Sk.python3) {\r\n\t        return new Sk.builtin.str(\"<class 'type'>\");\r\n\t    } else {\r\n\t        return new Sk.builtin.str(\"<type 'type'>\");\r\n\t    }\r\n\t};\r\n\r\n\t//Sk.builtin.type.prototype.tp$descr_get = function() { print(\"in type descr_get\"); };\r\n\r\n\t//Sk.builtin.type.prototype.tp$name = \"type\";\r\n\r\n\t// basically the same as GenericGetAttr except looks in the proto instead\r\n\tSk.builtin.type.prototype.tp$getattr = function (name) {\r\n\t    var res;\r\n\t    var tp = this;\r\n\t    var descr;\r\n\t    var f;\r\n\r\n\t    if (this[\"$d\"]) {\r\n\t        res = this[\"$d\"].mp$lookup(new Sk.builtin.str(name));\r\n\t        if (res !== undefined) {\r\n\t            return res;\r\n\t        }\r\n\t    }\r\n\r\n\t    descr = Sk.builtin.type.typeLookup(tp, name);\r\n\r\n\t    //print(\"type.tpgetattr descr\", descr, descr.tp$name, descr.func_code, name);\r\n\t    if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {\r\n\t        f = descr.ob$type.tp$descr_get;\r\n\t        // todo;if (f && descr.tp$descr_set) // is a data descriptor if it has a set\r\n\t        // return f.call(descr, this, this.ob$type);\r\n\t    }\r\n\r\n\t    if (f) {\r\n\t        // non-data descriptor\r\n\t        return f.call(descr, null, tp);\r\n\t    }\r\n\r\n\t    if (descr !== undefined) {\r\n\t        return descr;\r\n\t    }\r\n\r\n\t    return undefined;\r\n\t};\r\n\r\n\tSk.builtin.type.prototype.tp$setattr = function (name, value) {\r\n\t    // class attributes are direct properties of the object\r\n\t    this[name] = value;\r\n\t};\r\n\r\n\tSk.builtin.type.typeLookup = function (type, name) {\r\n\t    var mro = type.tp$mro;\r\n\t    var pyname = new Sk.builtin.str(name);\r\n\t    var base;\r\n\t    var res;\r\n\t    var i;\r\n\r\n\t    // todo; probably should fix this, used for builtin types to get stuff\r\n\t    // from prototype\r\n\t    if (!mro) {\r\n\t        if (type.prototype) {\r\n\t            return type.prototype[name];\r\n\t        }\r\n\t        return undefined;\r\n\t    }\r\n\r\n\t    for (i = 0; i < mro.v.length; ++i) {\r\n\t        base = mro.v[i];\r\n\t        if (base.hasOwnProperty(name)) {\r\n\t            return base[name];\r\n\t        }\r\n\t        res = base[\"$d\"].mp$lookup(pyname);\r\n\t        if (res !== undefined) {\r\n\t            return res;\r\n\t        }\r\n\t        if (base.prototype && base.prototype[name] !== undefined) {\r\n\t            return base.prototype[name];\r\n\t        }\r\n\t    }\r\n\r\n\t    return undefined;\r\n\t};\r\n\r\n\tSk.builtin.type.mroMerge_ = function (seqs) {\r\n\t    /*\r\n\t     var tmp = [];\r\n\t     for (var i = 0; i < seqs.length; ++i)\r\n\t     {\r\n\t     tmp.push(new Sk.builtin.list(seqs[i]));\r\n\t     }\r\n\t     print(Sk.builtin.repr(new Sk.builtin.list(tmp)).v);\r\n\t     */\r\n\t    var seq;\r\n\t    var i;\r\n\t    var next;\r\n\t    var k;\r\n\t    var sseq;\r\n\t    var j;\r\n\t    var cand;\r\n\t    var cands;\r\n\t    var res = [];\r\n\t    for (; ;) {\r\n\t        for (i = 0; i < seqs.length; ++i) {\r\n\t            seq = seqs[i];\r\n\t            if (seq.length !== 0) {\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\t        if (i === seqs.length) { // all empty\r\n\t            return res;\r\n\t        }\r\n\t        cands = [];\r\n\t        for (i = 0; i < seqs.length; ++i) {\r\n\t            seq = seqs[i];\r\n\t            //print(\"XXX\", Sk.builtin.repr(new Sk.builtin.list(seq)).v);\r\n\t            if (seq.length !== 0) {\r\n\t                cand = seq[0];\r\n\t                //print(\"CAND\", Sk.builtin.repr(cand).v);\r\n\t                OUTER:\r\n\t                    for (j = 0; j < seqs.length; ++j) {\r\n\t                        sseq = seqs[j];\r\n\t                        for (k = 1; k < sseq.length; ++k) {\r\n\t                            if (sseq[k] === cand) {\r\n\t                                break OUTER;\r\n\t                            }\r\n\t                        }\r\n\t                    }\r\n\r\n\t                // cand is not in any sequences' tail -> constraint-free\r\n\t                if (j === seqs.length) {\r\n\t                    cands.push(cand);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        if (cands.length === 0) {\r\n\t            throw new Sk.builtin.TypeError(\"Inconsistent precedences in type hierarchy\");\r\n\t        }\r\n\r\n\t        next = cands[0];\r\n\t        // append next to result and remove from sequences\r\n\t        res.push(next);\r\n\t        for (i = 0; i < seqs.length; ++i) {\r\n\t            seq = seqs[i];\r\n\t            if (seq.length > 0 && seq[0] === next) {\r\n\t                seq.splice(0, 1);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t};\r\n\r\n\tSk.builtin.type.buildMRO_ = function (klass) {\r\n\t    // MERGE(klass + mro(bases) + bases)\r\n\t    var i;\r\n\t    var bases;\r\n\t    var all = [\r\n\t        [klass]\r\n\t    ];\r\n\r\n\t    //Sk.debugout(\"buildMRO for\", klass.tp$name);\r\n\r\n\t    var kbases = klass[\"$d\"].mp$subscript(Sk.builtin.type.basesStr_);\r\n\t    for (i = 0; i < kbases.v.length; ++i) {\r\n\t        all.push(Sk.builtin.type.buildMRO_(kbases.v[i]));\r\n\t    }\r\n\r\n\t    bases = [];\r\n\t    for (i = 0; i < kbases.v.length; ++i) {\r\n\t        bases.push(kbases.v[i]);\r\n\t    }\r\n\t    all.push(bases);\r\n\r\n\t    return Sk.builtin.type.mroMerge_(all);\r\n\t};\r\n\r\n\t/*\r\n\t * C3 MRO (aka CPL) linearization. Figures out which order to search through\r\n\t * base classes to determine what should override what. C3 does the \"right\r\n\t * thing\", and it's what Python has used since 2.3.\r\n\t *\r\n\t * Kind of complicated to explain, but not really that complicated in\r\n\t * implementation. Explanations:\r\n\t *\r\n\t * http://people.csail.mit.edu/jrb/goo/manual.43/goomanual_55.html\r\n\t * http://www.python.org/download/releases/2.3/mro/\r\n\t * http://192.220.96.201/dylan/linearization-oopsla96.html\r\n\t *\r\n\t * This implementation is based on a post by Samuele Pedroni on python-dev\r\n\t * (http://mail.python.org/pipermail/python-dev/2002-October/029176.html) when\r\n\t * discussing its addition to Python.\r\n\t */\r\n\tSk.builtin.type.buildMRO = function (klass) {\r\n\t    return new Sk.builtin.tuple(Sk.builtin.type.buildMRO_(klass));\r\n\t};\r\n\r\n\tSk.builtin.type.prototype.tp$richcompare = function (other, op) {\r\n\t    var r2;\r\n\t    var r1;\r\n\t    if (other.ob$type != Sk.builtin.type) {\r\n\t        return undefined;\r\n\t    }\r\n\t    if (!this[\"$r\"] || !other[\"$r\"]) {\r\n\t        return undefined;\r\n\t    }\r\n\t    r1 = new Sk.builtin.str(this[\"$r\"]().v.slice(1,6));\r\n\t    r2 = new Sk.builtin.str(other[\"$r\"]().v.slice(1,6));\r\n\t    if (this[\"$r\"]().v.slice(1,6) !== \"class\") {\r\n\t        r1 = this[\"$r\"]();\r\n\t        r2 = other[\"$r\"]();\r\n\t    }\r\n\t    return r1.tp$richcompare(r2, op);\r\n\t};\r\n\r\n\r\n\r\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/abstract.js ---- */ \r\n\r\n\t/**\r\n\t * @namespace Sk.abstr\r\n\t *\r\n\t */\r\n\tSk.abstr = {};\r\n\r\n\t//\r\n\t// Number\r\n\t//\r\n\r\n\tSk.abstr.typeName = function (v) {\r\n\t    var vtypename;\r\n\t    if (v.tp$name !== undefined) {\r\n\t        vtypename = v.tp$name;\r\n\t    } else {\r\n\t        vtypename = \"<invalid type>\";\r\n\t    }\r\n\t    return vtypename;\r\n\t};\r\n\r\n\tSk.abstr.binop_type_error = function (v, w, name) {\r\n\t    var vtypename = Sk.abstr.typeName(v),\r\n\t        wtypename = Sk.abstr.typeName(w);\r\n\r\n\t    throw new Sk.builtin.TypeError(\"unsupported operand type(s) for \" + name + \": '\" + vtypename + \"' and '\" + wtypename + \"'\");\r\n\t};\r\n\r\n\tSk.abstr.unop_type_error = function (v, name) {\r\n\t    var vtypename = Sk.abstr.typeName(v),\r\n\t        uop = {\r\n\t            \"UAdd\"  : \"+\",\r\n\t            \"USub\"  : \"-\",\r\n\t            \"Invert\": \"~\"\r\n\t        }[name];\r\n\r\n\t    throw new Sk.builtin.TypeError(\"bad operand type for unary \" + uop + \": '\" + vtypename + \"'\");\r\n\t};\r\n\r\n\t/**\r\n\t * lookup and return the LHS object slot function method.  This coudl be either a builtin slot function or a dunder method defined by the user.\r\n\t * @param obj\r\n\t * @param name\r\n\t * @returns {Object|null|undefined}\r\n\t * @private\r\n\t */\r\n\tSk.abstr.boNameToSlotFuncLhs_ = function (obj, name) {\r\n\t    if (obj === null) {\r\n\t        return undefined;\r\n\t    }\r\n\r\n\t    switch (name) {\r\n\t    case \"Add\":\r\n\t        return obj.nb$add ? obj.nb$add : obj[\"__add__\"];\r\n\t    case \"Sub\":\r\n\t        return obj.nb$subtract ? obj.nb$subtract : obj[\"__sub__\"];\r\n\t    case \"Mult\":\r\n\t        return obj.nb$multiply ? obj.nb$multiply : obj[\"__mul__\"];\r\n\t    case \"Div\":\r\n\t        return obj.nb$divide ? obj.nb$divide : obj[\"__div__\"];\r\n\t    case \"FloorDiv\":\r\n\t        return obj.nb$floor_divide ? obj.nb$floor_divide : obj[\"__floordiv__\"];\r\n\t    case \"Mod\":\r\n\t        return obj.nb$remainder ? obj.nb$remainder : obj[\"__mod__\"];\r\n\t    case \"DivMod\":\r\n\t        return obj.nb$divmod ? obj.nb$divmod : obj[\"__divmod__\"];\r\n\t    case \"Pow\":\r\n\t        return obj.nb$power ? obj.nb$power : obj[\"__pow__\"];\r\n\t    case \"LShift\":\r\n\t        return obj.nb$lshift ? obj.nb$lshift : obj[\"__lshift__\"];\r\n\t    case \"RShift\":\r\n\t        return obj.nb$rshift ? obj.nb$rshift : obj[\"__rshift__\"];\r\n\t    case \"BitAnd\":\r\n\t        return obj.nb$and ? obj.nb$and : obj[\"__and__\"];\r\n\t    case \"BitXor\":\r\n\t        return obj.nb$xor ? obj.nb$xor : obj[\"__xor__\"];\r\n\t    case \"BitOr\":\r\n\t        return obj.nb$or ? obj.nb$or : obj[\"__or__\"];\r\n\t    }\r\n\t};\r\n\r\n\tSk.abstr.boNameToSlotFuncRhs_ = function (obj, name) {\r\n\t    if (obj === null) {\r\n\t        return undefined;\r\n\t    }\r\n\r\n\t    switch (name) {\r\n\t    case \"Add\":\r\n\t        return obj.nb$reflected_add ? obj.nb$reflected_add : obj[\"__radd__\"];\r\n\t    case \"Sub\":\r\n\t        return obj.nb$reflected_subtract ? obj.nb$reflected_subtract : obj[\"__rsub__\"];\r\n\t    case \"Mult\":\r\n\t        return obj.nb$reflected_multiply ? obj.nb$reflected_multiply : obj[\"__rmul__\"];\r\n\t    case \"Div\":\r\n\t        return obj.nb$reflected_divide ? obj.nb$reflected_divide : obj[\"__rdiv__\"];\r\n\t    case \"FloorDiv\":\r\n\t        return obj.nb$reflected_floor_divide ? obj.nb$reflected_floor_divide : obj[\"__rfloordiv__\"];\r\n\t    case \"Mod\":\r\n\t        return obj.nb$reflected_remainder ? obj.nb$reflected_remainder : obj[\"__rmod__\"];\r\n\t    case \"DivMod\":\r\n\t        return obj.nb$reflected_divmod ? obj.nb$reflected_divmod : obj[\"__rdivmod__\"];\r\n\t    case \"Pow\":\r\n\t        return obj.nb$reflected_power ? obj.nb$reflected_power : obj[\"__rpow__\"];\r\n\t    case \"LShift\":\r\n\t        return obj.nb$reflected_lshift ? obj.nb$reflected_lshift : obj[\"__rlshift__\"];\r\n\t    case \"RShift\":\r\n\t        return obj.nb$reflected_rshift ? obj.nb$reflected_rshift : obj[\"__rrshift__\"];\r\n\t    case \"BitAnd\":\r\n\t        return obj.nb$reflected_and ? obj.nb$reflected_and : obj[\"__rand__\"];\r\n\t    case \"BitXor\":\r\n\t        return obj.nb$reflected_xor ? obj.nb$reflected_xor : obj[\"__rxor__\"];\r\n\t    case \"BitOr\":\r\n\t        return obj.nb$reflected_or ? obj.nb$reflected_or : obj[\"__ror__\"];\r\n\t    }\r\n\t};\r\n\r\n\tSk.abstr.iboNameToSlotFunc_ = function (obj, name) {\r\n\t    switch (name) {\r\n\t    case \"Add\":\r\n\t        return obj.nb$inplace_add ? obj.nb$inplace_add : obj[\"__iadd__\"];\r\n\t    case \"Sub\":\r\n\t        return obj.nb$inplace_subtract ? obj.nb$inplace_subtract : obj[\"__isub__\"];\r\n\t    case \"Mult\":\r\n\t        return obj.nb$inplace_multiply ? obj.nb$inplace_multiply : obj[\"__imul__\"];\r\n\t    case \"Div\":\r\n\t        return obj.nb$inplace_divide ? obj.nb$inplace_divide : obj[\"__idiv__\"];\r\n\t    case \"FloorDiv\":\r\n\t        return obj.nb$inplace_floor_divide ? obj.nb$inplace_floor_divide : obj[\"__ifloordiv__\"];\r\n\t    case \"Mod\":\r\n\t        return obj.nb$inplace_remainder;\r\n\t    case \"Pow\":\r\n\t        return obj.nb$inplace_power;\r\n\t    case \"LShift\":\r\n\t        return obj.nb$inplace_lshift ? obj.nb$inplace_lshift : obj[\"__ilshift__\"];\r\n\t    case \"RShift\":\r\n\t        return obj.nb$inplace_rshift ? obj.nb$inplace_rshift : obj[\"__irshift__\"];\r\n\t    case \"BitAnd\":\r\n\t        return obj.nb$inplace_and;\r\n\t    case \"BitOr\":\r\n\t        return obj.nb$inplace_or;\r\n\t    case \"BitXor\":\r\n\t        return obj.nb$inplace_xor ? obj.nb$inplace_xor : obj[\"__ixor__\"];\r\n\t    }\r\n\t};\r\n\tSk.abstr.uoNameToSlotFunc_ = function (obj, name) {\r\n\t    if (obj === null) {\r\n\t        return undefined;\r\n\t    }\r\n\t    switch (name) {\r\n\t    case \"USub\":\r\n\t        return obj.nb$negative ? obj.nb$negative : obj[\"__neg__\"];\r\n\t    case \"UAdd\":\r\n\t        return obj.nb$positive ? obj.nb$positive : obj[\"__pos__\"];\r\n\t    case \"Invert\":\r\n\t        return obj.nb$invert ? obj.nb$invert : obj[\"__invert__\"];\r\n\t    }\r\n\t};\r\n\r\n\tSk.abstr.binary_op_ = function (v, w, opname) {\r\n\t    var wop;\r\n\t    var ret;\r\n\t    var vop;\r\n\r\n\t    // All Python inheritance is now enforced with Javascript inheritance\r\n\t    // (see Sk.abstr.setUpInheritance). This checks if w's type is a strict\r\n\t    // subclass of v's type\r\n\t    var w_is_subclass = w.constructor.prototype instanceof v.constructor;\r\n\r\n\t    // From the Python 2.7 docs:\r\n\t    //\r\n\t    // \"If the right operands type is a subclass of the left operands type and\r\n\t    // that subclass provides the reflected method for the operation, this\r\n\t    // method will be called before the left operands non-reflected method.\r\n\t    // This behavior allows subclasses to override their ancestors operations.\"\r\n\t    //\r\n\t    // -- https://docs.python.org/2/reference/datamodel.html#index-92\r\n\r\n\t    if (w_is_subclass) {\r\n\t        wop = Sk.abstr.boNameToSlotFuncRhs_(w, opname);\r\n\t        if (wop !== undefined) {\r\n\t            if (wop.call) {\r\n\t                ret = wop.call(w, v);\r\n\t            } else {\r\n\t                ret = Sk.misceval.callsim(wop, w, v);\r\n\t            }\r\n\t            if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\r\n\t                return ret;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    vop = Sk.abstr.boNameToSlotFuncLhs_(v, opname);\r\n\t    if (vop !== undefined) {\r\n\t        if (vop.call) {\r\n\t            ret = vop.call(v, w);\r\n\t        } else {\r\n\t            ret = Sk.misceval.callsim(vop, v, w);\r\n\t        }\r\n\t        if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\r\n\t            return ret;\r\n\t        }\r\n\t    }\r\n\t    // Don't retry RHS if failed above\r\n\t    if (!w_is_subclass) {\r\n\t        wop = Sk.abstr.boNameToSlotFuncRhs_(w, opname);\r\n\t        if (wop !== undefined) {\r\n\t            if (wop.call) {\r\n\t                ret = wop.call(w, v);\r\n\t            } else {\r\n\t                ret = Sk.misceval.callsim(wop, w, v);\r\n\t            }\r\n\t            if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\r\n\t                return ret;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    Sk.abstr.binop_type_error(v, w, opname);\r\n\t};\r\n\r\n\tSk.abstr.binary_iop_ = function (v, w, opname) {\r\n\t    var wop;\r\n\t    var ret;\r\n\t    var vop = Sk.abstr.iboNameToSlotFunc_(v, opname);\r\n\t    if (vop !== undefined) {\r\n\t        if (vop.call) {\r\n\t            ret = vop.call(v, w);\r\n\t        } else {  // assume that vop is an __xxx__ type method\r\n\t            ret = Sk.misceval.callsim(vop, v, w); //  added to be like not-in-place... is this okay?\r\n\t        }\r\n\t        if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\r\n\t            return ret;\r\n\t        }\r\n\t    }\r\n\t    wop = Sk.abstr.iboNameToSlotFunc_(w, opname);\r\n\t    if (wop !== undefined) {\r\n\t        if (wop.call) {\r\n\t            ret = wop.call(w, v);\r\n\t        } else { // assume that wop is an __xxx__ type method\r\n\t            ret = Sk.misceval.callsim(wop, w, v); //  added to be like not-in-place... is this okay?\r\n\t        }\r\n\t        if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\r\n\t            return ret;\r\n\t        }\r\n\t    }\r\n\t    Sk.abstr.binop_type_error(v, w, opname);\r\n\t};\r\n\tSk.abstr.unary_op_ = function (v, opname) {\r\n\t    var ret;\r\n\t    var vop = Sk.abstr.uoNameToSlotFunc_(v, opname);\r\n\t    if (vop !== undefined) {\r\n\t        if (vop.call) {\r\n\t            ret = vop.call(v);\r\n\t        } else {  // assume that vop is an __xxx__ type method\r\n\t            ret = Sk.misceval.callsim(vop, v); //  added to be like not-in-place... is this okay?\r\n\t        }\r\n\t        if (ret !== undefined) {\r\n\t            return ret;\r\n\t        }\r\n\t    }\r\n\t    Sk.abstr.unop_type_error(v, opname);\r\n\t};\r\n\r\n\t//\r\n\t// handle upconverting a/b from number to long if op causes too big/small a\r\n\t// result, or if either of the ops are already longs\r\n\tSk.abstr.numOpAndPromote = function (a, b, opfn) {\r\n\t    var tmp;\r\n\t    var ans;\r\n\t    if (a === null || b === null) {\r\n\t        return undefined;\r\n\t    }\r\n\r\n\t    if (typeof a === \"number\" && typeof b === \"number\") {\r\n\t        ans = opfn(a, b);\r\n\t        // todo; handle float   Removed RNL (bugs in lng, and it should be a question of precision, not magnitude -- this was just wrong)\r\n\t        if ((ans > Sk.builtin.int_.threshold$ || ans < -Sk.builtin.int_.threshold$) && Math.floor(ans) === ans) {\r\n\t            return [Sk.builtin.lng.fromInt$(a), Sk.builtin.lng.fromInt$(b)];\r\n\t        } else {\r\n\t            return ans;\r\n\t        }\r\n\t    } else if (a === undefined || b === undefined) {\r\n\t        throw new Sk.builtin.NameError(\"Undefined variable in expression\");\r\n\t    }\r\n\r\n\t    if (a.constructor === Sk.builtin.lng) {\r\n\t        return [a, b];\r\n\t    } else if ((a.constructor === Sk.builtin.int_ ||\r\n\t                a.constructor === Sk.builtin.float_) &&\r\n\t                b.constructor === Sk.builtin.complex) {\r\n\t        // special case of upconverting nmber and complex\r\n\t        // can we use here the Sk.builtin.checkComplex() method?\r\n\t        tmp = new Sk.builtin.complex(a);\r\n\t        return [tmp, b];\r\n\t    } else if (a.constructor === Sk.builtin.int_ ||\r\n\t               a.constructor === Sk.builtin.float_) {\r\n\t        return [a, b];\r\n\t    } else if (typeof a === \"number\") {\r\n\t        tmp = Sk.builtin.assk$(a);\r\n\t        return [tmp, b];\r\n\t    } else {\r\n\t        return undefined;\r\n\t    }\r\n\t};\r\n\r\n\tSk.abstr.boNumPromote_ = {\r\n\t    \"Add\"     : function (a, b) {\r\n\t        return a + b;\r\n\t    },\r\n\t    \"Sub\"     : function (a, b) {\r\n\t        return a - b;\r\n\t    },\r\n\t    \"Mult\"    : function (a, b) {\r\n\t        return a * b;\r\n\t    },\r\n\t    \"Mod\"     : function (a, b) {\r\n\t        var m;\r\n\t        if (b === 0) {\r\n\t            throw new Sk.builtin.ZeroDivisionError(\"division or modulo by zero\");\r\n\t        }\r\n\t        m = a % b;\r\n\t        return ((m * b) < 0 ? (m + b) : m);\r\n\t    },\r\n\t    \"Div\"     : function (a, b) {\r\n\t        if (b === 0) {\r\n\t            throw new Sk.builtin.ZeroDivisionError(\"division or modulo by zero\");\r\n\t        } else {\r\n\t            return a / b;\r\n\t        }\r\n\t    },\r\n\t    \"FloorDiv\": function (a, b) {\r\n\t        if (b === 0) {\r\n\t            throw new Sk.builtin.ZeroDivisionError(\"division or modulo by zero\");\r\n\t        } else {\r\n\t            return Math.floor(a / b);\r\n\t        } // todo; wrong? neg?\r\n\t    },\r\n\t    \"Pow\"     : Math.pow,\r\n\t    \"BitAnd\"  : function (a, b) {\r\n\t        var m = a & b;\r\n\t        if (m < 0) {\r\n\t            m = m + 4294967296; // convert back to unsigned\r\n\t        }\r\n\t        return m;\r\n\t    },\r\n\t    \"BitOr\"   : function (a, b) {\r\n\t        var m = a | b;\r\n\t        if (m < 0) {\r\n\t            m = m + 4294967296; // convert back to unsigned\r\n\t        }\r\n\t        return m;\r\n\t    },\r\n\t    \"BitXor\"  : function (a, b) {\r\n\t        var m = a ^ b;\r\n\t        if (m < 0) {\r\n\t            m = m + 4294967296; // convert back to unsigned\r\n\t        }\r\n\t        return m;\r\n\t    },\r\n\t    \"LShift\"  : function (a, b) {\r\n\t        var m;\r\n\t        if (b < 0) {\r\n\t            throw new Sk.builtin.ValueError(\"negative shift count\");\r\n\t        }\r\n\t        m = a << b;\r\n\t        if (m > a) {\r\n\t            return m;\r\n\t        } else {\r\n\t            // Fail, this will get recomputed with longs\r\n\t            return a * Math.pow(2, b);\r\n\t        }\r\n\t    },\r\n\t    \"RShift\"  : function (a, b) {\r\n\t        var m;\r\n\t        if (b < 0) {\r\n\t            throw new Sk.builtin.ValueError(\"negative shift count\");\r\n\t        }\r\n\t        m = a >> b;\r\n\t        if ((a > 0) && (m < 0)) {\r\n\t            // fix incorrect sign extension\r\n\t            m = m & (Math.pow(2, 32 - b) - 1);\r\n\t        }\r\n\t        return m;\r\n\t    }\r\n\t};\r\n\r\n\tSk.abstr.numberBinOp = function (v, w, op) {\r\n\t    var tmp;\r\n\t    var numPromoteFunc = Sk.abstr.boNumPromote_[op];\r\n\t    if (numPromoteFunc !== undefined) {\r\n\t        tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);\r\n\t        if (typeof tmp === \"number\") {\r\n\t            return tmp;\r\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.int_) {\r\n\t            return tmp;\r\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.float_) {\r\n\t            return tmp;\r\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {\r\n\t            return tmp;\r\n\t        } else if (tmp !== undefined) {\r\n\t            v = tmp[0];\r\n\t            w = tmp[1];\r\n\t        }\r\n\t    }\r\n\r\n\t    return Sk.abstr.binary_op_(v, w, op);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.abstr.numberBinOp\", Sk.abstr.numberBinOp);\r\n\r\n\tSk.abstr.numberInplaceBinOp = function (v, w, op) {\r\n\t    var tmp;\r\n\t    var numPromoteFunc = Sk.abstr.boNumPromote_[op];\r\n\t    if (numPromoteFunc !== undefined) {\r\n\t        tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);\r\n\t        if (typeof tmp === \"number\") {\r\n\t            return tmp;\r\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.int_) {\r\n\t            return tmp;\r\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.float_) {\r\n\t            return tmp;\r\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {\r\n\t            return tmp;\r\n\t        } else if (tmp !== undefined) {\r\n\t            v = tmp[0];\r\n\t            w = tmp[1];\r\n\t        }\r\n\t    }\r\n\r\n\t    return Sk.abstr.binary_iop_(v, w, op);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.abstr.numberInplaceBinOp\", Sk.abstr.numberInplaceBinOp);\r\n\r\n\tSk.abstr.numberUnaryOp = function (v, op) {\r\n\t    var value;\r\n\t    if (op === \"Not\") {\r\n\t        return Sk.misceval.isTrue(v) ? Sk.builtin.bool.false$ : Sk.builtin.bool.true$;\r\n\t    } else if (v instanceof Sk.builtin.bool) {\r\n\t        value = Sk.builtin.asnum$(v);\r\n\t        if (op === \"USub\") {\r\n\t            return new Sk.builtin.int_(-value);\r\n\t        }\r\n\t        if (op === \"UAdd\") {\r\n\t            return new Sk.builtin.int_(value);\r\n\t        }\r\n\t        if (op === \"Invert\") {\r\n\t            return new Sk.builtin.int_(~value);\r\n\t        }\r\n\t    } else {\r\n\t        if (op === \"USub\" && v.nb$negative) {\r\n\t            return v.nb$negative();\r\n\t        }\r\n\t        if (op === \"UAdd\" && v.nb$positive) {\r\n\t            return v.nb$positive();\r\n\t        }\r\n\t        if (op === \"Invert\" && v.nb$invert) {\r\n\t            return v.nb$invert();\r\n\t        }\r\n\t    }\r\n\r\n\t    return Sk.abstr.unary_op_(v, op);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.abstr.numberUnaryOp\", Sk.abstr.numberUnaryOp);\r\n\r\n\t//\r\n\t// Sequence\r\n\t//\r\n\r\n\tSk.abstr.fixSeqIndex_ = function (seq, i) {\r\n\t    i = Sk.builtin.asnum$(i);\r\n\t    if (i < 0 && seq.sq$length) {\r\n\t        i += seq.sq$length();\r\n\t    }\r\n\t    return i;\r\n\t};\r\n\r\n\t/**\r\n\t * @param {*} seq\r\n\t * @param {*} ob\r\n\t * @param {boolean=} canSuspend\r\n\t */\r\n\tSk.abstr.sequenceContains = function (seq, ob, canSuspend) {\r\n\t    var seqtypename;\r\n\t    var special;\r\n\t    var r;\r\n\r\n\t    if (seq.sq$contains) {\r\n\t        return seq.sq$contains(ob);\r\n\t    }\r\n\r\n\t    /**\r\n\t     *  Look for special method and call it, we have to distinguish between built-ins and\r\n\t     *  python objects\r\n\t     */\r\n\t    special = Sk.abstr.lookupSpecial(seq, \"__contains__\");\r\n\t    if (special != null) {\r\n\t        // method on builtin, provide this arg\r\n\t        return Sk.misceval.isTrue(Sk.misceval.callsim(special, seq, ob));\r\n\t    }\r\n\r\n\t    if (!Sk.builtin.checkIterable(seq)) {\r\n\t        seqtypename = Sk.abstr.typeName(seq);\r\n\t        throw new Sk.builtin.TypeError(\"argument of type '\" + seqtypename + \"' is not iterable\");\r\n\t    }\r\n\r\n\t    r = Sk.misceval.iterFor(Sk.abstr.iter(seq), function(i) {\r\n\t        if (Sk.misceval.richCompareBool(i, ob, \"Eq\")) {\r\n\t            return new Sk.misceval.Break(true);\r\n\t        } else {\r\n\t            return false;\r\n\t        }\r\n\t    }, false);\r\n\r\n\t    return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\r\n\t};\r\n\r\n\tSk.abstr.sequenceConcat = function (seq1, seq2) {\r\n\t    var seq1typename;\r\n\t    if (seq1.sq$concat) {\r\n\t        return seq1.sq$concat(seq2);\r\n\t    }\r\n\t    seq1typename = Sk.abstr.typeName(seq1);\r\n\t    throw new Sk.builtin.TypeError(\"'\" + seq1typename + \"' object can't be concatenated\");\r\n\t};\r\n\r\n\tSk.abstr.sequenceGetIndexOf = function (seq, ob) {\r\n\t    var seqtypename;\r\n\t    var i, it;\r\n\t    var index;\r\n\t    if (seq.index) {\r\n\t        return Sk.misceval.callsim(seq.index, seq, ob);\r\n\t    }\r\n\t    if (Sk.builtin.checkIterable(seq)) {\r\n\t        index = 0;\r\n\t        for (it = Sk.abstr.iter(seq), i = it.tp$iternext();\r\n\t             i !== undefined; i = it.tp$iternext()) {\r\n\t            if (Sk.misceval.richCompareBool(ob, i, \"Eq\")) {\r\n\t                return new Sk.builtin.int_(index);\r\n\t            }\r\n\t            index += 1;\r\n\t        }\r\n\t        throw new Sk.builtin.ValueError(\"sequence.index(x): x not in sequence\");\r\n\t    }\r\n\r\n\t    seqtypename = Sk.abstr.typeName(seq);\r\n\t    throw new Sk.builtin.TypeError(\"argument of type '\" + seqtypename + \"' is not iterable\");\r\n\t};\r\n\r\n\tSk.abstr.sequenceGetCountOf = function (seq, ob) {\r\n\t    var seqtypename;\r\n\t    var i, it;\r\n\t    var count;\r\n\t    if (seq.count) {\r\n\t        return Sk.misceval.callsim(seq.count, seq, ob);\r\n\t    }\r\n\t    if (Sk.builtin.checkIterable(seq)) {\r\n\t        count = 0;\r\n\t        for (it = Sk.abstr.iter(seq), i = it.tp$iternext();\r\n\t             i !== undefined; i = it.tp$iternext()) {\r\n\t            if (Sk.misceval.richCompareBool(ob, i, \"Eq\")) {\r\n\t                count += 1;\r\n\t            }\r\n\t        }\r\n\t        return new Sk.builtin.int_(count);\r\n\t    }\r\n\r\n\t    seqtypename = Sk.abstr.typeName(seq);\r\n\t    throw new Sk.builtin.TypeError(\"argument of type '\" + seqtypename + \"' is not iterable\");\r\n\t};\r\n\r\n\tSk.abstr.sequenceGetItem = function (seq, i, canSuspend) {\r\n\t    var seqtypename;\r\n\t    if (seq.mp$subscript) {\r\n\t        return seq.mp$subscript(i);\r\n\t    }\r\n\r\n\t    seqtypename = Sk.abstr.typeName(seq);\r\n\t    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object is unsubscriptable\");\r\n\t};\r\n\r\n\tSk.abstr.sequenceSetItem = function (seq, i, x, canSuspend) {\r\n\t    var seqtypename;\r\n\t    if (seq.mp$ass_subscript) {\r\n\t        return seq.mp$ass_subscript(i, x);\r\n\t    }\r\n\r\n\t    seqtypename = Sk.abstr.typeName(seq);\r\n\t    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object does not support item assignment\");\r\n\t};\r\n\r\n\tSk.abstr.sequenceDelItem = function (seq, i) {\r\n\t    var seqtypename;\r\n\t    if (seq.sq$del_item) {\r\n\t        i = Sk.abstr.fixSeqIndex_(seq, i);\r\n\t        seq.sq$del_item(i);\r\n\t        return;\r\n\t    }\r\n\r\n\t    seqtypename = Sk.abstr.typeName(seq);\r\n\t    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object does not support item deletion\");\r\n\t};\r\n\r\n\tSk.abstr.sequenceRepeat = function (f, seq, n) {\r\n\t    var ntypename;\r\n\t    var count;\r\n\t    n = Sk.builtin.asnum$(n);\r\n\t    count = Sk.misceval.asIndex(n);\r\n\t    if (count === undefined) {\r\n\t        ntypename = Sk.abstr.typeName(n);\r\n\t        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + ntypename + \"'\");\r\n\t    }\r\n\t    return f.call(seq, n);\r\n\t};\r\n\r\n\tSk.abstr.sequenceGetSlice = function (seq, i1, i2) {\r\n\t    var seqtypename;\r\n\t    if (seq.sq$slice) {\r\n\t        i1 = Sk.abstr.fixSeqIndex_(seq, i1);\r\n\t        i2 = Sk.abstr.fixSeqIndex_(seq, i2);\r\n\t        return seq.sq$slice(i1, i2);\r\n\t    } else if (seq.mp$subscript) {\r\n\t        return seq.mp$subscript(new Sk.builtin.slice(i1, i2));\r\n\t    }\r\n\r\n\t    seqtypename = Sk.abstr.typeName(seq);\r\n\t    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object is unsliceable\");\r\n\t};\r\n\r\n\tSk.abstr.sequenceDelSlice = function (seq, i1, i2) {\r\n\t    var seqtypename;\r\n\t    if (seq.sq$del_slice) {\r\n\t        i1 = Sk.abstr.fixSeqIndex_(seq, i1);\r\n\t        i2 = Sk.abstr.fixSeqIndex_(seq, i2);\r\n\t        seq.sq$del_slice(i1, i2);\r\n\t        return;\r\n\t    }\r\n\r\n\t    seqtypename = Sk.abstr.typeName(seq);\r\n\t    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' doesn't support slice deletion\");\r\n\t};\r\n\r\n\tSk.abstr.sequenceSetSlice = function (seq, i1, i2, x) {\r\n\t    var seqtypename;\r\n\t    if (seq.sq$ass_slice) {\r\n\t        i1 = Sk.abstr.fixSeqIndex_(seq, i1);\r\n\t        i2 = Sk.abstr.fixSeqIndex_(seq, i2);\r\n\t        seq.sq$ass_slice(i1, i2, x);\r\n\t    } else if (seq.mp$ass_subscript) {\r\n\t        seq.mp$ass_subscript(new Sk.builtin.slice(i1, i2), x);\r\n\t    } else {\r\n\t        seqtypename = Sk.abstr.typeName(seq);\r\n\t        throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object doesn't support slice assignment\");\r\n\t    }\r\n\t};\r\n\r\n\t// seq - Python object to unpack\r\n\t// n   - JavaScript number of items to unpack\r\n\tSk.abstr.sequenceUnpack = function (seq, n) {\r\n\t    var res = [];\r\n\t    var it, i;\r\n\r\n\t    if (!Sk.builtin.checkIterable(seq)) {\r\n\t        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(seq) + \"' object is not iterable\");\r\n\t    }\r\n\r\n\t    for (it = Sk.abstr.iter(seq), i = it.tp$iternext();\r\n\t         (i !== undefined) && (res.length < n);\r\n\t         i = it.tp$iternext()) {\r\n\t        res.push(i);\r\n\t    }\r\n\r\n\t    if (res.length < n) {\r\n\t        throw new Sk.builtin.ValueError(\"need more than \" + res.length + \" values to unpack\");\r\n\t    }\r\n\t    if (i !== undefined) {\r\n\t        throw new Sk.builtin.ValueError(\"too many values to unpack\");\r\n\t    }\r\n\r\n\t    // Return Javascript array of items\r\n\t    return res;\r\n\t};\r\n\r\n\t//\r\n\t// Object\r\n\t//\r\n\r\n\tSk.abstr.objectFormat = function (obj, format_spec) {\r\n\t    var meth; // PyObject\r\n\t    var result; // PyObject\r\n\r\n\t    // If no format_spec is provided, use an empty string\r\n\t    if(format_spec == null) {\r\n\t        format_spec = \"\";\r\n\t    }\r\n\r\n\t    // Find the (unbound!) __format__ method (a borrowed reference)\r\n\t    meth = Sk.abstr.lookupSpecial(obj, \"__format__\");\r\n\t    if (meth == null) {\r\n\t        throw new Sk.builtin.TypeError(\"Type \" + Sk.abstr.typeName(obj) + \"doesn't define __format__\");\r\n\t    }\r\n\r\n\t    // And call it\r\n\t    result = Sk.misceval.callsim(meth, obj, format_spec);\r\n\t    if (!Sk.builtin.checkString(result)) {\r\n\t        throw new Sk.builtin.TypeError(\"__format__ must return a str, not \" + Sk.abstr.typeName(result));\r\n\t    }\r\n\r\n\t    return result;\r\n\t};\r\n\r\n\tSk.abstr.objectAdd = function (a, b) {\r\n\t    var btypename;\r\n\t    var atypename;\r\n\t    if (a.nb$add) {\r\n\t        return a.nb$add(b);\r\n\t    }\r\n\r\n\t    atypename = Sk.abstr.typeName(a);\r\n\t    btypename = Sk.abstr.typeName(b);\r\n\t    throw new Sk.builtin.TypeError(\"unsupported operand type(s) for +: '\" + atypename + \"' and '\" + btypename + \"'\");\r\n\t};\r\n\r\n\t// in Python 2.6, this behaviour seems to be defined for numbers and bools (converts bool to int)\r\n\tSk.abstr.objectNegative = function (obj) {\r\n\t    var objtypename;\r\n\t    var obj_asnum = Sk.builtin.asnum$(obj); // this will also convert bool type to int\r\n\r\n\t    if (obj instanceof Sk.builtin.bool) {\r\n\t        obj = new Sk.builtin.int_(obj_asnum);\r\n\t    }\r\n\r\n\t    if (obj.nb$negative) {\r\n\t        return obj.nb$negative();\r\n\t    }\r\n\r\n\t    objtypename = Sk.abstr.typeName(obj);\r\n\t    throw new Sk.builtin.TypeError(\"bad operand type for unary -: '\" + objtypename + \"'\");\r\n\t};\r\n\r\n\t// in Python 2.6, this behaviour seems to be defined for numbers and bools (converts bool to int)\r\n\tSk.abstr.objectPositive = function (obj) {\r\n\t    var objtypename = Sk.abstr.typeName(obj);\r\n\t    var obj_asnum = Sk.builtin.asnum$(obj); // this will also convert bool type to int\r\n\r\n\t    if (obj instanceof Sk.builtin.bool) {\r\n\t        obj = new Sk.builtin.int_(obj_asnum);\r\n\t    }\r\n\r\n\t    if (obj.nb$negative) {\r\n\t        return obj.nb$positive();\r\n\t    }\r\n\r\n\t    throw new Sk.builtin.TypeError(\"bad operand type for unary +: '\" + objtypename + \"'\");\r\n\t};\r\n\r\n\tSk.abstr.objectDelItem = function (o, key) {\r\n\t    var otypename;\r\n\t    var keytypename;\r\n\t    var keyValue;\r\n\t    if (o !== null) {\r\n\t        if (o.mp$del_subscript) {\r\n\t            o.mp$del_subscript(key);\r\n\t            return;\r\n\t        }\r\n\t        if (o.sq$ass_item) {\r\n\t            keyValue = Sk.misceval.asIndex(key);\r\n\t            if (keyValue === undefined) {\r\n\t                keytypename = Sk.abstr.typeName(key);\r\n\t                throw new Sk.builtin.TypeError(\"sequence index must be integer, not '\" + keytypename + \"'\");\r\n\t            }\r\n\t            Sk.abstr.sequenceDelItem(o, keyValue);\r\n\t            return;\r\n\t        }\r\n\t        // if o is a slice do something else...\r\n\t    }\r\n\r\n\t    otypename = Sk.abstr.typeName(o);\r\n\t    throw new Sk.builtin.TypeError(\"'\" + otypename + \"' object does not support item deletion\");\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.abstr.objectDelItem\", Sk.abstr.objectDelItem);\r\n\r\n\tSk.abstr.objectGetItem = function (o, key, canSuspend) {\r\n\t    var otypename;\r\n\t    if (o !== null) {\r\n\t        if (o.tp$getitem) {\r\n\t            return o.tp$getitem(key, canSuspend);\r\n\t        } else if (o.mp$subscript) {\r\n\t            return o.mp$subscript(key, canSuspend);\r\n\t        } else if (Sk.misceval.isIndex(key) && o.sq$item) {\r\n\t            return Sk.abstr.sequenceGetItem(o, Sk.misceval.asIndex(key), canSuspend);\r\n\t        }\r\n\t    }\r\n\r\n\t    otypename = Sk.abstr.typeName(o);\r\n\t    throw new Sk.builtin.TypeError(\"'\" + otypename + \"' does not support indexing\");\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.abstr.objectGetItem\", Sk.abstr.objectGetItem);\r\n\r\n\tSk.abstr.objectSetItem = function (o, key, v, canSuspend) {\r\n\t    var otypename;\r\n\t    if (o !== null) {\r\n\t        if (o.tp$setitem) {\r\n\t            return o.tp$setitem(key, v, canSuspend);\r\n\t        } else if (o.mp$ass_subscript) {\r\n\t            return o.mp$ass_subscript(key, v, canSuspend);\r\n\t        } else if (Sk.misceval.isIndex(key) && o.sq$ass_item) {\r\n\t            return Sk.abstr.sequenceSetItem(o, Sk.misceval.asIndex(key), v, canSuspend);\r\n\t        }\r\n\t    }\r\n\r\n\t    otypename = Sk.abstr.typeName(o);\r\n\t    throw new Sk.builtin.TypeError(\"'\" + otypename + \"' does not support item assignment\");\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.abstr.objectSetItem\", Sk.abstr.objectSetItem);\r\n\r\n\r\n\tSk.abstr.gattr = function (obj, nameJS, canSuspend) {\r\n\t    var ret, f;\r\n\t    var objname = Sk.abstr.typeName(obj);\r\n\r\n\t    if (obj === null) {\r\n\t        throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + nameJS + \"'\");\r\n\t    }\r\n\r\n\r\n\t    if (obj.tp$getattr !== undefined) {\r\n\t        f = obj.tp$getattr(\"__getattribute__\");\r\n\t    }\r\n\r\n\t    if (f !== undefined) {\r\n\t        ret = Sk.misceval.callsimOrSuspend(f, new Sk.builtin.str(nameJS));\r\n\t    }\r\n\r\n\t    ret = Sk.misceval.chain(ret, function(ret) {\r\n\t        var f;\r\n\r\n\t        if (ret === undefined && obj.tp$getattr !== undefined) {\r\n\t            ret = obj.tp$getattr(nameJS);\r\n\r\n\t            if (ret === undefined) {\r\n\t                f = obj.tp$getattr(\"__getattr__\");\r\n\r\n\t                if (f !== undefined) {\r\n\t                    ret = Sk.misceval.callsimOrSuspend(f, new Sk.builtin.str(nameJS));\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        return ret;\r\n\t    }, function(r) {\r\n\t        if (r === undefined) {\r\n\t            throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + nameJS + \"'\");\r\n\t        }\r\n\t        return r;\r\n\t    });\r\n\r\n\t    return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.abstr.gattr\", Sk.abstr.gattr);\r\n\r\n\tSk.abstr.sattr = function (obj, nameJS, data, canSuspend) {\r\n\t    var objname = Sk.abstr.typeName(obj), r, setf;\r\n\r\n\t    if (obj === null) {\r\n\t        throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + nameJS + \"'\");\r\n\t    }\r\n\r\n\t    if (obj.tp$getattr !== undefined) {\r\n\t        setf = obj.tp$getattr(\"__setattr__\");\r\n\t        if (setf !== undefined) {\r\n\t            r = Sk.misceval.callsimOrSuspend(setf, new Sk.builtin.str(nameJS), data);\r\n\t            return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\r\n\t        }\r\n\t    }\r\n\r\n\t    if (obj.tp$setattr !== undefined) {\r\n\t        obj.tp$setattr(nameJS, data);\r\n\t    } else {\r\n\t        throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + nameJS + \"'\");\r\n\t    }\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.abstr.sattr\", Sk.abstr.sattr);\r\n\r\n\r\n\tSk.abstr.iternext = function (it, canSuspend) {\r\n\t    return it.tp$iternext(canSuspend);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.abstr.iternext\", Sk.abstr.iternext);\r\n\r\n\r\n\t/**\r\n\t * Get the iterator for a Python object  This iterator could be one of the following.\r\n\t * This is the preferred mechanism for consistently getting the correct iterator.  You should\r\n\t * not just use tp$iter because that could lead to incorrect behavior of a user created class.\r\n\t *\r\n\t * - tp$iter\r\n\t * - A user defined `__iter__` method\r\n\t * - A user defined `__getitem__` method\r\n\t *\r\n\t * @param obj\r\n\t *\r\n\t * @throws {Sk.builtin.TypeError}\r\n\t * @returns {Object}\r\n\t */\r\n\r\n\tSk.abstr.iter = function(obj) {\r\n\t    var iter;\r\n\t    var getit;\r\n\t    var ret;\r\n\r\n\t    /**\r\n\t     * Builds an iterator around classes that have a __getitem__ method.\r\n\t     *\r\n\t     * @constructor\r\n\t     */\r\n\t    var seqIter = function (obj) {\r\n\t        this.idx = 0;\r\n\t        this.myobj = obj;\r\n\t        this.getitem = Sk.abstr.lookupSpecial(obj, \"__getitem__\");\r\n\t        this.tp$iternext = function () {\r\n\t            var ret;\r\n\t            try {\r\n\t                ret = Sk.misceval.callsim(this.getitem, this.myobj, Sk.ffi.remapToPy(this.idx));\r\n\t            } catch (e) {\r\n\t                if (e instanceof Sk.builtin.IndexError || e instanceof Sk.builtin.StopIteration) {\r\n\t                    return undefined;\r\n\t                } else {\r\n\t                    throw e;\r\n\t                }\r\n\t            }\r\n\t            this.idx++;\r\n\t            return ret;\r\n\t        };\r\n\t    };\r\n\r\n\t    if (obj.tp$getattr) {\r\n\t        iter =  Sk.abstr.lookupSpecial(obj,\"__iter__\");\r\n\t        if (iter) {\r\n\t            ret = Sk.misceval.callsim(iter, obj);\r\n\t            if (ret.tp$iternext) {\r\n\t                return ret;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    if (obj.tp$iter) {\r\n\t        try {  // catch and ignore not iterable error here.\r\n\t            ret = obj.tp$iter();\r\n\t            if (ret.tp$iternext) {\r\n\t                return ret;\r\n\t            }\r\n\t        } catch (e) { }\r\n\t    }\r\n\t    getit = Sk.abstr.lookupSpecial(obj, \"__getitem__\");\r\n\t    if (getit) {\r\n\t        // create internal iterobject if __getitem__\r\n\t        return new seqIter(obj);\r\n\t    }\r\n\t    throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(obj) + \"' object is not iterable\");\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.abstr.iter\", Sk.abstr.iter);\r\n\r\n\t/**\r\n\t * Special method look up. First try getting the method via\r\n\t * internal dict and getattr. If getattr is not present (builtins)\r\n\t * try if method is defined on the object itself\r\n\t *\r\n\t * @returns {null|Object} Return null if not found or the function\r\n\t */\r\n\tSk.abstr.lookupSpecial = function(op, str) {\r\n\t    var res;\r\n\t    var obtp;\r\n\t    if (op.ob$type) {\r\n\t        obtp = op.ob$type;\r\n\t    } else {\r\n\t        return null;\r\n\t    }\r\n\r\n\t    return Sk.builtin.type.typeLookup(obtp, str);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.abstr.lookupSpecial\", Sk.abstr.lookupSpecial);\r\n\r\n\t/**\r\n\t * Mark a class as unhashable and prevent its `__hash__` function from being called.\r\n\t * @param  {function(...[?])} thisClass The class to mark as unhashable.\r\n\t * @return {undefined}\r\n\t */\r\n\tSk.abstr.markUnhashable = function (thisClass) {\r\n\t    var proto = thisClass.prototype;\r\n\t    proto.__hash__ = Sk.builtin.none.none$;\r\n\t    proto.tp$hash = Sk.builtin.none.none$;\r\n\t};\r\n\r\n\t/**\r\n\t * Set up inheritance between two Python classes. This allows only for single\r\n\t * inheritance -- multiple inheritance is not supported by Javascript.\r\n\t *\r\n\t * Javascript's inheritance is prototypal. This means that properties must\r\n\t * be defined on the superclass' prototype in order for subclasses to inherit\r\n\t * them.\r\n\t *\r\n\t * ```\r\n\t * Sk.superclass.myProperty                 # will NOT be inherited\r\n\t * Sk.superclass.prototype.myProperty       # will be inherited\r\n\t * ```\r\n\t *\r\n\t * In order for a class to be subclassable, it must (directly or indirectly)\r\n\t * inherit from Sk.builtin.object so that it will be properly initialized in\r\n\t * {@link Sk.doOneTimeInitialization} (in src/import.js). Further, all Python\r\n\t * builtins should inherit from Sk.builtin.object.\r\n\t *\r\n\t * @param {string} childName The Python name of the child (subclass).\r\n\t * @param {function(...[?])} child     The subclass.\r\n\t * @param {function(...[?])} parent    The superclass.\r\n\t * @return {undefined}\r\n\t */\r\n\tSk.abstr.setUpInheritance = function (childName, child, parent) {\r\n\t    goog.inherits(child, parent);\r\n\t    child.prototype.tp$base = parent;\r\n\t    child.prototype.tp$name = childName;\r\n\t    child.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(childName, child);\r\n\t};\r\n\r\n\t/**\r\n\t * Call the super constructor of the provided class, with the object `self` as\r\n\t * the `this` value of that constructor. Any arguments passed to this function\r\n\t * after `self` will be passed as-is to the constructor.\r\n\t *\r\n\t * @param  {function(...[?])} thisClass The subclass.\r\n\t * @param  {Object} self      The instance of the subclas.\r\n\t * @param  {...?} args Arguments to pass to the constructor.\r\n\t * @return {undefined}\r\n\t */\r\n\tSk.abstr.superConstructor = function (thisClass, self, args) {\r\n\t    var argumentsForConstructor = Array.prototype.slice.call(arguments, 2);\r\n\t    thisClass.prototype.tp$base.apply(self, argumentsForConstructor);\r\n\t};\r\n\r\n\r\n\r\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/object.js ---- */ \r\n\r\n\t/**\r\n\t * @constructor\r\n\t * Sk.builtin.object\r\n\t *\r\n\t * @description\r\n\t * Constructor for Python object. All Python classes (builtin and user-defined)\r\n\t * should inherit from this class.\r\n\t *\r\n\t * @return {Sk.builtin.object} Python object\r\n\t */\r\n\tSk.builtin.object = function () {\r\n\t    if (!(this instanceof Sk.builtin.object)) {\r\n\t        return new Sk.builtin.object();\r\n\t    }\r\n\r\n\t    return this;\r\n\t};\r\n\r\n\r\n\r\n\tvar _tryGetSubscript = function(dict, pyName) {\r\n\t    try {\r\n\t        return dict.mp$subscript(pyName);\r\n\t    } catch (x) {\r\n\t        return undefined;\r\n\t    }\r\n\t};\r\n\r\n\t/**\r\n\t * @return {undefined}\r\n\t */\r\n\tSk.builtin.object.prototype.GenericGetAttr = function (name) {\r\n\t    var res;\r\n\t    var f;\r\n\t    var descr;\r\n\t    var tp;\r\n\t    var dict;\r\n\t    var pyName = new Sk.builtin.str(name);\r\n\t    goog.asserts.assert(typeof name === \"string\");\r\n\r\n\t    tp = this.ob$type;\r\n\t    goog.asserts.assert(tp !== undefined, \"object has no ob$type!\");\r\n\r\n\t    dict = this[\"$d\"] || this.constructor[\"$d\"];\r\n\r\n\t    // todo; assert? force?\r\n\t    if (dict) {\r\n\t        if (dict.mp$lookup) {\r\n\t            res = dict.mp$lookup(pyName);\r\n\t        } else if (dict.mp$subscript) {\r\n\t            res = _tryGetSubscript(dict, pyName);\r\n\t        } else if (typeof dict === \"object\") {\r\n\t            // todo; definitely the wrong place for this. other custom tp$getattr won't work on object -- bnm -- implemented custom __getattr__ in abstract.js\r\n\t            res = dict[name];\r\n\t        }\r\n\t        if (res !== undefined) {\r\n\t            return res;\r\n\t        }\r\n\t    }\r\n\r\n\t    descr = Sk.builtin.type.typeLookup(tp, name);\r\n\r\n\t    // otherwise, look in the type for a descr\r\n\t    if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {\r\n\t        f = descr.ob$type.tp$descr_get;\r\n\t        if (!(f) && descr[\"__get__\"]) {\r\n\t            f = descr[\"__get__\"];\r\n\t            return Sk.misceval.callsimOrSuspend(f, descr, this, Sk.builtin.none.none$);\r\n\t        }\r\n\t        // todo;\r\n\t        // if (f && descr.tp$descr_set) // is a data descriptor if it has a set\r\n\t        // return f.call(descr, this, this.ob$type);\r\n\r\n\t        if (f) {\r\n\t            // non-data descriptor\r\n\t            return f.call(descr, this, this.ob$type);\r\n\t        }\r\n\t    }\r\n\r\n\t    if (descr !== undefined) {\r\n\t        return descr;\r\n\t    }\r\n\r\n\t    return undefined;\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.object.prototype.GenericGetAttr\", Sk.builtin.object.prototype.GenericGetAttr);\r\n\r\n\tSk.builtin.object.prototype.GenericPythonGetAttr = function(self, name) {\r\n\t    return Sk.builtin.object.prototype.GenericGetAttr.call(self, name.v);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.object.prototype.GenericPythonGetAttr\", Sk.builtin.object.prototype.GenericPythonGetAttr);\r\n\r\n\tSk.builtin.object.prototype.GenericSetAttr = function (name, value) {\r\n\t    var objname = Sk.abstr.typeName(this);\r\n\t    var pyname;\r\n\t    var dict;\r\n\t    var tp = this.ob$type;\r\n\t    var descr;\r\n\t    var f;\r\n\r\n\t    goog.asserts.assert(typeof name === \"string\");\r\n\t    goog.asserts.assert(tp !== undefined, \"object has no ob$type!\");\r\n\r\n\t    dict = this[\"$d\"] || this.constructor[\"$d\"];\r\n\r\n\t    descr = Sk.builtin.type.typeLookup(tp, name);\r\n\r\n\t    // otherwise, look in the type for a descr\r\n\t    if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {\r\n\t        //f = descr.ob$type.tp$descr_set;\r\n\t        if (descr[\"__set__\"]) {\r\n\t            f = descr[\"__set__\"];\r\n\t            Sk.misceval.callsimOrSuspend(f, descr, this, value);\r\n\t            return;\r\n\t        }\r\n\t        // todo;\r\n\t        //if (f && descr.tp$descr_set) // is a data descriptor if it has a set\r\n\t        //return f.call(descr, this, this.ob$type);\r\n\t    }\r\n\r\n\t    if (dict.mp$ass_subscript) {\r\n\t        pyname = new Sk.builtin.str(name);\r\n\r\n\t        if (this instanceof Sk.builtin.object && !(this.ob$type.sk$klass) &&\r\n\t            dict.mp$lookup(pyname) === undefined) {\r\n\t            // Cannot add new attributes to a builtin object\r\n\t            throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + name + \"'\");\r\n\t        }\r\n\t        dict.mp$ass_subscript(new Sk.builtin.str(name), value);\r\n\t    } else if (typeof dict === \"object\") {\r\n\t        dict[name] = value;\r\n\t    }\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.object.prototype.GenericSetAttr\", Sk.builtin.object.prototype.GenericSetAttr);\r\n\r\n\tSk.builtin.object.prototype.GenericPythonSetAttr = function(self, name, value) {\r\n\t    return Sk.builtin.object.prototype.GenericSetAttr.call(self, name.v, value);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.object.prototype.GenericPythonSetAttr\", Sk.builtin.object.prototype.GenericPythonSetAttr);\r\n\r\n\tSk.builtin.object.prototype.HashNotImplemented = function () {\r\n\t    throw new Sk.builtin.TypeError(\"unhashable type: '\" + Sk.abstr.typeName(this) + \"'\");\r\n\t};\r\n\r\n\tSk.builtin.object.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\r\n\tSk.builtin.object.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\r\n\r\n\t// Although actual attribute-getting happens in pure Javascript via tp$getattr, classes\r\n\t// overriding __getattr__ etc need to be able to call object.__getattr__ etc from Python\r\n\tSk.builtin.object.prototype[\"__getattr__\"] = Sk.builtin.object.prototype.GenericPythonGetAttr;\r\n\tSk.builtin.object.prototype[\"__setattr__\"] = Sk.builtin.object.prototype.GenericPythonSetAttr;\r\n\r\n\t/**\r\n\t * The name of this class.\r\n\t * @type {string}\r\n\t */\r\n\tSk.builtin.object.prototype.tp$name = \"object\";\r\n\r\n\t/**\r\n\t * The type object of this class.\r\n\t * @type {Sk.builtin.type}\r\n\t */\r\n\tSk.builtin.object.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(\"object\", Sk.builtin.object);\r\n\tSk.builtin.object.prototype.ob$type.sk$klass = undefined;   // Nonsense for closure compiler\r\n\r\n\t/** Default implementations of dunder methods found in all Python objects */\r\n\r\n\t/**\r\n\t * Python wrapper for `__repr__` method.\r\n\t * @name  __repr__\r\n\t * @memberOf Sk.builtin.object.prototype\r\n\t * @instance\r\n\t */\r\n\tSk.builtin.object.prototype[\"__repr__\"] = function (self) {\r\n\t    Sk.builtin.pyCheckArgs(\"__repr__\", arguments, 0, 0, false, true);\r\n\r\n\t    return self[\"$r\"]();\r\n\t};\r\n\r\n\t/**\r\n\t * Python wrapper for `__str__` method.\r\n\t * @name  __str__\r\n\t * @memberOf Sk.builtin.object.prototype\r\n\t * @instance\r\n\t */\r\n\tSk.builtin.object.prototype[\"__str__\"] = function (self) {\r\n\t    Sk.builtin.pyCheckArgs(\"__str__\", arguments, 0, 0, false, true);\r\n\r\n\t    return self[\"$r\"]();\r\n\t};\r\n\r\n\t/**\r\n\t * Python wrapper for `__hash__` method.\r\n\t * @name  __hash__\r\n\t * @memberOf Sk.builtin.object.prototype\r\n\t * @instance\r\n\t */\r\n\tSk.builtin.object.prototype[\"__hash__\"] = function (self) {\r\n\t    Sk.builtin.pyCheckArgs(\"__hash__\", arguments, 0, 0, false, true);\r\n\r\n\t    return self.tp$hash();\r\n\t};\r\n\r\n\t/**\r\n\t * Python wrapper for `__eq__` method.\r\n\t * @name  __eq__\r\n\t * @memberOf Sk.builtin.object.prototype\r\n\t * @instance\r\n\t */\r\n\tSk.builtin.object.prototype[\"__eq__\"] = function (self, other) {\r\n\t    Sk.builtin.pyCheckArgs(\"__eq__\", arguments, 1, 1, false, true);\r\n\r\n\t    return self.ob$eq(other);\r\n\t};\r\n\r\n\t/**\r\n\t * Python wrapper for `__ne__` method.\r\n\t * @name  __ne__\r\n\t * @memberOf Sk.builtin.object.prototype\r\n\t * @instance\r\n\t */\r\n\tSk.builtin.object.prototype[\"__ne__\"] = function (self, other) {\r\n\t    Sk.builtin.pyCheckArgs(\"__ne__\", arguments, 1, 1, false, true);\r\n\r\n\t    return self.ob$ne(other);\r\n\t};\r\n\r\n\t/**\r\n\t * Python wrapper for `__lt__` method.\r\n\t * @name  __lt__\r\n\t * @memberOf Sk.builtin.object.prototype\r\n\t * @instance\r\n\t */\r\n\tSk.builtin.object.prototype[\"__lt__\"] = function (self, other) {\r\n\t    Sk.builtin.pyCheckArgs(\"__lt__\", arguments, 1, 1, false, true);\r\n\r\n\t    return self.ob$lt(other);\r\n\t};\r\n\r\n\t/**\r\n\t * Python wrapper for `__le__` method.\r\n\t * @name  __le__\r\n\t * @memberOf Sk.builtin.object.prototype\r\n\t * @instance\r\n\t */\r\n\tSk.builtin.object.prototype[\"__le__\"] = function (self, other) {\r\n\t    Sk.builtin.pyCheckArgs(\"__le__\", arguments, 1, 1, false, true);\r\n\r\n\t    return self.ob$le(other);\r\n\t};\r\n\r\n\t/**\r\n\t * Python wrapper for `__gt__` method.\r\n\t * @name  __gt__\r\n\t * @memberOf Sk.builtin.object.prototype\r\n\t * @instance\r\n\t */\r\n\tSk.builtin.object.prototype[\"__gt__\"] = function (self, other) {\r\n\t    Sk.builtin.pyCheckArgs(\"__gt__\", arguments, 1, 1, false, true);\r\n\r\n\t    return self.ob$gt(other);\r\n\t};\r\n\r\n\t/**\r\n\t * Python wrapper for `__ge__` method.\r\n\t * @name  __ge__\r\n\t * @memberOf Sk.builtin.object.prototype\r\n\t * @instance\r\n\t */\r\n\tSk.builtin.object.prototype[\"__ge__\"] = function (self, other) {\r\n\t    Sk.builtin.pyCheckArgs(\"__ge__\", arguments, 1, 1, false, true);\r\n\r\n\t    return self.ob$ge(other);\r\n\t};\r\n\r\n\t/** Default implementations of Javascript functions used in dunder methods */\r\n\r\n\t/**\r\n\t * Return the string representation of this instance.\r\n\t *\r\n\t * Javascript function, returns Python object.\r\n\t *\r\n\t * @name  $r\r\n\t * @memberOf Sk.builtin.object.prototype\r\n\t * @return {Sk.builtin.str} The Python string representation of this instance.\r\n\t */\r\n\tSk.builtin.object.prototype[\"$r\"] = function () {\r\n\t    return new Sk.builtin.str(\"<object>\");\r\n\t};\r\n\r\n\tSk.builtin.hashCount = 1;\r\n\tSk.builtin.idCount = 1;\r\n\r\n\t/**\r\n\t * Return the hash value of this instance.\r\n\t *\r\n\t * Javascript function, returns Python object.\r\n\t *\r\n\t * @return {Sk.builtin.int_} The hash value\r\n\t */\r\n\tSk.builtin.object.prototype.tp$hash = function () {\r\n\t    if (!this.$savedHash_) {\r\n\t        this.$savedHash_ = new Sk.builtin.int_(Sk.builtin.hashCount++);\r\n\t    }\r\n\r\n\t    return this.$savedHash_;\r\n\t};\r\n\r\n\t/**\r\n\t * Perform equality check between this instance and a Python object (i.e. this == other).\r\n\t *\r\n\t * Implements `__eq__` dunder method.\r\n\t *\r\n\t * Javascript function, returns Python object.\r\n\t *\r\n\t * @param  {Object} other The Python object to check for equality.\r\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if equal, false otherwise\r\n\t */\r\n\tSk.builtin.object.prototype.ob$eq = function (other) {\r\n\t    if (this === other) {\r\n\t        return Sk.builtin.bool.true$;\r\n\t    }\r\n\r\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\r\n\t};\r\n\r\n\t/**\r\n\t * Perform non-equality check between this instance and a Python object (i.e. this != other).\r\n\t *\r\n\t * Implements `__ne__` dunder method.\r\n\t *\r\n\t * Javascript function, returns Python object.\r\n\t *\r\n\t * @param  {Object} other The Python object to check for non-equality.\r\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if not equal, false otherwise\r\n\t */\r\n\tSk.builtin.object.prototype.ob$ne = function (other) {\r\n\t    if (this === other) {\r\n\t        return Sk.builtin.bool.false$;\r\n\t    }\r\n\r\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\r\n\t};\r\n\r\n\t/**\r\n\t * Determine if this instance is less than a Python object (i.e. this < other).\r\n\t *\r\n\t * Implements `__lt__` dunder method.\r\n\t *\r\n\t * Javascript function, returns Python object.\r\n\t *\r\n\t * @param  {Object} other The Python object to compare.\r\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this < other, false otherwise\r\n\t */\r\n\tSk.builtin.object.prototype.ob$lt = function (other) {\r\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\r\n\t};\r\n\r\n\t/**\r\n\t * Determine if this instance is less than or equal to a Python object (i.e. this <= other).\r\n\t *\r\n\t * Implements `__le__` dunder method.\r\n\t *\r\n\t * Javascript function, returns Python object.\r\n\t *\r\n\t * @param  {Object} other The Python object to compare.\r\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this <= other, false otherwise\r\n\t */\r\n\tSk.builtin.object.prototype.ob$le = function (other) {\r\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\r\n\t};\r\n\r\n\t/**\r\n\t * Determine if this instance is greater than a Python object (i.e. this > other).\r\n\t *\r\n\t * Implements `__gt__` dunder method.\r\n\t *\r\n\t * Javascript function, returns Python object.\r\n\t *\r\n\t * @param  {Object} other The Python object to compare.\r\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this > other, false otherwise\r\n\t */\r\n\tSk.builtin.object.prototype.ob$gt = function (other) {\r\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\r\n\t};\r\n\r\n\t/**\r\n\t * Determine if this instance is greater than or equal to a Python object (i.e. this >= other).\r\n\t *\r\n\t * Implements `__ge__` dunder method.\r\n\t *\r\n\t * Javascript function, returns Python object.\r\n\t *\r\n\t * @param  {Object} other The Python object to compare.\r\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this >= other, false otherwise\r\n\t */\r\n\tSk.builtin.object.prototype.ob$ge = function (other) {\r\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\r\n\t};\r\n\r\n\t// Wrap the following functions in Sk.builtin.func once that class is initialized\r\n\t/**\r\n\t * Array of all the Python functions which are methods of this class.\r\n\t * @type {Array}\r\n\t */\r\n\tSk.builtin.object.pythonFunctions = [\"__repr__\", \"__str__\", \"__hash__\",\r\n\t\"__eq__\", \"__ne__\", \"__lt__\", \"__le__\", \"__gt__\", \"__ge__\", \"__getattr__\", \"__setattr__\"];\r\n\r\n\t/**\r\n\t * @constructor\r\n\t * Sk.builtin.none\r\n\t *\r\n\t * @extends {Sk.builtin.object}\r\n\t */\r\n\tSk.builtin.none = function () {\r\n\t    this.v = null;\r\n\t};\r\n\tSk.abstr.setUpInheritance(\"NoneType\", Sk.builtin.none, Sk.builtin.object);\r\n\r\n\t/** @override */\r\n\tSk.builtin.none.prototype[\"$r\"] = function () { return new Sk.builtin.str(\"None\"); };\r\n\r\n\t/** @override */\r\n\tSk.builtin.none.prototype.tp$hash = function () {\r\n\t    return new Sk.builtin.int_(0);\r\n\t};\r\n\r\n\t/**\r\n\t * Python None constant.\r\n\t * @type {Sk.builtin.none}\r\n\t */\r\n\tSk.builtin.none.none$ = new Sk.builtin.none();\r\n\r\n\t/**\r\n\t * @constructor\r\n\t * Sk.builtin.NotImplemented\r\n\t *\r\n\t * @extends {Sk.builtin.object}\r\n\t */\r\n\tSk.builtin.NotImplemented = function() { };\r\n\tSk.abstr.setUpInheritance(\"NotImplementedType\", Sk.builtin.NotImplemented, Sk.builtin.object);\r\n\r\n\t/** @override */\r\n\tSk.builtin.NotImplemented.prototype[\"$r\"] = function () { return new Sk.builtin.str(\"NotImplemented\"); };\r\n\r\n\t/**\r\n\t * Python NotImplemented constant.\r\n\t * @type {Sk.builtin.NotImplemented}\r\n\t */\r\n\tSk.builtin.NotImplemented.NotImplemented$ = new Sk.builtin.NotImplemented();\r\n\r\n\tgoog.exportSymbol(\"Sk.builtin.none\", Sk.builtin.none);\r\n\tgoog.exportSymbol(\"Sk.builtin.NotImplemented\", Sk.builtin.NotImplemented);\r\n\r\n\r\n\r\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/function.js ---- */ \r\n\r\n\t/**\r\n\t * @namespace Sk.builtin\r\n\t */\r\n\r\n\r\n\t/**\r\n\t * Check arguments to Python functions to ensure the correct number of\r\n\t * arguments are passed.\r\n\t *\r\n\t * @param {string} name the name of the function\r\n\t * @param {Object} args the args passed to the function\r\n\t * @param {number} minargs the minimum number of allowable arguments\r\n\t * @param {number=} maxargs optional maximum number of allowable\r\n\t * arguments (default: Infinity)\r\n\t * @param {boolean=} kwargs optional true if kwargs, false otherwise\r\n\t * (default: false)\r\n\t * @param {boolean=} free optional true if free vars, false otherwise\r\n\t * (default: false)\r\n\t */\r\n\tSk.builtin.pyCheckArgs = function (name, args, minargs, maxargs, kwargs, free) {\r\n\t    var nargs = args.length;\r\n\t    var msg = \"\";\r\n\r\n\t    if (maxargs === undefined) {\r\n\t        maxargs = Infinity;\r\n\t    }\r\n\t    if (kwargs) {\r\n\t        nargs -= 1;\r\n\t    }\r\n\t    if (free) {\r\n\t        nargs -= 1;\r\n\t    }\r\n\t    if ((nargs < minargs) || (nargs > maxargs)) {\r\n\t        if (minargs === maxargs) {\r\n\t            msg = name + \"() takes exactly \" + minargs + \" arguments\";\r\n\t        } else if (nargs < minargs) {\r\n\t            msg = name + \"() takes at least \" + minargs + \" arguments\";\r\n\t        } else {\r\n\t            msg = name + \"() takes at most \" + maxargs + \" arguments\";\r\n\t        }\r\n\t        msg += \" (\" + nargs + \" given)\";\r\n\t        throw new Sk.builtin.TypeError(msg);\r\n\t    }\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.pyCheckArgs\", Sk.builtin.pyCheckArgs);\r\n\r\n\t/**\r\n\t * Check type of argument to Python functions.\r\n\t *\r\n\t * @param {string} name the name of the argument\r\n\t * @param {string} exptype string of the expected type name\r\n\t * @param {boolean} check truthy if type check passes, falsy otherwise\r\n\t */\r\n\tSk.builtin.pyCheckType = function (name, exptype, check) {\r\n\t    if (!check) {\r\n\t        throw new Sk.builtin.TypeError(name + \" must be a \" + exptype);\r\n\t    }\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.pyCheckType\", Sk.builtin.pyCheckType);\r\n\r\n\tSk.builtin.checkSequence = function (arg) {\r\n\t    return (arg !== null && arg.mp$subscript !== undefined);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.checkSequence\", Sk.builtin.checkSequence);\r\n\r\n\t/**\r\n\t * Use this to test whether or not a Python object is iterable.  You should **not** rely\r\n\t * on the presence of tp$iter on the object as a good test, as it could be a user defined\r\n\t * class with `__iter__` defined or ``__getitem__``  This tests for all of those cases\r\n\t *\r\n\t * @param arg {Object}   A Python object\r\n\t * @returns {boolean} true if the object is iterable\r\n\t */\r\n\tSk.builtin.checkIterable = function (arg) {\r\n\t    var ret = false;\r\n\t    if (arg !== null ) {\r\n\t        try {\r\n\t            ret = Sk.abstr.iter(arg);\r\n\t            if (ret) {\r\n\t                return true;\r\n\t            } else {\r\n\t                return false;\r\n\t            }\r\n\t        } catch (e) {\r\n\t            if (e instanceof Sk.builtin.TypeError) {\r\n\t                return false;\r\n\t            } else {\r\n\t                throw e;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    return ret;\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.checkIterable\", Sk.builtin.checkIterable);\r\n\r\n\tSk.builtin.checkCallable = function (obj) {\r\n\t    // takes care of builtin functions and methods, builtins\r\n\t    if (typeof obj === \"function\") {\r\n\t        return true;\r\n\t    }\r\n\t    // takes care of python function, methods and lambdas\r\n\t    if (obj instanceof Sk.builtin.func) {\r\n\t        return true;\r\n\t    }\r\n\t    // takes care of instances of methods\r\n\t    if (obj instanceof Sk.builtin.method) {\r\n\t        return true;\r\n\t    }\r\n\t    // go up the prototype chain to see if the class has a __call__ method\r\n\t    if (Sk.abstr.lookupSpecial(obj, \"__call__\") !== undefined) {\r\n\t        return true;\r\n\t    } \r\n\t    return false;\r\n\t};\r\n\r\n\tSk.builtin.checkNumber = function (arg) {\r\n\t    return (arg !== null && (typeof arg === \"number\" ||\r\n\t        arg instanceof Sk.builtin.int_ ||\r\n\t        arg instanceof Sk.builtin.float_ ||\r\n\t        arg instanceof Sk.builtin.lng));\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.checkNumber\", Sk.builtin.checkNumber);\r\n\r\n\t/**\r\n\t * Checks for complex type, delegates to internal method\r\n\t * Most skulpt users would search here!\r\n\t */\r\n\tSk.builtin.checkComplex = function (arg) {\r\n\t    return Sk.builtin.complex._complex_check(arg);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.checkComplex\", Sk.builtin.checkComplex);\r\n\r\n\tSk.builtin.checkInt = function (arg) {\r\n\t    return (arg !== null) && ((typeof arg === \"number\" && arg === (arg | 0)) ||\r\n\t        arg instanceof Sk.builtin.int_ ||\r\n\t        arg instanceof Sk.builtin.lng);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.checkInt\", Sk.builtin.checkInt);\r\n\r\n\tSk.builtin.checkFloat = function (arg) {\r\n\t    return (arg !== null) && (arg instanceof Sk.builtin.float_);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.checkFloat\", Sk.builtin.checkFloat);\r\n\r\n\tSk.builtin.checkString = function (arg) {\r\n\t    return (arg !== null && arg.__class__ == Sk.builtin.str);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.checkString\", Sk.builtin.checkString);\r\n\r\n\tSk.builtin.checkClass = function (arg) {\r\n\t    return (arg !== null && arg.sk$type);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.checkClass\", Sk.builtin.checkClass);\r\n\r\n\tSk.builtin.checkBool = function (arg) {\r\n\t    return (arg instanceof Sk.builtin.bool);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.checkBool\", Sk.builtin.checkBool);\r\n\r\n\tSk.builtin.checkNone = function (arg) {\r\n\t    return (arg instanceof Sk.builtin.none);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.checkNone\", Sk.builtin.checkNone);\r\n\r\n\tSk.builtin.checkFunction = function (arg) {\r\n\t    return (arg !== null && arg.tp$call !== undefined);\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.checkFunction\", Sk.builtin.checkFunction);\r\n\r\n\t/**\r\n\t * @constructor\r\n\t * Sk.builtin.func\r\n\t *\r\n\t * @description\r\n\t * This function converts a Javascript function into a Python object that is callable.  Or just\r\n\t * think of it as a Python function rather than a Javascript function now.  This is an important\r\n\t * distinction in skulpt because once you have Python function you cannot just call it.\r\n\t * You must now use Sk.misceval.callsim to call the Python function.\r\n\t *\r\n\t * @param {Function} code the javascript implementation of this function\r\n\t * @param {Object=} globals the globals where this function was defined.\r\n\t * Can be undefined (which will be stored as null) for builtins. (is\r\n\t * that ok?)\r\n\t * @param {Object=} closure dict of free variables\r\n\t * @param {Object=} closure2 another dict of free variables that will be\r\n\t * merged into 'closure'. there's 2 to simplify generated code (one is $free,\r\n\t * the other is $cell)\r\n\t *\r\n\t * closure is the cell variables from the parent scope that we need to close\r\n\t * over. closure2 is the free variables in the parent scope that we also might\r\n\t * need to access.\r\n\t *\r\n\t * NOTE: co_varnames and co_name are defined by compiled code only, so we have\r\n\t * to access them via dict-style lookup for closure.\r\n\t *\r\n\t */\r\n\tSk.builtin.func = function (code, globals, closure, closure2) {\r\n\t    var k;\r\n\t    this.func_code = code;\r\n\t    this.func_globals = globals || null;\r\n\t    if (closure2 !== undefined) {\r\n\t        // todo; confirm that modification here can't cause problems\r\n\t        for (k in closure2) {\r\n\t            closure[k] = closure2[k];\r\n\t        }\r\n\t    }\r\n\t    this.func_closure = closure;\r\n\t    return this;\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.func\", Sk.builtin.func);\r\n\r\n\r\n\tSk.builtin.func.prototype.tp$name = \"function\";\r\n\tSk.builtin.func.prototype.tp$descr_get = function (obj, objtype) {\r\n\t    goog.asserts.assert(obj !== undefined && objtype !== undefined);\r\n\t    if (obj == null) {\r\n\t        return this;\r\n\t    }\r\n\t    return new Sk.builtin.method(this, obj, objtype);\r\n\t};\r\n\tSk.builtin.func.prototype.tp$call = function (args, kw) {\r\n\t    var j;\r\n\t    var i;\r\n\t    var numvarnames;\r\n\t    var varnames;\r\n\t    var kwlen;\r\n\t    var kwargsarr;\r\n\t    var expectskw;\r\n\t    var name;\r\n\t    var numargs;\r\n\r\n\t    // note: functions expect 'this' to be globals to avoid having to\r\n\t    // slice/unshift onto the main args\r\n\t    if (this.func_closure) {\r\n\t        // todo; OK to modify?\r\n\t        if (this.func_code[\"$defaults\"] && this.func_code[\"co_varnames\"]) {\r\n\t            // Make sure all default arguments are in args before adding closure\r\n\t            numargs = args.length;\r\n\t            numvarnames = this.func_code[\"co_varnames\"].length;\r\n\t            for (i = numargs; i < numvarnames; i++) {\r\n\t                args.push(undefined);\r\n\t            }\r\n\t        }\r\n\t        args.push(this.func_closure);\r\n\t    }\r\n\r\n\t    expectskw = this.func_code[\"co_kwargs\"];\r\n\t    kwargsarr = [];\r\n\r\n\t    if (this.func_code[\"no_kw\"] && kw) {\r\n\t        name = (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || \"<native JS>\";\r\n\t        throw new Sk.builtin.TypeError(name + \"() takes no keyword arguments\");\r\n\t    }\r\n\r\n\t    if (kw) {\r\n\t        // bind the kw args\r\n\t        kwlen = kw.length;\r\n\t        varnames = this.func_code[\"co_varnames\"];\r\n\t        numvarnames = varnames && varnames.length;\r\n\t        for (i = 0; i < kwlen; i += 2) {\r\n\t            // todo; make this a dict mapping name to offset\r\n\t            for (j = 0; j < numvarnames; ++j) {\r\n\t                if (kw[i] === varnames[j]) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            if (varnames && j !== numvarnames) {\r\n\t                if (j in args) {\r\n\t                    name = (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || \"<native JS>\";\r\n\t                    throw new Sk.builtin.TypeError(name + \"() got multiple values for keyword argument '\" + kw[i] + \"'\");\r\n\t                }\r\n\t                args[j] = kw[i + 1];\r\n\t            } else if (expectskw) {\r\n\t                // build kwargs dict\r\n\t                kwargsarr.push(new Sk.builtin.str(kw[i]));\r\n\t                kwargsarr.push(kw[i + 1]);\r\n\t            } else {\r\n\t                name = (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || \"<native JS>\";\r\n\t                throw new Sk.builtin.TypeError(name + \"() got an unexpected keyword argument '\" + kw[i] + \"'\");\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    if (expectskw) {\r\n\t        args.unshift(kwargsarr);\r\n\t    }\r\n\r\n\t    //print(JSON.stringify(args, null, 2));\r\n\r\n\t    return this.func_code.apply(this.func_globals, args);\r\n\t};\r\n\r\n\tSk.builtin.func.prototype.tp$getattr = function (key) {\r\n\t    return this[key];\r\n\t};\r\n\tSk.builtin.func.prototype.tp$setattr = function (key, value) {\r\n\t    this[key] = value;\r\n\t};\r\n\r\n\t//todo; investigate why the other doesn't work\r\n\t//Sk.builtin.type.makeIntoTypeObj('function', Sk.builtin.func);\r\n\tSk.builtin.func.prototype.ob$type = Sk.builtin.type.makeTypeObj(\"function\", new Sk.builtin.func(null, null));\r\n\r\n\tSk.builtin.func.prototype[\"$r\"] = function () {\r\n\t    var name = (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || \"<native JS>\";\r\n\t    return new Sk.builtin.str(\"<function \" + name + \">\");\r\n\t};\r\n\r\n\r\n\r\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/seqtype.js ---- */ \r\n\r\n\t/**\r\n\t * @constructor\r\n\t * Sk.builtin.seqtype\r\n\t *\r\n\t * @description\r\n\t * Abstract class for Python sequence types.\r\n\t *\r\n\t * @extends {Sk.builtin.object}\r\n\t *\r\n\t * @return {undefined} Cannot instantiate a Sk.builtin.seqtype object\r\n\t */\r\n\tSk.builtin.seqtype = function () {\r\n\r\n\t    throw new Sk.builtin.ExternalError(\"Cannot instantiate abstract Sk.builtin.seqtype class\");\r\n\r\n\t};\r\n\r\n\tSk.abstr.setUpInheritance(\"SequenceType\", Sk.builtin.seqtype, Sk.builtin.object);\r\n\r\n\tSk.builtin.seqtype.sk$abstract = true;\r\n\r\n\t/**\r\n\t * Python wrapper of `__len__` method.\r\n\t *\r\n\t * @name  __len__\r\n\t * @instance\r\n\t * @memberOf Sk.builtin.seqtype.prototype\r\n\t */\r\n\tSk.builtin.seqtype.prototype[\"__len__\"] = new Sk.builtin.func(function (self) {\r\n\r\n\t    Sk.builtin.pyCheckArgs(\"__len__\", arguments, 0, 0, false, true);\r\n\r\n\t    return new Sk.builtin.int_(self.sq$length());    \r\n\r\n\t});\r\n\r\n\t/**\r\n\t * Python wrapper of `__iter__` method.\r\n\t *\r\n\t * @name  __iter__\r\n\t * @instance\r\n\t * @memberOf Sk.builtin.seqtype.prototype\r\n\t */\r\n\tSk.builtin.seqtype.prototype[\"__iter__\"] = new Sk.builtin.func(function (self) {\r\n\r\n\t    Sk.builtin.pyCheckArgs(\"__iter__\", arguments, 0, 0, false, true);\r\n\r\n\t    return self.tp$iter();\r\n\r\n\t});\r\n\r\n\t/**\r\n\t * Python wrapper of `__contains__` method.\r\n\t *\r\n\t * @name  __contains__\r\n\t * @instance\r\n\t * @memberOf Sk.builtin.seqtype.prototype\r\n\t */\r\n\tSk.builtin.seqtype.prototype[\"__contains__\"] = new Sk.builtin.func(function (self, item) {\r\n\r\n\t    Sk.builtin.pyCheckArgs(\"__contains__\", arguments, 1, 1, false, true);\r\n\r\n\t    if (self.sq$contains(item)) {\r\n\t        return Sk.builtin.bool.true$;\r\n\t    } else {\r\n\t        return Sk.builtin.bool.false$;\r\n\t    }\r\n\r\n\t});\r\n\r\n\t/**\r\n\t * Python wrapper of `__getitem__` method.\r\n\t *\r\n\t * @name  __getitem__\r\n\t * @instance\r\n\t * @memberOf Sk.builtin.seqtype.prototype\r\n\t */\r\n\tSk.builtin.seqtype.prototype[\"__getitem__\"] = new Sk.builtin.func(function (self, key) {\r\n\r\n\t    Sk.builtin.pyCheckArgs(\"__getitem__\", arguments, 1, 1, false, true);\r\n\r\n\t    return self.mp$subscript(key);\r\n\r\n\t});\r\n\r\n\t/**\r\n\t * Python wrapper of `__add__` method.\r\n\t *\r\n\t * @name  __add__\r\n\t * @instance\r\n\t * @memberOf Sk.builtin.seqtype.prototype\r\n\t */\r\n\tSk.builtin.seqtype.prototype[\"__add__\"] = new Sk.builtin.func(function (self, other) {\r\n\r\n\t    Sk.builtin.pyCheckArgs(\"__add__\", arguments, 1, 1, false, true);\r\n\r\n\t    return self.sq$concat(other);\r\n\r\n\t});\r\n\r\n\t/**\r\n\t * Python wrapper of `__mul__` method.\r\n\t *\r\n\t * @name  __mul__\r\n\t * @instance\r\n\t * @memberOf Sk.builtin.seqtype.prototype\r\n\t */\r\n\tSk.builtin.seqtype.prototype[\"__mul__\"] = new Sk.builtin.func(function (self, n) {\r\n\r\n\t    Sk.builtin.pyCheckArgs(\"__mul__\", arguments, 1, 1, false, true);\r\n\r\n\t    if (!Sk.misceval.isIndex(n)) {\r\n\t        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + Sk.abstr.typeName(n) + \"'\");\r\n\t    }\r\n\r\n\t    return self.sq$repeat(n);\r\n\r\n\t});\r\n\r\n\t/**\r\n\t * Python wrapper of `__rmul__` method.\r\n\t *\r\n\t * @name  __rmul__\r\n\t * @instance\r\n\t * @memberOf Sk.builtin.seqtype.prototype\r\n\t */\r\n\tSk.builtin.seqtype.prototype[\"__rmul__\"] = new Sk.builtin.func(function (self, n) {\r\n\r\n\t    Sk.builtin.pyCheckArgs(\"__rmul__\", arguments, 1, 1, false, true);\r\n\r\n\t    return self.sq$repeat(n);    \r\n\r\n\t});\r\n\r\n\r\n\r\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/str.js ---- */ \r\n\r\n\tSk.builtin.interned = {};\r\n\r\n\t/**\r\n\t * @constructor\r\n\t * @param {*} x\r\n\t * @extends Sk.builtin.object\r\n\t */\r\n\tSk.builtin.str = function (x) {\r\n\t    var ret;\r\n\t    if (x === undefined) {\r\n\t        x = \"\";\r\n\t    }\r\n\t    if (x instanceof Sk.builtin.str) {\r\n\t        return x;\r\n\t    }\r\n\t    if (!(this instanceof Sk.builtin.str)) {\r\n\t        return new Sk.builtin.str(x);\r\n\t    }\r\n\r\n\r\n\t    // convert to js string\r\n\t    if (x === true) {\r\n\t        ret = \"True\";\r\n\t    } else if (x === false) {\r\n\t        ret = \"False\";\r\n\t    } else if ((x === null) || (x instanceof Sk.builtin.none)) {\r\n\t        ret = \"None\";\r\n\t    } else if (x instanceof Sk.builtin.bool) {\r\n\t        if (x.v) {\r\n\t            ret = \"True\";\r\n\t        } else {\r\n\t            ret = \"False\";\r\n\t        }\r\n\t    } else if (typeof x === \"number\") {\r\n\t        ret = x.toString();\r\n\t        if (ret === \"Infinity\") {\r\n\t            ret = \"inf\";\r\n\t        } else if (ret === \"-Infinity\") {\r\n\t            ret = \"-inf\";\r\n\t        }\r\n\t    } else if (typeof x === \"string\") {\r\n\t        ret = x;\r\n\t    } else if (x.tp$str !== undefined) {\r\n\t        ret = x.tp$str();\r\n\t        if (!(ret instanceof Sk.builtin.str)) {\r\n\t            throw new Sk.builtin.ValueError(\"__str__ didn't return a str\");\r\n\t        }\r\n\t        return ret;\r\n\t    } else {\r\n\t        return Sk.misceval.objectRepr(x);\r\n\t    }\r\n\r\n\t    // interning required for strings in py\r\n\t    if (Sk.builtin.interned[\"1\" + ret]) {\r\n\t        return Sk.builtin.interned[\"1\" + ret];\r\n\t    }\r\n\r\n\t    this.__class__ = Sk.builtin.str;\r\n\t    this.v = ret;\r\n\t    this[\"v\"] = this.v;\r\n\t    Sk.builtin.interned[\"1\" + ret] = this;\r\n\t    return this;\r\n\r\n\t};\r\n\tgoog.exportSymbol(\"Sk.builtin.str\", Sk.builtin.str);\r\n\r\n\tSk.abstr.setUpInheritance(\"str\", Sk.builtin.str, Sk.builtin.seqtype);\r\n\r\n\tSk.builtin.str.prototype.mp$subscript = function (index) {\r\n\t    var ret;\r\n\t    if (Sk.misceval.isIndex(index)) {\r\n\t        index = Sk.misceval.asIndex(index);\r\n\t        if (index < 0) {\r\n\t            index = this.v.length + index;\r\n\t        }\r\n\t        if (index < 0 || index >= this.v.length) {\r\n\t            throw new Sk.builtin.IndexError(\"string index out of range\");\r\n\t        }\r\n\t        return new Sk.builtin.str(this.v.charAt(index));\r\n\t    } else if (index instanceof Sk.builtin.slice) {\r\n\t        ret = \"\";\r\n\t        index.sssiter$(this, function (i, wrt) {\r\n\t            if (i >= 0 && i < wrt.v.length) {\r\n\t                ret += wrt.v.charAt(i);\r\n\t            }\r\n\t        });\r\n\t        return new Sk.builtin.str(ret);\r\n\t    } else {\r\n\t        throw new Sk.builtin.TypeError(\"string indices must be integers, not \" + Sk.abstr.typeName(index));\r\n\t    }\r\n\t};\r\n\r\n\tSk.builtin.str.prototype.sq$length = function () {\r\n\t    return this.v.length;\r\n\t};\r\n\tSk.builtin.str.prototype.sq$concat = function (other) {\r\n\t    var otypename;\r\n\t    if (!other || !Sk.builtin.checkString(other)) {\r\n\t        otypename = Sk.abstr.typeName(other);\r\n\t        throw new Sk.builtin.TypeError(\"cannot concatenate 'str' and '\" + otypename + \"' objects\");\r\n\t    }\r\n\t    return new Sk.builtin.str(this.v + other.v);\r\n\t};\r\n\tSk.builtin.str.prototype.nb$add = Sk.builtin.str.prototype.sq$concat;\r\n\tSk.builtin.str.prototype.nb$inplace_add = Sk.builtin.str.prototype.sq$concat;\r\n\tSk.builtin.str.prototype.sq$repeat = function (n) {\r\n\t    var i;\r\n\t    var ret;\r\n\r\n\t    if (!Sk.misceval.isIndex(n)) {\r\n\t        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + Sk.abstr.typeName(n) + \"'\");\r\n\t    }\r\n\r\n\t    n = Sk.misceval.asIndex(n);\r\n\t    ret = \"\";\r\n\t    for (i = 0; i < n; ++i) {\r\n\t        ret += this.v;\r\n\t    }\r\n\t    return new Sk.builtin.str(ret);\r\n\t};\r\n\tSk.builtin.str.prototype.nb$multiply = Sk.builtin.str.prototype.sq$repeat;\r\n\tSk.builtin.str.prototype.nb$inplace_multiply = Sk.builtin.str.prototype.sq$repeat;\r\n\tSk.builtin.str.prototype.sq$item = function () {\r\n\t    goog.asserts.fail();\r\n\t};\r\n\tSk.builtin.str.prototype.sq$slice = function (i1, i2) {\r\n\t    i1 = Sk.builtin.asnum$(i1);\r\n\t    i2 = Sk.builtin.asnum$(i2);\r\n\t    if (i1 < 0) {\r\n\t        i1 = 0;\r\n\t    }\r\n\t    return new Sk.builtin.str(this.v.substr(i1, i2 - i1));\r\n\t};\r\n\r\n\tSk.builtin.str.prototype.sq$contains = function (ob) {\r\n\t    if (!(ob instanceof Sk.builtin.str)) {\r\n\t        throw new Sk.builtin.TypeError(\"TypeError: 'In <string> requires string as left operand\");\r\n\t    }\r\n\t    return this.v.indexOf(ob.v) != -1;\r\n\t};\r\n\r\n\tSk.builtin.str.prototype.__iter__ = new Sk.builtin.func(function (self) {\r\n\t    return new Sk.builtin.str_iter_(self);\r\n\t});\r\n\r\n\tSk.builtin.str.prototype.tp$iter = function () {\r\n\t    return new Sk.builtin.str_iter_(this);\r\n\t};\r\n\r\n\tSk.builtin.str.prototype.tp$richcompare = function (other, op) {\r\n\t    if (!(other instanceof Sk.builtin.str)) {\r\n\t        return undefined;\r\n\t    }\r\n\r\n\t    switch (op) {\r\n\t        case \"Lt\":\r\n\t            return this.v < other.v;\r\n\t        case \"LtE\":\r\n\t            return this.v <= other.v;\r\n\t        case \"Eq\":\r\n\t            return this.v === other.v;\r\n\t        case \"NotEq\":\r\n\t            return this.v !== other.v;\r\n\t        case \"Gt\":\r\n\t            return this.v > other.v;\r\n\t        case \"GtE\":\r\n\t            return this.v >= other.v;\r\n\t        default:\r\n\t            goog.asserts.fail();\r\n\t    }\r\n\t};\r\n\r\n\tSk.builtin.str.prototype[\"$r\"] = function () {\r\n\t    // single is preferred\r\n\t    var ashex;\r\n\t    var c;\r\n\t    var i;\r\n\t    var ret;\r\n\t    var len;\r\n\t    var quote = \"'\";\r\n\t    //jshint ignore:start\r\n\t    if (this.v.indexOf(\"'\") !== -1 && this.v.indexOf('\"') === -1) {\r\n\t        quote = '\"';\r\n\t    }\r\n\t    //jshint ignore:end\r\n\t    len = this.v.length;\r\n\t    ret = quote;\r\n\t    for (i = 0; i < len; ++i) {\r\n\t        c = this.v.charAt(i);\r\n\t        if (c === quote || c === \"\\\\\") {\r\n\t            ret += \"\\\\\" + c;\r\n\t        } else if (c === \"\\t\") {\r\n\t            ret += \"\\\\t\";\r\n\t        } else if (c === \"\\n\") {\r\n\t            ret += \"\\\\n\";\r\n\t        } else if (c === \"\\r\") {\r\n\t            ret += \"\\\\r\";\r\n\t        } else if (c < \" \" || c >= 0x7f) {\r\n\t            ashex = c.charCodeAt(0).toString(16);\r\n\t            if (ashex.length < 2) {\r\n\t                ashex = \"0\" + ashex;\r\n\t            }\r\n\t            ret += \"\\\\x\" + ashex;\r\n\t        } else {\r\n\t            ret += c;\r\n\t        }\r\n\t    }\r\n\t    ret += quote;\r\n\t    return new Sk.builtin.str(ret);\r\n\t};\r\n\r\n\r\n\tSk.builtin.str.re_escape_ = function (s) {\r\n\t    var c;\r\n\t    var i;\r\n\t    var ret = [];\r\n\t    var re = /^[A-Za-z0-9]+$/;\r\n\t    for (i = 0; i < s.length; ++i) {\r\n\t        c = s.charAt(i);\r\n\r\n\t        if (re.test(c)) {\r\n\t            ret.push(c);\r\n\t        } else {\r\n\t            if (c === \"\\\\000\") {\r\n\t                ret.push(\"\\\\000\");\r\n\t            } else {\r\n\t                ret.push(\"\\\\\" + c);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    return ret.join(\"\");\r\n\t};\r\n\r\n\tSk.builtin.str.prototype[\"lower\"] = new Sk.builtin.func(function (self) {\r\n\t    Sk.builtin.pyCheckArgs(\"lower\", arguments, 1, 1);\r\n\t    return new Sk.builtin.str(self.v.toLowerCase());\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"upper\"] = new Sk.builtin.func(function (self) {\r\n\t    Sk.builtin.pyCheckArgs(\"upper\", arguments, 1, 1);\r\n\t    return new Sk.builtin.str(self.v.toUpperCase());\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"capitalize\"] = new Sk.builtin.func(function (self) {\r\n\t    var i;\r\n\t    var cap;\r\n\t    var orig;\r\n\t    Sk.builtin.pyCheckArgs(\"capitalize\", arguments, 1, 1);\r\n\t    orig = self.v;\r\n\r\n\t    if (orig.length === 0) {\r\n\t        return new Sk.builtin.str(\"\");\r\n\t    }\r\n\t    cap = orig.charAt(0).toUpperCase();\r\n\r\n\t    for (i = 1; i < orig.length; i++) {\r\n\t        cap += orig.charAt(i).toLowerCase();\r\n\t    }\r\n\t    return new Sk.builtin.str(cap);\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"join\"] = new Sk.builtin.func(function (self, seq) {\r\n\t    var it, i;\r\n\t    var arrOfStrs;\r\n\t    Sk.builtin.pyCheckArgs(\"join\", arguments, 2, 2);\r\n\t    Sk.builtin.pyCheckType(\"seq\", \"iterable\", Sk.builtin.checkIterable(seq));\r\n\t    arrOfStrs = [];\r\n\t    for (it = seq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\r\n\t        if (i.constructor !== Sk.builtin.str) {\r\n\t            throw new Sk.builtin.TypeError(\"TypeError: sequence item \" + arrOfStrs.length + \": expected string, \" + typeof i + \" found\");\r\n\t        }\r\n\t        arrOfStrs.push(i.v);\r\n\t    }\r\n\t    return new Sk.builtin.str(arrOfStrs.join(self.v));\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"split\"] = new Sk.builtin.func(function (self, on, howmany) {\r\n\t    var splits;\r\n\t    var index;\r\n\t    var match;\r\n\t    var result;\r\n\t    var s;\r\n\t    var str;\r\n\t    var regex;\r\n\t    Sk.builtin.pyCheckArgs(\"split\", arguments, 1, 3);\r\n\t    if ((on === undefined) || (on instanceof Sk.builtin.none)) {\r\n\t        on = null;\r\n\t    }\r\n\t    if ((on !== null) && !Sk.builtin.checkString(on)) {\r\n\t        throw new Sk.builtin.TypeError(\"expected a string\");\r\n\t    }\r\n\t    if ((on !== null) && on.v === \"\") {\r\n\t        throw new Sk.builtin.ValueError(\"empty separator\");\r\n\t    }\r\n\t    if ((howmany !== undefined) && !Sk.builtin.checkInt(howmany)) {\r\n\t        throw new Sk.builtin.TypeError(\"an integer is required\");\r\n\t    }\r\n\r\n\t    howmany = Sk.builtin.asnum$(howmany);\r\n\t    regex = /[\\s]+/g;\r\n\t    str = self.v;\r\n\t    if (on === null) {\r\n\t        str = goog.string.trimLeft(str);\r\n\t    } else {\r\n\t        // Escape special characters in \"on\" so we can use a regexp\r\n\t        s = on.v.replace(/([.*+?=|\\\\\\/()\\[\\]\\{\\}^$])/g, \"\\\\$1\");\r\n\t        regex = new RegExp(s, \"g\");\r\n\t    }\r\n\r\n\t    // This is almost identical to re.split,\r\n\t    // except how the regexp is constructed\r\n\r\n\t    result = [];\r\n\t    index = 0;\r\n\t    splits = 0;\r\n\t    while ((match = regex.exec(str)) != null) {\r\n\t        if (match.index === regex.lastIndex) {\r\n\t            // empty match\r\n\t            break;\r\n\t        }\r\n\t        result.push(new Sk.builtin.str(str.substring(index, match.index)));\r\n\t        index = regex.lastIndex;\r\n\t        splits += 1;\r\n\t        if (howmany && (splits >= howmany)) {\r\n\t            break;\r\n\t        }\r\n\t    }\r\n\t    str = str.substring(index);\r\n\t    if (on !== null || (str.length > 0)) {\r\n\t        result.push(new Sk.builtin.str(str));\r\n\t    }\r\n\r\n\t    return new Sk.builtin.list(result);\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"strip\"] = new Sk.builtin.func(function (self, chars) {\r\n\t    var regex;\r\n\t    var pattern;\r\n\t    Sk.builtin.pyCheckArgs(\"strip\", arguments, 1, 2);\r\n\t    if ((chars !== undefined) && !Sk.builtin.checkString(chars)) {\r\n\t        throw new Sk.builtin.TypeError(\"strip arg must be None or str\");\r\n\t    }\r\n\t    if (chars === undefined) {\r\n\t        pattern = /^\\s+|\\s+$/g;\r\n\t    } else {\r\n\t        regex = Sk.builtin.str.re_escape_(chars.v);\r\n\t        pattern = new RegExp(\"^[\" + regex + \"]+|[\" + regex + \"]+$\", \"g\");\r\n\t    }\r\n\t    return new Sk.builtin.str(self.v.replace(pattern, \"\"));\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"lstrip\"] = new Sk.builtin.func(function (self, chars) {\r\n\t    var regex;\r\n\t    var pattern;\r\n\t    Sk.builtin.pyCheckArgs(\"lstrip\", arguments, 1, 2);\r\n\t    if ((chars !== undefined) && !Sk.builtin.checkString(chars)) {\r\n\t        throw new Sk.builtin.TypeError(\"lstrip arg must be None or str\");\r\n\t    }\r\n\t    if (chars === undefined) {\r\n\t        pattern = /^\\s+/g;\r\n\t    } else {\r\n\t        regex = Sk.builtin.str.re_escape_(chars.v);\r\n\t        pattern = new RegExp(\"^[\" + regex + \"]+\", \"g\");\r\n\t    }\r\n\t    return new Sk.builtin.str(self.v.replace(pattern, \"\"));\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"rstrip\"] = new Sk.builtin.func(function (self, chars) {\r\n\t    var regex;\r\n\t    var pattern;\r\n\t    Sk.builtin.pyCheckArgs(\"rstrip\", arguments, 1, 2);\r\n\t    if ((chars !== undefined) && !Sk.builtin.checkString(chars)) {\r\n\t        throw new Sk.builtin.TypeError(\"rstrip arg must be None or str\");\r\n\t    }\r\n\t    if (chars === undefined) {\r\n\t        pattern = /\\s+$/g;\r\n\t    } else {\r\n\t        regex = Sk.builtin.str.re_escape_(chars.v);\r\n\t        pattern = new RegExp(\"[\" + regex + \"]+$\", \"g\");\r\n\t    }\r\n\t    return new Sk.builtin.str(self.v.replace(pattern, \"\"));\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"partition\"] = new Sk.builtin.func(function (self, sep) {\r\n\t    var pos;\r\n\t    var sepStr;\r\n\t    Sk.builtin.pyCheckArgs(\"partition\", arguments, 2, 2);\r\n\t    Sk.builtin.pyCheckType(\"sep\", \"string\", Sk.builtin.checkString(sep));\r\n\t    sepStr = new Sk.builtin.str(sep);\r\n\t    pos = self.v.indexOf(sepStr.v);\r\n\t    if (pos < 0) {\r\n\t        return new Sk.builtin.tuple([self, Sk.builtin.str.$emptystr, Sk.builtin.str.$emptystr]);\r\n\t    }\r\n\r\n\t    return new Sk.builtin.tuple([\r\n\t        new Sk.builtin.str(self.v.substring(0, pos)),\r\n\t        sepStr,\r\n\t        new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))]);\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"rpartition\"] = new Sk.builtin.func(function (self, sep) {\r\n\t    var pos;\r\n\t    var sepStr;\r\n\t    Sk.builtin.pyCheckArgs(\"rpartition\", arguments, 2, 2);\r\n\t    Sk.builtin.pyCheckType(\"sep\", \"string\", Sk.builtin.checkString(sep));\r\n\t    sepStr = new Sk.builtin.str(sep);\r\n\t    pos = self.v.lastIndexOf(sepStr.v);\r\n\t    if (pos < 0) {\r\n\t        return new Sk.builtin.tuple([Sk.builtin.str.$emptystr, Sk.builtin.str.$emptystr, self]);\r\n\t    }\r\n\r\n\t    return new Sk.builtin.tuple([\r\n\t        new Sk.builtin.str(self.v.substring(0, pos)),\r\n\t        sepStr,\r\n\t        new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))]);\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"count\"] = new Sk.builtin.func(function (self, pat, start, end) {\r\n\t    var normaltext;\r\n\t    var ctl;\r\n\t    var slice;\r\n\t    var m;\r\n\t    Sk.builtin.pyCheckArgs(\"count\", arguments, 2, 4);\r\n\t    if (!Sk.builtin.checkString(pat)) {\r\n\t        throw new Sk.builtin.TypeError(\"expected a character buffer object\");\r\n\t    }\r\n\t    if ((start !== undefined) && !Sk.builtin.checkInt(start)) {\r\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\r\n\t    }\r\n\t    if ((end !== undefined) && !Sk.builtin.checkInt(end)) {\r\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\r\n\t    }\r\n\r\n\t    if (start === undefined) {\r\n\t        start = 0;\r\n\t    } else {\r\n\t        start = Sk.builtin.asnum$(start);\r\n\t        start = start >= 0 ? start : self.v.length + start;\r\n\t    }\r\n\r\n\t    if (end === undefined) {\r\n\t        end = self.v.length;\r\n\t    } else {\r\n\t        end = Sk.builtin.asnum$(end);\r\n\t        end = end >= 0 ? end : self.v.length + end;\r\n\t    }\r\n\r\n\t    normaltext = pat.v.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\r\n\t    m = new RegExp(normaltext, \"g\");\r\n\t    slice = self.v.slice(start, end);\r\n\t    ctl = slice.match(m);\r\n\t    if (!ctl) {\r\n\t        return  new Sk.builtin.int_(0);\r\n\t    } else {\r\n\t        return new Sk.builtin.int_(ctl.length);\r\n\t    }\r\n\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"ljust\"] = new Sk.builtin.func(function (self, len, fillchar) {\r\n\t    var newstr;\r\n\t    Sk.builtin.pyCheckArgs(\"ljust\", arguments, 2, 3);\r\n\t    if (!Sk.builtin.checkInt(len)) {\r\n\t        throw new Sk.builtin.TypeError(\"integer argument exepcted, got \" + Sk.abstr.typeName(len));\r\n\t    }\r\n\t    if ((fillchar !== undefined) && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {\r\n\t        throw new Sk.builtin.TypeError(\"must be char, not \" + Sk.abstr.typeName(fillchar));\r\n\t    }\r\n\t    if (fillchar === undefined) {\r\n\t        fillchar = \" \";\r\n\t    } else {\r\n\t        fillchar = fillchar.v;\r\n\t    }\r\n\t    len = Sk.builtin.asnum$(len);\r\n\t    if (self.v.length >= len) {\r\n\t        return self;\r\n\t    } else {\r\n\t        newstr = Array.prototype.join.call({length: Math.floor(len - self.v.length) + 1}, fillchar);\r\n\t        return new Sk.builtin.str(self.v + newstr);\r\n\t    }\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"rjust\"] = new Sk.builtin.func(function (self, len, fillchar) {\r\n\t    var newstr;\r\n\t    Sk.builtin.pyCheckArgs(\"rjust\", arguments, 2, 3);\r\n\t    if (!Sk.builtin.checkInt(len)) {\r\n\t        throw new Sk.builtin.TypeError(\"integer argument exepcted, got \" + Sk.abstr.typeName(len));\r\n\t    }\r\n\t    if ((fillchar !== undefined) && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {\r\n\t        throw new Sk.builtin.TypeError(\"must be char, not \" + Sk.abstr.typeName(fillchar));\r\n\t    }\r\n\t    if (fillchar === undefined) {\r\n\t        fillchar = \" \";\r\n\t    } else {\r\n\t        fillchar = fillchar.v;\r\n\t    }\r\n\t    len = Sk.builtin.asnum$(len);\r\n\t    if (self.v.length >= len) {\r\n\t        return self;\r\n\t    } else {\r\n\t        newstr = Array.prototype.join.call({length: Math.floor(len - self.v.length) + 1}, fillchar);\r\n\t        return new Sk.builtin.str(newstr + self.v);\r\n\t    }\r\n\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"center\"] = new Sk.builtin.func(function (self, len, fillchar) {\r\n\t    var newstr;\r\n\t    var newstr1;\r\n\t    Sk.builtin.pyCheckArgs(\"center\", arguments, 2, 3);\r\n\t    if (!Sk.builtin.checkInt(len)) {\r\n\t        throw new Sk.builtin.TypeError(\"integer argument exepcted, got \" + Sk.abstr.typeName(len));\r\n\t    }\r\n\t    if ((fillchar !== undefined) && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {\r\n\t        throw new Sk.builtin.TypeError(\"must be char, not \" + Sk.abstr.typeName(fillchar));\r\n\t    }\r\n\t    if (fillchar === undefined) {\r\n\t        fillchar = \" \";\r\n\t    } else {\r\n\t        fillchar = fillchar.v;\r\n\t    }\r\n\t    len = Sk.builtin.asnum$(len);\r\n\t    if (self.v.length >= len) {\r\n\t        return self;\r\n\t    } else {\r\n\t        newstr1 = Array.prototype.join.call({length: Math.floor((len - self.v.length) / 2) + 1}, fillchar);\r\n\t        newstr = newstr1 + self.v + newstr1;\r\n\t        if (newstr.length < len) {\r\n\t            newstr = newstr + fillchar;\r\n\t        }\r\n\t        return new Sk.builtin.str(newstr);\r\n\t    }\r\n\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"find\"] = new Sk.builtin.func(function (self, tgt, start, end) {\r\n\t    var idx;\r\n\t    Sk.builtin.pyCheckArgs(\"find\", arguments, 2, 4);\r\n\t    if (!Sk.builtin.checkString(tgt)) {\r\n\t        throw new Sk.builtin.TypeError(\"expected a character buffer object\");\r\n\t    }\r\n\t    if ((start !== undefined) && !Sk.builtin.checkInt(start)) {\r\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\r\n\t    }\r\n\t    if ((end !== undefined) && !Sk.builtin.checkInt(end)) {\r\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\r\n\t    }\r\n\r\n\t    if (start === undefined) {\r\n\t        start = 0;\r\n\t    } else {\r\n\t        start = Sk.builtin.asnum$(start);\r\n\t        start = start >= 0 ? start : self.v.length + start;\r\n\t    }\r\n\r\n\t    if (end === undefined) {\r\n\t        end = self.v.length;\r\n\t    } else {\r\n\t        end = Sk.builtin.asnum$(end);\r\n\t        end = end >= 0 ? end : self.v.length + end;\r\n\t    }\r\n\r\n\t    idx = self.v.indexOf(tgt.v, start);\r\n\t    idx = ((idx >= start) && (idx < end)) ? idx : -1;\r\n\r\n\t    return new Sk.builtin.int_(idx);\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"index\"] = new Sk.builtin.func(function (self, tgt, start, end) {\r\n\t    var idx;\r\n\t    Sk.builtin.pyCheckArgs(\"index\", arguments, 2, 4);\r\n\t    idx = Sk.misceval.callsim(self[\"find\"], self, tgt, start, end);\r\n\t    if (Sk.builtin.asnum$(idx) === -1) {\r\n\t        throw new Sk.builtin.ValueError(\"substring not found\");\r\n\t    }\r\n\t    return idx;\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"rfind\"] = new Sk.builtin.func(function (self, tgt, start, end) {\r\n\t    var idx;\r\n\t    Sk.builtin.pyCheckArgs(\"rfind\", arguments, 2, 4);\r\n\t    if (!Sk.builtin.checkString(tgt)) {\r\n\t        throw new Sk.builtin.TypeError(\"expected a character buffer object\");\r\n\t    }\r\n\t    if ((start !== undefined) && !Sk.builtin.checkInt(start)) {\r\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\r\n\t    }\r\n\t    if ((end !== undefined) && !Sk.builtin.checkInt(end)) {\r\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\r\n\t    }\r\n\r\n\t    if (start === undefined) {\r\n\t        start = 0;\r\n\t    } else {\r\n\t        start = Sk.builtin.asnum$(start);\r\n\t        start = start >= 0 ? start : self.v.length + start;\r\n\t    }\r\n\r\n\t    if (end === undefined) {\r\n\t        end = self.v.length;\r\n\t    } else {\r\n\t        end = Sk.builtin.asnum$(end);\r\n\t        end = end >= 0 ? end : self.v.length + end;\r\n\t    }\r\n\r\n\t    idx = self.v.lastIndexOf(tgt.v, end);\r\n\t    idx = (idx !== end) ? idx : self.v.lastIndexOf(tgt.v, end - 1);\r\n\t    idx = ((idx >= start) && (idx < end)) ? idx : -1;\r\n\r\n\t    return new Sk.builtin.int_(idx);\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"rindex\"] = new Sk.builtin.func(function (self, tgt, start, end) {\r\n\t    var idx;\r\n\t    Sk.builtin.pyCheckArgs(\"rindex\", arguments, 2, 4);\r\n\t    idx = Sk.misceval.callsim(self[\"rfind\"], self, tgt, start, end);\r\n\t    if (Sk.builtin.asnum$(idx) === -1) {\r\n\t        throw new Sk.builtin.ValueError(\"substring not found\");\r\n\t    }\r\n\t    return idx;\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"startswith\"] = new Sk.builtin.func(function (self, tgt) {\r\n\t    Sk.builtin.pyCheckArgs(\"startswith\", arguments, 2, 2);\r\n\t    Sk.builtin.pyCheckType(\"tgt\", \"string\", Sk.builtin.checkString(tgt));\r\n\t    return new Sk.builtin.bool( self.v.indexOf(tgt.v) === 0);\r\n\t});\r\n\r\n\t// http://stackoverflow.com/questions/280634/endswith-in-javascript\r\n\tSk.builtin.str.prototype[\"endswith\"] = new Sk.builtin.func(function (self, tgt) {\r\n\t    Sk.builtin.pyCheckArgs(\"endswith\", arguments, 2, 2);\r\n\t    Sk.builtin.pyCheckType(\"tgt\", \"string\", Sk.builtin.checkString(tgt));\r\n\t    return new Sk.builtin.bool( self.v.indexOf(tgt.v, self.v.length - tgt.v.length) !== -1);\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"replace\"] = new Sk.builtin.func(function (self, oldS, newS, count) {\r\n\t    var c;\r\n\t    var patt;\r\n\t    Sk.builtin.pyCheckArgs(\"replace\", arguments, 3, 4);\r\n\t    Sk.builtin.pyCheckType(\"oldS\", \"string\", Sk.builtin.checkString(oldS));\r\n\t    Sk.builtin.pyCheckType(\"newS\", \"string\", Sk.builtin.checkString(newS));\r\n\t    if ((count !== undefined) && !Sk.builtin.checkInt(count)) {\r\n\t        throw new Sk.builtin.TypeError(\"integer argument expected, got \" +\r\n\t            Sk.abstr.typeName(count));\r\n\t    }\r\n\t    count = Sk.builtin.asnum$(count);\r\n\t    patt = new RegExp(Sk.builtin.str.re_escape_(oldS.v), \"g\");\r\n\r\n\t    if ((count === undefined) || (count < 0)) {\r\n\t        return new Sk.builtin.str(self.v.replace(patt, newS.v));\r\n\t    }\r\n\r\n\t    c = 0;\r\n\r\n\t    function replacer (match) {\r\n\t        c++;\r\n\t        if (c <= count) {\r\n\t            return newS.v;\r\n\t        }\r\n\t        return match;\r\n\t    }\r\n\r\n\t    return new Sk.builtin.str(self.v.replace(patt, replacer));\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"zfill\"] = new Sk.builtin.func(function (self, len) {\r\n\t    var str = self.v;\r\n\t    var ret;\r\n\t    var zeroes;\r\n\t    var offset;\r\n\t    var pad = \"\";\r\n\r\n\t    Sk.builtin.pyCheckArgs(\"zfill\", arguments, 2, 2);\r\n\t    if (! Sk.builtin.checkInt(len)) {\r\n\t        throw new Sk.builtin.TypeError(\"integer argument exepected, got \" + Sk.abstr.typeName(len));\r\n\t    }\r\n\r\n\t    // figure out how many zeroes are needed to make the proper length\r\n\t    zeroes = len.v - str.length;\r\n\t    // offset by 1 if there is a +/- at the beginning of the string\r\n\t    offset = (str[0] === \"+\" || str[0] === \"-\") ? 1 : 0;\r\n\t    for(var i = 0; i < zeroes; i++){\r\n\t        pad += \"0\";\r\n\t    }\r\n\t    // combine the string and the zeroes\r\n\t    ret = str.substr(0, offset) + pad + str.substr(offset);\r\n\t    return new Sk.builtin.str(ret);\r\n\r\n\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"isdigit\"] = new Sk.builtin.func(function (self) {\r\n\t    Sk.builtin.pyCheckArgs(\"isdigit\", arguments, 1, 1);\r\n\t    return new Sk.builtin.bool( /^\\d+$/.test(self.v));\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"isspace\"] = new Sk.builtin.func(function (self) {\r\n\t    Sk.builtin.pyCheckArgs(\"isspace\", arguments, 1, 1);\r\n\t    return new Sk.builtin.bool( /^\\s+$/.test(self.v));\r\n\t});\r\n\r\n\r\n\tSk.builtin.str.prototype[\"expandtabs\"] = new Sk.builtin.func(function (self, tabsize) {\r\n\t    // var input = self.v;\r\n\t    // var expanded = \"\";\r\n\t    // var split;\r\n\t    // var spacestr = \"\";\r\n\t    // var spacerem;\r\n\r\n\r\n\t    var spaces;\r\n\t    var expanded;\r\n\r\n\t    Sk.builtin.pyCheckArgs(\"expandtabs\", arguments, 1, 2);\r\n\r\n\r\n\t    if ((tabsize !== undefined) && ! Sk.builtin.checkInt(tabsize)) {\r\n\t        throw new Sk.builtin.TypeError(\"integer argument exepected, got \" + Sk.abstr.typeName(tabsize));\r\n\t    }\r\n\t    if (tabsize === undefined) {\r\n\t        tabsize = 8;\r\n\t    } else {\r\n\t        tabsize = Sk.builtin.asnum$(tabsize);\r\n\t    }\r\n\r\n\t    spaces = (new Array(tabsize + 1)).join(\" \");\r\n\t    expanded = self.v.replace(/([^\\r\\n\\t]*)\\t/g, function(a, b) {\r\n\t        return b + spaces.slice(b.length % tabsize);\r\n\t    });\r\n\t    return new Sk.builtin.str(expanded);\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"swapcase\"] = new Sk.builtin.func(function (self) {\r\n\t    var ret;\r\n\t    Sk.builtin.pyCheckArgs(\"swapcase\", arguments, 1, 1);\r\n\r\n\r\n\t    ret = self.v.replace(/[a-z]/gi, function(c) {\r\n\t        var lc = c.toLowerCase();\r\n\t        return lc === c ? c.toUpperCase() : lc;\r\n\t    });\r\n\r\n\t    return new Sk.builtin.str(ret);\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"splitlines\"] = new Sk.builtin.func(function (self, keepends) {\r\n\t    var data = self.v;\r\n\t    var i = 0;\r\n\t    var j = i;\r\n\t    var selflen = self.v.length;\r\n\t    var strs_w = [];\r\n\t    var ch;\r\n\t    var eol;\r\n\t    var sol = 0;\r\n\t    var slice;\r\n\t    Sk.builtin.pyCheckArgs(\"splitlines\", arguments, 1, 2);\r\n\t    if ((keepends !== undefined) && ! Sk.builtin.checkBool(keepends)) {\r\n\t        throw new Sk.builtin.TypeError(\"boolean argument expected, got \" + Sk.abstr.typeName(keepends));\r\n\t    }\r\n\t    if (keepends === undefined) {\r\n\t        keepends = false;\r\n\t    } else {\r\n\t        keepends = keepends.v;\r\n\t    }\r\n\r\n\r\n\t    for (i = 0; i < selflen; i ++) {\r\n\t        ch = data.charAt(i);\r\n\t        if (data.charAt(i + 1) === \"\\n\" && ch === \"\\r\") {\r\n\t            eol = i + 2;\r\n\t            slice = data.slice(sol, eol);\r\n\t            if (! keepends) {\r\n\t                slice = slice.replace(/(\\r|\\n)/g, \"\");\r\n\t            }\r\n\t            strs_w.push(new Sk.builtin.str(slice));\r\n\t            sol = eol;\r\n\t        } else if ((ch === \"\\n\" && data.charAt(i - 1) !== \"\\r\") || ch === \"\\r\") {\r\n\t            eol = i + 1;\r\n\t            slice = data.slice(sol, eol);\r\n\t            if (! keepends) {\r\n\t                slice = slice.replace(/(\\r|\\n)/g, \"\");\r\n\t            }\r\n\t            strs_w.push(new Sk.builtin.str(slice));\r\n\t            sol = eol;\r\n\t        }\r\n\r\n\t    }\r\n\t    if (sol < selflen) {\r\n\t        eol = selflen;\r\n\t        slice = data.slice(sol, eol);\r\n\t        if (! keepends) {\r\n\t            slice = slice.replace(/(\\r|\\n)/g, \"\");\r\n\t        }\r\n\t        strs_w.push(new Sk.builtin.str(slice));\r\n\t    }\r\n\t    return new Sk.builtin.list(strs_w);\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"title\"] = new Sk.builtin.func(function (self) {\r\n\t    var ret;\r\n\r\n\t    Sk.builtin.pyCheckArgs(\"title\", arguments, 1, 1);\r\n\r\n\t    ret = self.v.replace(/[a-z][a-z]*/gi, function(str) {\r\n\t        return str[0].toUpperCase() + str.substr(1).toLowerCase();\r\n\t    });\r\n\r\n\t    return new Sk.builtin.str(ret);\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"isalpha\"] = new Sk.builtin.func(function (self) {\r\n\t    Sk.builtin.pyCheckArgs(\"isalpha\", arguments, 1, 1);\r\n\t    return new Sk.builtin.bool( self.v.length && goog.string.isAlpha(self.v));\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"isalnum\"] = new Sk.builtin.func(function (self) {\r\n\t    Sk.builtin.pyCheckArgs(\"isalnum\", arguments, 1, 1);\r\n\t    return new Sk.builtin.bool( self.v.length && goog.string.isAlphaNumeric(self.v));\r\n\t});\r\n\r\n\t// does not account for unicode numeric values\r\n\tSk.builtin.str.prototype[\"isnumeric\"] = new Sk.builtin.func(function (self) {\r\n\t    Sk.builtin.pyCheckArgs(\"isnumeric\", arguments, 1, 1);\r\n\t    return new Sk.builtin.bool( self.v.length && goog.string.isNumeric(self.v));\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"islower\"] = new Sk.builtin.func(function (self) {\r\n\t    Sk.builtin.pyCheckArgs(\"islower\", arguments, 1, 1);\r\n\t    return new Sk.builtin.bool( self.v.length && /[a-z]/.test(self.v) && !/[A-Z]/.test(self.v));\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"isupper\"] = new Sk.builtin.func(function (self) {\r\n\t    Sk.builtin.pyCheckArgs(\"isupper\", arguments, 1, 1);\r\n\t    return new Sk.builtin.bool( self.v.length && !/[a-z]/.test(self.v) && /[A-Z]/.test(self.v));\r\n\t});\r\n\r\n\tSk.builtin.str.prototype[\"istitle\"] = new Sk.builtin.func(function (self) {\r\n\t    // Comparing to str.title() seems the most intuitive thing, but it fails on \"\",\r\n\t    // Other empty-ish strings with no change.\r\n\t    var input = self.v;\r\n\t    var cased = false;\r\n\t    var previous_is_cased = false;\r\n\t    var pos;\r\n\t    var ch;\r\n\t    Sk.builtin.pyCheckArgs(\"istitle\", arguments, 1, 1);\r\n\t    for (pos = 0; pos < input.length; pos ++) {\r\n\t        ch = input.charAt(pos);\r\n\t        if (! /[a-z]/.test(ch) && /[A-Z]/.test(ch)) {\r\n\t            if (previous_is_cased) {\r\n\t                return new Sk.builtin.bool( false);\r\n\t            }\r\n\t            previous_is_cased = true;\r\n\t            cased = true;\r\n\t        } else if (/[a-z]/.test(ch) && ! /[A-Z]/.test(ch)) {\r\n\t            if (! previous_is_cased) {\r\n\t                return new Sk.builtin.bool( false);\r\n\t            }\r\n\t            cased = true;\r\n\t        } else {\r\n\t            previous_is_cased = false;\r\n\t        }\r\n\t    }\r\n\t    return new Sk.builtin.bool( cased);\r\n\t});\r\n\r\n\tSk.builtin.str.prototype.nb$remainder = function (rhs) {\r\n\t    // % format op. rhs can be a value, a tuple, or something with __getitem__ (dict)\r\n\r\n\t    // From http://docs.python.org/library/stdtypes.html#string-formatting the\r\n\t    // format looks like:\r\n\t    // 1. The '%' character, which marks the start of the specifier.\r\n\t    // 2. Mapping key (optional), consisting of a parenthesised sequence of characters (for example, (somename)).\r\n\t    // 3. Conversion flags (optional), which affect the result of some conversion types.\r\n\t    // 4. Minimum field width (optional). If specified as an '*' (asterisk), the actual width is read from the next\r\n\t    // element of the tuple in values, and the object to convert comes after the minimum field width and optional\r\n\t    // precision. 5. Precision (optional), given as a '.' (dot) followed by the precision. If specified as '*' (an\r\n\t    // asterisk), the actual width is read from the next element of the tuple in values, and the value to convert comes\r\n\t    // after the precision. 6. Length modifier (optional). 7. Conversion type.  length modifier is ignored\r\n\r\n\t    var ret;\r\n\t    var replFunc;\r\n\t    var index;\r\n\t    var regex;\r\n\t    if (rhs.constructor !== Sk.builtin.tuple && (rhs.mp$subscript === undefined || rhs.constructor === Sk.builtin.str)) {\r\n\t        rhs = new Sk.builtin.tuple([rhs]);\r\n\t    }\r\n\r\n\t    // general approach is to use a regex that matches the format above, and\r\n\t    // do an re.sub with a function as replacement to make the subs.\r\n\r\n\t    //           1 2222222222222222   33333333   444444444   5555555555555  66666  777777777777777777\r\n\t    regex = /%(\\([a-zA-Z0-9]+\\))?([#0 +\\-]+)?(\\*|[0-9]+)?(\\.(\\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrs%])/g;\r\n\t    index = 0;\r\n\t    replFunc = function (substring, mappingKey, conversionFlags, fieldWidth, precision, precbody, conversionType) {\r\n\t        var result;\r\n\t        var convName;\r\n\t        var convValue;\r\n\t        var base;\r\n\t        var r;\r\n\t        var mk;\r\n\t        var value;\r\n\t        var handleWidth;\r\n\t        var formatNumber;\r\n\t        var alternateForm;\r\n\t        var precedeWithSign;\r\n\t        var blankBeforePositive;\r\n\t        var leftAdjust;\r\n\t        var zeroPad;\r\n\t        var i;\r\n\t        fieldWidth = Sk.builtin.asnum$(fieldWidth);\r\n\t        precision = Sk.builtin.asnum$(precision);\r\n\r\n\t        if (mappingKey === undefined || mappingKey === \"\") {\r\n\t            i = index++;\r\n\t        } // ff passes '' not undef for some reason\r\n\r\n\t        if (precision === \"\") { // ff passes '' here aswell causing problems with G,g, etc.\r\n\t            precision = undefined;\r\n\t        }\r\n\r\n\t        zeroPad = false;\r\n\t        leftAdjust = false;\r\n\t        blankBeforePositive = false;\r\n\t        precedeWithSign = false;\r\n\t        alternateForm = false;\r\n\t        if (conversionFlags) {\r\n\t            if (conversionFlags.indexOf(\"-\") !== -1) {\r\n\t                leftAdjust = true;\r\n\t            } else if (conversionFlags.indexOf(\"0\") !== -1) {\r\n\t                zeroPad = true;\r\n\t            }\r\n\r\n\t            if (conversionFlags.indexOf(\"+\") !== -1) {\r\n\t                precedeWithSign = true;\r\n\t            } else if (conversionFlags.indexOf(\" \") !== -1) {\r\n\t                blankBeforePositive = true;\r\n\t            }\r\n\r\n\t            alternateForm = conversionFlags.indexOf(\"#\") !== -1;\r\n\t        }\r\n\r\n\t        if (precision) {\r\n\t            precision = parseInt(precision.substr(1), 10);\r\n\t        }\r\n\r\n\t        formatNumber = function (n, base) {\r\n\t            var precZeroPadded;\r\n\t            var prefix;\r\n\t            var didSign;\r\n\t            var neg;\r\n\t            var r;\r\n\t            var j;\r\n\t            base = Sk.builtin.asnum$(base);\r\n\t            neg = false;\r\n\t            didSign = false;\r\n\t            if (typeof n === \"number\") {\r\n\t                if (n < 0) {\r\n\t                    n = -n;\r\n\t                    neg = true;\r\n\t                }\r\n\t                r = n.toString(base);\r\n\t            } else if (n instanceof Sk.builtin.float_) {\r\n\t                r = n.str$(base, false);\r\n\t                if (r.length > 2 && r.substr(-2) === \".0\") {\r\n\t                    r = r.substr(0, r.length - 2);\r\n\t                }\r\n\t                neg = n.nb$isnegative();\r\n\t            } else if (n instanceof Sk.builtin.int_) {\r\n\t                r = n.str$(base, false);\r\n\t                neg = n.nb$isnegative();\r\n\t            } else if (n instanceof Sk.builtin.lng) {\r\n\t                r = n.str$(base, false);\r\n\t                neg = n.nb$isnegative();\t//\tneg = n.size$ < 0;\tRNL long.js change\r\n\t            }\r\n\r\n\t            goog.asserts.assert(r !== undefined, \"unhandled number format\");\r\n\r\n\t            precZeroPadded = false;\r\n\r\n\t            if (precision) {\r\n\t                //print(\"r.length\",r.length,\"precision\",precision);\r\n\t                for (j = r.length; j < precision; ++j) {\r\n\t                    r = \"0\" + r;\r\n\t                    precZeroPadded = true;\r\n\t                }\r\n\t            }\r\n\r\n\t            prefix = \"\";\r\n\r\n\t            if (neg) {\r\n\t                prefix = \"-\";\r\n\t            } else if (precedeWithSign) {\r\n\t                prefix = \"+\" + prefix;\r\n\t            } else if (blankBeforePositive) {\r\n\t                prefix = \" \" + prefix;\r\n\t            }\r\n\r\n\t            if (alternateForm) {\r\n\t                if (base === 16) {\r\n\t                    prefix += \"0x\";\r\n\t                } else if (base === 8 && !precZeroPadded && r !== \"0\") {\r\n\t                    prefix += \"0\";\r\n\t                }\r\n\t            }\r\n\r\n\t            return [prefix, r];\r\n\t        };\r\n\r\n\t        handleWidth = function (args) {\r\n\t            var totLen;\r\n\t            var prefix = args[0];\r\n\t            var r = args[1];\r\n\t            var j;\r\n\t            if (fieldWidth) {\r\n\t                fieldWidth = parseInt(fieldWidth, 10);\r\n\t                totLen = r.length + prefix.length;\r\n\t                if (zeroPad) {\r\n\t                    for (j = totLen; j < fieldWidth; ++j) {\r\n\t                        r = \"0\" + r;\r\n\t                    }\r\n\t                } else if (leftAdjust) {\r\n\t                    for (j = totLen; j < fieldWidth; ++j) {\r\n\t                        r = r + \" \";\r\n\t                    }\r\n\t                } else {\r\n\t                    for (j = totLen; j < fieldWidth; ++j) {\r\n\t                        prefix = \" \" + prefix;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            return prefix + r;\r\n\t        };\r\n\r\n\t        //print(\"Rhs:\",rhs, \"ctor\", rhs.constructor);\r\n\t        if (rhs.constructor === Sk.builtin.tuple) {\r\n\t            value = rhs.v[i];\r\n\t        } else if (rhs.mp$subscript !== undefined && mappingKey !== undefined) {\r\n\t            mk = mappingKey.substring(1, mappingKey.length - 1);\r\n\t            //print(\"mk\",mk);\r\n\t            value = rhs.mp$subscript(new Sk.builtin.str(mk));\r\n\t        } else if (rhs.constructor === Sk.builtin.dict || rhs.constructor === Sk.builtin.list) {\r\n\t            // new case where only one argument is provided\r\n\t            value = rhs;\r\n\t        } else {\r\n\t            throw new Sk.builtin.AttributeError(rhs.tp$name + \" instance has no attribute 'mp$subscript'\");\r\n\t        }\r\n\t        base = 10;\r\n\t        if (conversionType === \"d\" || conversionType === \"i\") {\r\n\t            return handleWidth(formatNumber(value, 10));\r\n\t        } else if (conversionType === \"o\") {\r\n\t            return handleWidth(formatNumber(value, 8));\r\n\t        } else if (conversionType === \"x\") {\r\n\t            return handleWidth(formatNumber(value, 16));\r\n\t        } else if (conversionType === \"X\") {\r\n\t            return handleWidth(formatNumber(value, 16)).toUpperCase();\r\n\t        } else if (conversionType === \"f\" || conversionType === \"F\" || conversionType === \"e\" || conversionType === \"E\" || conversionType === \"g\" || conversionType === \"G\") {\r\n\t            convValue = Sk.builtin.asnum$(value);\r\n\t            if (typeof convValue === \"string\") {\r\n\t                convValue = Number(convValue);\r\n\t            }\r\n\t            if (convValue === Infinity) {\r\n\t                return \"inf\";\r\n\t            }\r\n\t            if (convValue === -Infinity) {\r\n\t                return \"-inf\";\r\n\t            }\r\n\t            if (isNaN(convValue)) {\r\n\t                return \"nan\";\r\n\t            }\r\n\t            convName = [\"toExponential\", \"toFixed\", \"toPrecision\"][\"efg\".indexOf(conversionType.toLowerCase())];\r\n\t            if (precision === undefined || precision === \"\") {\r\n\t                if (conversionType === \"e\" || conversionType === \"E\") {\r\n\t                    precision = 6;\r\n\t                } else if (conversionType === \"f\" || conversionType === \"F\") {\r\n\t                    precision = 7;\r\n\t                }\r\n\t            }\r\n\t            result = (convValue)[convName](precision); // possible loose of negative zero sign\r\n\r\n\t            // apply sign to negative zeros, floats only!\r\n\t            if(Sk.builtin.checkFloat(value)) {\r\n\t                if(convValue === 0 && 1/convValue === -Infinity) {\r\n\t                    result = \"-\" + result; // add sign for zero\r\n\t                }\r\n\t            }\r\n\r\n\t            if (\"EFG\".indexOf(conversionType) !== -1) {\r\n\t                result = result.toUpperCase();\r\n\t            }\r\n\t            return handleWidth([\"\", result]);\r\n\t        } else if (conversionType === \"c\") {\r\n\t            if (typeof value === \"number\") {\r\n\t                return String.fromCharCode(value);\r\n\t            } else if (value instanceof Sk.builtin.int_) {\r\n\t                return String.fromCharCode(value.v);\r\n\t            } else if (value instanceof Sk.builtin.float_) {\r\n\t                return String.fromCharCode(value.v);\r\n\t            } else if (value instanceof Sk.builtin.lng) {\r\n\t                return String.fromCharCode(value.str$(10, false)[0]);\r\n\t            } else if (value.constructor === Sk.builtin.str) {\r\n\t                return value.v.substr(0, 1);\r\n\t            } else {\r\n\t                throw new Sk.builtin.TypeError(\"an integer is required\");\r\n\t            }\r\n\t        } else if (conversionType === \"r\") {\r\n\t            r = Sk.builtin.repr(value);\r\n\t            if (precision) {\r\n\t                return r.v.substr(0, precision);\r\n\t            }\r\n\t            return r.v;\r\n\t        } else if (conversionType === \"s\") {\r\n\t            r = new Sk.builtin.str(value);\r\n\t            if (precision) {\r\n\t                return r.v.substr(0, precision);\r\n\t            }\r\n\t            if(fieldWidth) {\r\n\t                r.v = handleWidth([\" \", r.v]);\r\n\t            }\r\n\t            return r.v;\r\n\t        } else if (conversionType === \"%\") {\r\n\t            return \"%\";\r\n\t        }\r\n\t    };\r\n\r\n\t    ret = this.v.replace(regex, replFunc);\r\n\t    return new Sk.builtin.str(ret);\r\n\t};\r\n\r\n\t/**\r\n\t * @constructor\r\n\t * @param {Object} obj\r\n\t */\r\n\tSk.builtin.str_iter_ = function (obj) {\r\n\t    if (!(this instanceof Sk.builtin.str_iter_)) {\r\n\t        return new Sk.builtin.str_iter_(obj);\r\n\t    }\r\n\t    this.$index = 0;\r\n\t    this.$obj = obj.v.slice();\r\n\t    this.sq$length = this.$obj.length;\r\n\t    this.tp$iter = this;\r\n\t    this.tp$iternext = function () {\r\n\t        if (this.$index >= this.sq$length) {\r\n\t            return undefined;\r\n\t        }\r\n\t        return new Sk.builtin.str(this.$obj.substr(this.$index++, 1));\r\n\t    };\r\n\t    this.$r = function () {\r\n\t        return new Sk.builtin.str(\"iterator\");\r\n\t    };\r\n\t    return this;\r\n\t};\r\n\r\n\tSk.abstr.setUpInheritance(\"iterator\", Sk.builtin.str_iter_, Sk.builtin.object);\r\n\r\n\tSk.builtin.str_iter_.prototype.__class__ = Sk.builtin.str_iter_;\r\n\r\n\tSk.builtin.str_iter_.prototype.__iter__ = new Sk.builtin.func(function (self) {\r\n\t    Sk.builtin.pyCheckArgs(\"__iter__\", arguments, 0, 0, true, false);\r\n\t    return self;\r\n\t});\r\n\r\n\tSk.builtin.str_iter_.prototype[\"next\"] = new Sk.builtin.func(function (self) {\r\n\t    var ret = self.tp$iternext();\r\n\t    if (ret === undefined) {\r\n\t        throw new Sk.builtin.StopIteration();\r\n\t    }\r\n\t    return ret;\r\n\t});\r\n\r\n\r\n\r\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/tokenize.js ---- */ \r\n\r\n\t/*\r\n\t * This is a port of tokenize.py by Ka-Ping Yee.\r\n\t *\r\n\t * each call to readline should return one line of input as a string, or\r\n\t * undefined if it's finished.\r\n\t *\r\n\t * callback is called for each token with 5 args:\r\n\t * 1. the token type\r\n\t * 2. the token string\r\n\t * 3. [ start_row, start_col ]\r\n\t * 4. [ end_row, end_col ]\r\n\t * 5. logical line where the token was found, including continuation lines\r\n\t *\r\n\t * callback can return true to abort.\r\n\t *\r\n\t */\r\n\r\n\t/**\r\n\t * @constructor\r\n\t */\r\n\tSk.Tokenizer = function (filename, interactive, callback) {\r\n\t    this.filename = filename;\r\n\t    this.callback = callback;\r\n\t    this.lnum = 0;\r\n\t    this.parenlev = 0;\r\n\t    this.parenstack = [];\r\n\t    this.continued = false;\r\n\t    this.namechars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\";\r\n\t    this.numchars = \"0123456789\";\r\n\t    this.contstr = \"\";\r\n\t    this.needcont = false;\r\n\t    this.contline = undefined;\r\n\t    this.indents = [0];\r\n\t    this.endprog = /.*/;\r\n\t    this.strstart = [-1, -1];\r\n\t    this.interactive = interactive;\r\n\t    this.doneFunc = function () {\r\n\t        var i;\r\n\t        for (i = 1; i < this.indents.length; ++i) // pop remaining indent levels\r\n\t        {\r\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, \"\", [this.lnum, 0], [this.lnum, 0], \"\")) {\r\n\t                return \"done\";\r\n\t            }\r\n\t        }\r\n\t        if (this.callback(Sk.Tokenizer.Tokens.T_ENDMARKER, \"\", [this.lnum, 0], [this.lnum, 0], \"\")) {\r\n\t            return \"done\";\r\n\t        }\r\n\r\n\t        return \"failed\";\r\n\t    };\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * @enum {number}\r\n\t */\r\n\tSk.Tokenizer.Tokens = {\r\n\t    T_ENDMARKER       : 0,\r\n\t    T_NAME            : 1,\r\n\t    T_NUMBER          : 2,\r\n\t    T_STRING          : 3,\r\n\t    T_NEWLINE         : 4,\r\n\t    T_INDENT          : 5,\r\n\t    T_DEDENT          : 6,\r\n\t    T_LPAR            : 7,\r\n\t    T_RPAR            : 8,\r\n\t    T_LSQB            : 9,\r\n\t    T_RSQB            : 10,\r\n\t    T_COLON           : 11,\r\n\t    T_COMMA           : 12,\r\n\t    T_SEMI            : 13,\r\n\t    T_PLUS            : 14,\r\n\t    T_MINUS           : 15,\r\n\t    T_STAR            : 16,\r\n\t    T_SLASH           : 17,\r\n\t    T_VBAR            : 18,\r\n\t    T_AMPER           : 19,\r\n\t    T_LESS            : 20,\r\n\t    T_GREATER         : 21,\r\n\t    T_EQUAL           : 22,\r\n\t    T_DOT             : 23,\r\n\t    T_PERCENT         : 24,\r\n\t    T_BACKQUOTE       : 25,\r\n\t    T_LBRACE          : 26,\r\n\t    T_RBRACE          : 27,\r\n\t    T_EQEQUAL         : 28,\r\n\t    T_NOTEQUAL        : 29,\r\n\t    T_LESSEQUAL       : 30,\r\n\t    T_GREATEREQUAL    : 31,\r\n\t    T_TILDE           : 32,\r\n\t    T_CIRCUMFLEX      : 33,\r\n\t    T_LEFTSHIFT       : 34,\r\n\t    T_RIGHTSHIFT      : 35,\r\n\t    T_DOUBLESTAR      : 36,\r\n\t    T_PLUSEQUAL       : 37,\r\n\t    T_MINEQUAL        : 38,\r\n\t    T_STAREQUAL       : 39,\r\n\t    T_SLASHEQUAL      : 40,\r\n\t    T_PERCENTEQUAL    : 41,\r\n\t    T_AMPEREQUAL      : 42,\r\n\t    T_VBAREQUAL       : 43,\r\n\t    T_CIRCUMFLEXEQUAL : 44,\r\n\t    T_LEFTSHIFTEQUAL  : 45,\r\n\t    T_RIGHTSHIFTEQUAL : 46,\r\n\t    T_DOUBLESTAREQUAL : 47,\r\n\t    T_DOUBLESLASH     : 48,\r\n\t    T_DOUBLESLASHEQUAL: 49,\r\n\t    T_AT              : 50,\r\n\t    T_OP              : 51,\r\n\t    T_COMMENT         : 52,\r\n\t    T_NL              : 53,\r\n\t    T_RARROW          : 54,\r\n\t    T_ERRORTOKEN      : 55,\r\n\t    T_N_TOKENS        : 56,\r\n\t    T_NT_OFFSET       : 256\r\n\t};\r\n\r\n\t/** @param {...*} x */\r\n\tfunction group (x) {\r\n\t    var args = Array.prototype.slice.call(arguments);\r\n\t    return \"(\" + args.join(\"|\") + \")\";\r\n\t}\r\n\r\n\t/** @param {...*} x */\r\n\tfunction any (x) {\r\n\t    return group.apply(null, arguments) + \"*\";\r\n\t}\r\n\r\n\t/** @param {...*} x */\r\n\tfunction maybe (x) {\r\n\t    return group.apply(null, arguments) + \"?\";\r\n\t}\r\n\r\n\t/* we have to use string and ctor to be able to build patterns up. + on /.../\r\n\t * does something strange. */\r\n\tvar Whitespace = \"[ \\\\f\\\\t]*\";\r\n\tvar Comment_ = \"#[^\\\\r\\\\n]*\";\r\n\tvar Ident = \"[a-zA-Z_]\\\\w*\";\r\n\r\n\tvar Binnumber = \"0[bB][01]*\";\r\n\tvar Hexnumber = \"0[xX][\\\\da-fA-F]*[lL]?\";\r\n\tvar Octnumber = \"0[oO]?[0-7]*[lL]?\";\r\n\tvar Decnumber = \"[1-9]\\\\d*[lL]?\";\r\n\tvar Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber);\r\n\r\n\tvar Exponent = \"[eE][-+]?\\\\d+\";\r\n\tvar Pointfloat = group(\"\\\\d+\\\\.\\\\d*\", \"\\\\.\\\\d+\") + maybe(Exponent);\r\n\tvar Expfloat = \"\\\\d+\" + Exponent;\r\n\tvar Floatnumber = group(Pointfloat, Expfloat);\r\n\tvar Imagnumber = group(\"\\\\d+[jJ]\", Floatnumber + \"[jJ]\");\r\n\tvar Number_ = group(Imagnumber, Floatnumber, Intnumber);\r\n\r\n\t// tail end of ' string\r\n\tvar Single = \"^[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*'\";\r\n\t// tail end of \" string\r\n\tvar Double_ = '^[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*\"';\r\n\t// tail end of ''' string\r\n\tvar Single3 = \"[^'\\\\\\\\]*(?:(?:\\\\\\\\.|'(?!''))[^'\\\\\\\\]*)*'''\";\r\n\t// tail end of \"\"\" string\r\n\tvar Double3 = '[^\"\\\\\\\\]*(?:(?:\\\\\\\\.|\"(?!\"\"))[^\"\\\\\\\\]*)*\"\"\"';\r\n\tvar Triple = group(\"[ubUB]?[rR]?'''\", '[ubUB]?[rR]?\"\"\"');\r\n\tvar String_ = group(\"[uU]?[rR]?'[^\\\\n'\\\\\\\\]*(?:\\\\\\\\.[^\\\\n'\\\\\\\\]*)*'\",\r\n\t    '[uU]?[rR]?\"[^\\\\n\"\\\\\\\\]*(?:\\\\\\\\.[^\\\\n\"\\\\\\\\]*)*\"');\r\n\r\n\t// Because of leftmost-then-longest match semantics, be sure to put the\r\n\t// longest operators first (e.g., if = came before ==, == would get\r\n\t// recognized as two instances of =).\r\n\tvar Operator = group(\"\\\\*\\\\*=?\", \">>=?\", \"<<=?\", \"<>\", \"!=\",\r\n\t    \"//=?\", \"->\",\r\n\t    \"[+\\\\-*/%&|^=<>]=?\",\r\n\t    \"~\");\r\n\r\n\tvar Bracket = \"[\\\\][(){}]\";\r\n\tvar Special = group(\"\\\\r?\\\\n\", \"[:;.,`@]\");\r\n\tvar Funny = group(Operator, Bracket, Special);\r\n\r\n\tvar ContStr = group(\"[uUbB]?[rR]?'[^\\\\n'\\\\\\\\]*(?:\\\\\\\\.[^\\\\n'\\\\\\\\]*)*\" +\r\n\t        group(\"'\", \"\\\\\\\\\\\\r?\\\\n\"),\r\n\t        \"[uUbB]?[rR]?\\\"[^\\\\n\\\"\\\\\\\\]*(?:\\\\\\\\.[^\\\\n\\\"\\\\\\\\]*)*\" +\r\n\t        group(\"\\\"\", \"\\\\\\\\\\\\r?\\\\n\"));\r\n\tvar PseudoExtras = group(\"\\\\\\\\\\\\r?\\\\n\", Comment_, Triple);\r\n\t// Need to prefix with \"^\" as we only want to match what's next\r\n\tvar PseudoToken = \"^\" + group(PseudoExtras, Number_, Funny, ContStr, Ident);\r\n\r\n\r\n\tvar triple_quoted = {\r\n\t    \"'''\"  : true, '\"\"\"': true,\r\n\t    \"r'''\" : true, 'r\"\"\"': true, \"R'''\": true, 'R\"\"\"': true,\r\n\t    \"u'''\" : true, 'u\"\"\"': true, \"U'''\": true, 'U\"\"\"': true,\r\n\t    \"b'''\" : true, 'b\"\"\"': true, \"B'''\": true, 'B\"\"\"': true,\r\n\t    \"ur'''\": true, 'ur\"\"\"': true, \"Ur'''\": true, 'Ur\"\"\"': true,\r\n\t    \"uR'''\": true, 'uR\"\"\"': true, \"UR'''\": true, 'UR\"\"\"': true,\r\n\t    \"br'''\": true, 'br\"\"\"': true, \"Br'''\": true, 'Br\"\"\"': true,\r\n\t    \"bR'''\": true, 'bR\"\"\"': true, \"BR'''\": true, 'BR\"\"\"': true\r\n\t};\r\n\r\n\tvar single_quoted = {\r\n\t    \"'\"  : true, '\"': true,\r\n\t    \"r'\" : true, 'r\"': true, \"R'\": true, 'R\"': true,\r\n\t    \"u'\" : true, 'u\"': true, \"U'\": true, 'U\"': true,\r\n\t    \"b'\" : true, 'b\"': true, \"B'\": true, 'B\"': true,\r\n\t    \"ur'\": true, 'ur\"': true, \"Ur'\": true, 'Ur\"': true,\r\n\t    \"uR'\": true, 'uR\"': true, \"UR'\": true, 'UR\"': true,\r\n\t    \"br'\": true, 'br\"': true, \"Br'\": true, 'Br\"': true,\r\n\t    \"bR'\": true, 'bR\"': true, \"BR'\": true, 'BR\"': true\r\n\t};\r\n\r\n\t// hack to make closure keep those objects. not sure what a better way is.\r\n\t(function () {\r\n\t    var k;\r\n\t    for (k in triple_quoted) {\r\n\t    }\r\n\t    for (k in single_quoted) {\r\n\t    }\r\n\t}());\r\n\r\n\r\n\tvar tabsize = 8;\r\n\r\n\tfunction contains (a, obj) {\r\n\t    var i = a.length;\r\n\t    while (i--) {\r\n\t        if (a[i] === obj) {\r\n\t            return true;\r\n\t        }\r\n\t    }\r\n\t    return false;\r\n\t}\r\n\r\n\tfunction rstrip (input, what) {\r\n\t    var i;\r\n\t    for (i = input.length; i > 0; --i) {\r\n\t        if (what.indexOf(input.charAt(i - 1)) === -1) {\r\n\t            break;\r\n\t        }\r\n\t    }\r\n\t    return input.substring(0, i);\r\n\t}\r\n\r\n\tSk.Tokenizer.prototype.generateTokens = function (line) {\r\n\t    var nl_pos;\r\n\t    var newl;\r\n\t    var initial;\r\n\t    var token;\r\n\t    var epos;\r\n\t    var spos;\r\n\t    var start;\r\n\t    var pseudomatch;\r\n\t    var capos;\r\n\t    var comment_token;\r\n\t    var endmatch, pos, column, end, max;\r\n\r\n\r\n\t    // bnm - Move these definitions in this function otherwise test state is preserved between\r\n\t    // calls on single3prog and double3prog causing weird errors with having multiple instances\r\n\t    // of triple quoted strings in the same program.\r\n\r\n\t    var pseudoprog = new RegExp(PseudoToken);\r\n\t    var single3prog = new RegExp(Single3, \"g\");\r\n\t    var double3prog = new RegExp(Double3, \"g\");\r\n\r\n\t    var endprogs = {     \"'\": new RegExp(Single, \"g\"), \"\\\"\": new RegExp(Double_, \"g\"),\r\n\t        \"'''\"               : single3prog, '\"\"\"': double3prog,\r\n\t        \"r'''\"              : single3prog, 'r\"\"\"': double3prog,\r\n\t        \"u'''\"              : single3prog, 'u\"\"\"': double3prog,\r\n\t        \"b'''\"              : single3prog, 'b\"\"\"': double3prog,\r\n\t        \"ur'''\"             : single3prog, 'ur\"\"\"': double3prog,\r\n\t        \"br'''\"             : single3prog, 'br\"\"\"': double3prog,\r\n\t        \"R'''\"              : single3prog, 'R\"\"\"': double3prog,\r\n\t        \"U'''\"              : single3prog, 'U\"\"\"': double3prog,\r\n\t        \"B'''\"              : single3prog, 'B\"\"\"': double3prog,\r\n\t        \"uR'''\"             : single3prog, 'uR\"\"\"': double3prog,\r\n\t        \"Ur'''\"             : single3prog, 'Ur\"\"\"': double3prog,\r\n\t        \"UR'''\"             : single3prog, 'UR\"\"\"': double3prog,\r\n\t        \"bR'''\"             : single3prog, 'bR\"\"\"': double3prog,\r\n\t        \"Br'''\"             : single3prog, 'Br\"\"\"': double3prog,\r\n\t        \"BR'''\"             : single3prog, 'BR\"\"\"': double3prog,\r\n\t        'r'                 : null, 'R': null,\r\n\t        'u'                 : null, 'U': null,\r\n\t        'b'                 : null, 'B': null\r\n\t    };\r\n\r\n\r\n\t    if (!line) {\r\n\t        line = '';\r\n\t    }\r\n\t    //print(\"LINE:'\"+line+\"'\");\r\n\r\n\t    this.lnum += 1;\r\n\t    pos = 0;\r\n\t    max = line.length;\r\n\r\n\t    if (this.contstr.length > 0) {\r\n\t        if (!line) {\r\n\t            throw new Sk.builtin.SyntaxError(\"EOF in multi-line string\", this.filename, this.strstart[0], this.strstart[1], {\r\n\t                kind: \"STRING_EOF\",\r\n\t                line: this.contline\r\n\t            });\r\n\t        }\r\n\t        this.endprog.lastIndex = 0;\r\n\t        endmatch = this.endprog.test(line);\r\n\t        if (endmatch) {\r\n\t            pos = end = this.endprog.lastIndex;\r\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_STRING, this.contstr + line.substring(0, end),\r\n\t                this.strstart, [this.lnum, end], this.contline + line)) {\r\n\t                return 'done';\r\n\t            }\r\n\t            this.contstr = '';\r\n\t            this.needcont = false;\r\n\t            this.contline = undefined;\r\n\t        }\r\n\t        else if (this.needcont && line.substring(line.length - 2) !== \"\\\\\\n\" && line.substring(line.length - 3) !== \"\\\\\\r\\n\") {\r\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, this.contstr + line,\r\n\t                this.strstart, [this.lnum, line.length], this.contline)) {\r\n\t                return 'done';\r\n\t            }\r\n\t            this.contstr = '';\r\n\t            this.contline = undefined;\r\n\t            return false;\r\n\t        }\r\n\t        else {\r\n\t            this.contstr += line;\r\n\t            this.contline = this.contline + line;\r\n\t            return false;\r\n\t        }\r\n\t    }\r\n\t    else if (this.parenlev === 0 && !this.continued) {\r\n\t        if (!line) {\r\n\t            return this.doneFunc();\r\n\t        }\r\n\t        column = 0;\r\n\t        while (pos < max) {\r\n\t            if (line.charAt(pos) === ' ') {\r\n\t                column += 1;\r\n\t            }\r\n\t            else if (line.charAt(pos) === '\\t') {\r\n\t                column = (column / tabsize + 1) * tabsize;\r\n\t            }\r\n\t            else if (line.charAt(pos) === '\\f') {\r\n\t                column = 0;\r\n\t            }\r\n\t            else {\r\n\t                break;\r\n\t            }\r\n\t            pos = pos + 1;\r\n\t        }\r\n\t        if (pos === max) {\r\n\t            return this.doneFunc();\r\n\t        }\r\n\r\n\t        if (\"#\\r\\n\".indexOf(line.charAt(pos)) !== -1) // skip comments or blank lines\r\n\t        {\r\n\t            if (line.charAt(pos) === '#') {\r\n\t                comment_token = rstrip(line.substring(pos), '\\r\\n');\r\n\t                nl_pos = pos + comment_token.length;\r\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_COMMENT, comment_token,\r\n\t                    [this.lnum, pos], [this.lnum, pos + comment_token.length], line)) {\r\n\t                    return 'done';\r\n\t                }\r\n\t                //print(\"HERE:1\");\r\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_NL, line.substring(nl_pos),\r\n\t                    [this.lnum, nl_pos], [this.lnum, line.length], line)) {\r\n\t                    return 'done';\r\n\t                }\r\n\t                return false;\r\n\t            }\r\n\t            else {\r\n\t                //print(\"HERE:2\");\r\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_NL, line.substring(pos),\r\n\t                    [this.lnum, pos], [this.lnum, line.length], line)) {\r\n\t                    return 'done';\r\n\t                }\r\n\t                if (!this.interactive) {\r\n\t                    return false;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        if (column > this.indents[this.indents.length - 1]) // count indents or dedents\r\n\t        {\r\n\t            this.indents.push(column);\r\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_INDENT, line.substring(0, pos), [this.lnum, 0], [this.lnum, pos], line)) {\r\n\t                return 'done';\r\n\t            }\r\n\t        }\r\n\t        while (column < this.indents[this.indents.length - 1]) {\r\n\t            if (!contains(this.indents, column)) {\r\n\t                throw new Sk.builtin.IndentationError(\"unindent does not match any outer indentation level\",\r\n\t                    this.filename, this.lnum, pos, line);\r\n\t            }\r\n\t            this.indents.splice(this.indents.length - 1, 1);\r\n\t            //print(\"dedent here\");\r\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, '', [this.lnum, pos], [this.lnum, pos], line)) {\r\n\t                return 'done';\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    else // continued statement\r\n\t    {\r\n\t        if (!line) {\r\n\t            throw new Sk.builtin.SyntaxError(\"EOF in multi-line statement\", this.filename, this.lnum, 0, {\r\n\t                kind: 'STATEMENT_EOF',\r\n\t                parenlev: this.parenlev,\r\n\t                parenstack: this.parenstack\r\n\t            });\r\n\t        }\r\n\t        this.continued = false;\r\n\t    }\r\n\r\n\t    while (pos < max) {\r\n\t        //print(\"pos:\"+pos+\":\"+max);\r\n\t        // js regexes don't return any info about matches, other than the\r\n\t        // content. we'd like to put a \\w+ before pseudomatch, but then we\r\n\t        // can't get any data\r\n\t        capos = line.charAt(pos);\r\n\t        while (capos === ' ' || capos === '\\f' || capos === '\\t') {\r\n\t            pos += 1;\r\n\t            capos = line.charAt(pos);\r\n\t        }\r\n\t        pseudoprog.lastIndex = 0;\r\n\t        pseudomatch = pseudoprog.exec(line.substring(pos));\r\n\t        if (pseudomatch) {\r\n\t            start = pos;\r\n\t            end = start + pseudomatch[1].length;\r\n\t            spos = [this.lnum, start];\r\n\t            epos = [this.lnum, end];\r\n\t            pos = end;\r\n\t            token = line.substring(start, end);\r\n\t            initial = line.charAt(start);\r\n\t            //Sk.debugout(\"token:\",token, \"initial:\",initial, start, end);\r\n\t            if (this.numchars.indexOf(initial) !== -1 || (initial === '.' && token !== '.')) {\r\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_NUMBER, token, spos, epos, line)) {\r\n\t                    return 'done';\r\n\t                }\r\n\t            }\r\n\t            else if (initial === '\\r' || initial === '\\n') {\r\n\t                newl = Sk.Tokenizer.Tokens.T_NEWLINE;\r\n\t                //print(\"HERE:3\");\r\n\t                if (this.parenlev > 0) {\r\n\t                    newl = Sk.Tokenizer.Tokens.T_NL;\r\n\t                }\r\n\t                if (this.callback(newl, token, spos, epos, line)) {\r\n\t                    return 'done';\r\n\t                }\r\n\t            }\r\n\t            else if (initial === '#') {\r\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_COMMENT, token, spos, epos, line)) {\r\n\t                    return 'done';\r\n\t                }\r\n\t            }\r\n\t            else if (triple_quoted.hasOwnProperty(token)) {\r\n\t                this.endprog = endprogs[token];\r\n\t                this.endprog.lastIndex = 0;\r\n\t                endmatch = this.endprog.test(line.substring(pos));\r\n\t                if (endmatch) {\r\n\t                    pos = this.endprog.lastIndex + pos;\r\n\t                    token = line.substring(start, pos);\r\n\t                    if (this.callback(Sk.Tokenizer.Tokens.T_STRING, token, spos, [this.lnum, pos], line)) {\r\n\t                        return 'done';\r\n\t                    }\r\n\t                }\r\n\t                else {\r\n\t                    this.strstart = [this.lnum, start];\r\n\t                    this.contstr = line.substring(start);\r\n\t                    this.contline = line;\r\n\t                    return false;\r\n\t                }\r\n\t            }\r\n\t            else if (single_quoted.hasOwnProperty(initial) ||\r\n\t                single_quoted.hasOwnProperty(token.substring(0, 2)) ||\r\n\t                single_quoted.hasOwnProperty(token.substring(0, 3))) {\r\n\t                if (token[token.length - 1] === '\\n') {\r\n\t                    this.strstart = [this.lnum, start];\r\n\t                    this.endprog = endprogs[initial] || endprogs[token[1]] || endprogs[token[2]];\r\n\t                    this.contstr = line.substring(start);\r\n\t                    this.needcont = true;\r\n\t                    this.contline = line;\r\n\t                    //print(\"i, t1, t2\", initial, token[1], token[2]);\r\n\t                    //print(\"ep, cs\", this.endprog, this.contstr);\r\n\t                    return false;\r\n\t                }\r\n\t                else {\r\n\t                    if (this.callback(Sk.Tokenizer.Tokens.T_STRING, token, spos, epos, line)) {\r\n\t                        return 'done';\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            else if (this.namechars.indexOf(initial) !== -1) {\r\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_NAME, token, spos, epos, line)) {\r\n\t                    return 'done';\r\n\t                }\r\n\t            }\r\n\t            else if (initial === '\\\\') {\r\n\t                //print(\"HERE:4\");\r\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_NL, token, spos, [this.lnum, pos], line)) {\r\n\t                    return 'done';\r\n\t                }\r\n\t                this.continued = true;\r\n\t            }\r\n\t            else {\r\n\t                if ('([{'.indexOf(initial) !== -1) {\r\n\t                    this.parenlev += 1;\r\n\t                    this.parenstack.push([initial, this.lnum, pos]);\r\n\t                }\r\n\t                else if (')]}'.indexOf(initial) !== -1) {\r\n\t                    this.parenlev -= 1;\r\n\t                    this.parenstack.pop();\r\n\t                }\r\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_OP, token, spos, epos, line)) {\r\n\t                    return 'done';\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        else {\r\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, line.charAt(pos),\r\n\t                [this.lnum, pos], [this.lnum, pos + 1], line)) {\r\n\t                return 'done';\r\n\t            }\r\n\t            pos += 1;\r\n\t        }\r\n\t    }\r\n\r\n\t    return false;\r\n\t};\r\n\r\n\tSk.Tokenizer.tokenNames = {\r\n\t    0  : 'T_ENDMARKER', 1: 'T_NAME', 2: 'T_NUMBER', 3: 'T_STRING', 4: 'T_NEWLINE',\r\n\t    5  : 'T_INDENT', 6: 'T_DEDENT', 7: 'T_LPAR', 8: 'T_RPAR', 9: 'T_LSQB',\r\n\t    10 : 'T_RSQB', 11: 'T_COLON', 12: 'T_COMMA', 13: 'T_SEMI', 14: 'T_PLUS',\r\n\t    15 : 'T_MINUS', 16: 'T_STAR', 17: 'T_SLASH', 18: 'T_VBAR', 19: 'T_AMPER',\r\n\t    20 : 'T_LESS', 21: 'T_GREATER', 22: 'T_EQUAL', 23: 'T_DOT', 24: 'T_PERCENT',\r\n\t    25 : 'T_BACKQUOTE', 26: 'T_LBRACE', 27: 'T_RBRACE', 28: 'T_EQEQUAL', 29: 'T_NOTEQUAL',\r\n\t    30 : 'T_LESSEQUAL', 31: 'T_GREATEREQUAL', 32: 'T_TILDE', 33: 'T_CIRCUMFLEX', 34: 'T_LEFTSHIFT',\r\n\t    35 : 'T_RIGHTSHIFT', 36: 'T_DOUBLESTAR', 37: 'T_PLUSEQUAL', 38: 'T_MINEQUAL', 39: 'T_STAREQUAL',\r\n\t    40 : 'T_SLASHEQUAL', 41: 'T_PERCENTEQUAL', 42: 'T_AMPEREQUAL', 43: 'T_VBAREQUAL', 44: 'T_CIRCUMFLEXEQUAL',\r\n\t    45 : 'T_LEFTSHIFTEQUAL', 46: 'T_RIGHTSHIFTEQUAL', 47: 'T_DOUBLESTAREQUAL', 48: 'T_DOUBLESLASH', 49: 'T_DOUBLESLASHEQUAL',\r\n\t    50 : 'T_AT', 51: 'T_OP', 52: 'T_COMMENT', 53: 'T_NL', 54: 'T_RARROW',\r\n\t    55 : 'T_ERRORTOKEN', 56: 'T_N_TOKENS',\r\n\t    256: 'T_NT_OFFSET'\r\n\t};\r\n\r\n\tgoog.exportSymbol(\"Sk.Tokenizer\", Sk.Tokenizer);\r\n\tgoog.exportSymbol(\"Sk.Tokenizer.prototype.generateTokens\", Sk.Tokenizer.prototype.generateTokens);\r\n\tgoog.exportSymbol(\"Sk.Tokenizer.tokenNames\", Sk.Tokenizer.tokenNames);\r\n\r\n\r\n\r\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/gen/parse_tables.js ---- */ \r\n\r\n\t// generated by pgen/main.py\r\n\tSk.OpMap = {\r\n\t\"(\": Sk.Tokenizer.Tokens.T_LPAR,\r\n\t\")\": Sk.Tokenizer.Tokens.T_RPAR,\r\n\t\"[\": Sk.Tokenizer.Tokens.T_LSQB,\r\n\t\"]\": Sk.Tokenizer.Tokens.T_RSQB,\r\n\t\":\": Sk.Tokenizer.Tokens.T_COLON,\r\n\t\",\": Sk.Tokenizer.Tokens.T_COMMA,\r\n\t\";\": Sk.Tokenizer.Tokens.T_SEMI,\r\n\t\"+\": Sk.Tokenizer.Tokens.T_PLUS,\r\n\t\"-\": Sk.Tokenizer.Tokens.T_MINUS,\r\n\t\"*\": Sk.Tokenizer.Tokens.T_STAR,\r\n\t\"/\": Sk.Tokenizer.Tokens.T_SLASH,\r\n\t\"|\": Sk.Tokenizer.Tokens.T_VBAR,\r\n\t\"&\": Sk.Tokenizer.Tokens.T_AMPER,\r\n\t\"<\": Sk.Tokenizer.Tokens.T_LESS,\r\n\t\">\": Sk.Tokenizer.Tokens.T_GREATER,\r\n\t\"=\": Sk.Tokenizer.Tokens.T_EQUAL,\r\n\t\".\": Sk.Tokenizer.Tokens.T_DOT,\r\n\t\"%\": Sk.Tokenizer.Tokens.T_PERCENT,\r\n\t\"`\": Sk.Tokenizer.Tokens.T_BACKQUOTE,\r\n\t\"{\": Sk.Tokenizer.Tokens.T_LBRACE,\r\n\t\"}\": Sk.Tokenizer.Tokens.T_RBRACE,\r\n\t\"@\": Sk.Tokenizer.Tokens.T_AT,\r\n\t\"==\": Sk.Tokenizer.Tokens.T_EQEQUAL,\r\n\t\"!=\": Sk.Tokenizer.Tokens.T_NOTEQUAL,\r\n\t\"<>\": Sk.Tokenizer.Tokens.T_NOTEQUAL,\r\n\t\"<=\": Sk.Tokenizer.Tokens.T_LESSEQUAL,\r\n\t\">=\": Sk.Tokenizer.Tokens.T_GREATEREQUAL,\r\n\t\"~\": Sk.Tokenizer.Tokens.T_TILDE,\r\n\t\"^\": Sk.Tokenizer.Tokens.T_CIRCUMFLEX,\r\n\t\"<<\": Sk.Tokenizer.Tokens.T_LEFTSHIFT,\r\n\t\">>\": Sk.Tokenizer.Tokens.T_RIGHTSHIFT,\r\n\t\"**\": Sk.Tokenizer.Tokens.T_DOUBLESTAR,\r\n\t\"+=\": Sk.Tokenizer.Tokens.T_PLUSEQUAL,\r\n\t\"-=\": Sk.Tokenizer.Tokens.T_MINEQUAL,\r\n\t\"*=\": Sk.Tokenizer.Tokens.T_STAREQUAL,\r\n\t\"/=\": Sk.Tokenizer.Tokens.T_SLASHEQUAL,\r\n\t\"%=\": Sk.Tokenizer.Tokens.T_PERCENTEQUAL,\r\n\t\"&=\": Sk.Tokenizer.Tokens.T_AMPEREQUAL,\r\n\t\"|=\": Sk.Tokenizer.Tokens.T_VBAREQUAL,\r\n\t\"^=\": Sk.Tokenizer.Tokens.T_CIRCUMFLEXEQUAL,\r\n\t\"<<=\": Sk.Tokenizer.Tokens.T_LEFTSHIFTEQUAL,\r\n\t\">>=\": Sk.Tokenizer.Tokens.T_RIGHTSHIFTEQUAL,\r\n\t\"**=\": Sk.Tokenizer.Tokens.T_DOUBLESTAREQUAL,\r\n\t\"//\": Sk.Tokenizer.Tokens.T_DOUBLESLASH,\r\n\t\"//=\": Sk.Tokenizer.Tokens.T_DOUBLESLASHEQUAL,\r\n\t\"->\": Sk.Tokenizer.Tokens.T_RARROW\r\n\t};\r\n\tSk.ParseTables = {\r\n\tsym:\r\n\t{and_expr: 257,\r\n\t and_test: 258,\r\n\t arglist: 259,\r\n\t argument: 260,\r\n\t arith_expr: 261,\r\n\t assert_stmt: 262,\r\n\t atom: 263,\r\n\t augassign: 264,\r\n\t break_stmt: 265,\r\n\t classdef: 266,\r\n\t comp_for: 267,\r\n\t comp_if: 268,\r\n\t comp_iter: 269,\r\n\t comp_op: 270,\r\n\t comparison: 271,\r\n\t compound_stmt: 272,\r\n\t continue_stmt: 273,\r\n\t debugger_stmt: 274,\r\n\t decorated: 275,\r\n\t decorator: 276,\r\n\t decorators: 277,\r\n\t del_stmt: 278,\r\n\t dictorsetmaker: 279,\r\n\t dotted_as_name: 280,\r\n\t dotted_as_names: 281,\r\n\t dotted_name: 282,\r\n\t encoding_decl: 283,\r\n\t eval_input: 284,\r\n\t except_clause: 285,\r\n\t exec_stmt: 286,\r\n\t expr: 287,\r\n\t expr_stmt: 288,\r\n\t exprlist: 289,\r\n\t factor: 290,\r\n\t file_input: 291,\r\n\t flow_stmt: 292,\r\n\t for_stmt: 293,\r\n\t fpdef: 294,\r\n\t fplist: 295,\r\n\t funcdef: 296,\r\n\t global_stmt: 297,\r\n\t if_stmt: 298,\r\n\t import_as_name: 299,\r\n\t import_as_names: 300,\r\n\t import_from: 301,\r\n\t import_name: 302,\r\n\t import_stmt: 303,\r\n\t lambdef: 304,\r\n\t list_for: 305,\r\n\t list_if: 306,\r\n\t list_iter: 307,\r\n\t listmaker: 308,\r\n\t not_test: 309,\r\n\t old_lambdef: 310,\r\n\t old_test: 311,\r\n\t or_test: 312,\r\n\t parameters: 313,\r\n\t pass_stmt: 314,\r\n\t power: 315,\r\n\t print_stmt: 316,\r\n\t raise_stmt: 317,\r\n\t return_stmt: 318,\r\n\t shift_expr: 319,\r\n\t simple_stmt: 320,\r\n\t single_input: 256,\r\n\t sliceop: 321,\r\n\t small_stmt: 322,\r\n\t stmt: 323,\r\n\t subscript: 324,\r\n\t subscriptlist: 325,\r\n\t suite: 326,\r\n\t term: 327,\r\n\t test: 328,\r\n\t testlist: 329,\r\n\t testlist1: 330,\r\n\t testlist_comp: 331,\r\n\t testlist_safe: 332,\r\n\t trailer: 333,\r\n\t try_stmt: 334,\r\n\t varargslist: 335,\r\n\t while_stmt: 336,\r\n\t with_item: 337,\r\n\t with_stmt: 338,\r\n\t xor_expr: 339,\r\n\t yield_expr: 340,\r\n\t yield_stmt: 341},\r\n\tnumber2symbol:\r\n\t{256: 'single_input',\r\n\t 257: 'and_expr',\r\n\t 258: 'and_test',\r\n\t 259: 'arglist',\r\n\t 260: 'argument',\r\n\t 261: 'arith_expr',\r\n\t 262: 'assert_stmt',\r\n\t 263: 'atom',\r\n\t 264: 'augassign',\r\n\t 265: 'break_stmt',\r\n\t 266: 'classdef',\r\n\t 267: 'comp_for',\r\n\t 268: 'comp_if',\r\n\t 269: 'comp_iter',\r\n\t 270: 'comp_op',\r\n\t 271: 'comparison',\r\n\t 272: 'compound_stmt',\r\n\t 273: 'continue_stmt',\r\n\t 274: 'debugger_stmt',\r\n\t 275: 'decorated',\r\n\t 276: 'decorator',\r\n\t 277: 'decorators',\r\n\t 278: 'del_stmt',\r\n\t 279: 'dictorsetmaker',\r\n\t 280: 'dotted_as_name',\r\n\t 281: 'dotted_as_names',\r\n\t 282: 'dotted_name',\r\n\t 283: 'encoding_decl',\r\n\t 284: 'eval_input',\r\n\t 285: 'except_clause',\r\n\t 286: 'exec_stmt',\r\n\t 287: 'expr',\r\n\t 288: 'expr_stmt',\r\n\t 289: 'exprlist',\r\n\t 290: 'factor',\r\n\t 291: 'file_input',\r\n\t 292: 'flow_stmt',\r\n\t 293: 'for_stmt',\r\n\t 294: 'fpdef',\r\n\t 295: 'fplist',\r\n\t 296: 'funcdef',\r\n\t 297: 'global_stmt',\r\n\t 298: 'if_stmt',\r\n\t 299: 'import_as_name',\r\n\t 300: 'import_as_names',\r\n\t 301: 'import_from',\r\n\t 302: 'import_name',\r\n\t 303: 'import_stmt',\r\n\t 304: 'lambdef',\r\n\t 305: 'list_for',\r\n\t 306: 'list_if',\r\n\t 307: 'list_iter',\r\n\t 308: 'listmaker',\r\n\t 309: 'not_test',\r\n\t 310: 'old_lambdef',\r\n\t 311: 'old_test',\r\n\t 312: 'or_test',\r\n\t 313: 'parameters',\r\n\t 314: 'pass_stmt',\r\n\t 315: 'power',\r\n\t 316: 'print_stmt',\r\n\t 317: 'raise_stmt',\r\n\t 318: 'return_stmt',\r\n\t 319: 'shift_expr',\r\n\t 320: 'simple_stmt',\r\n\t 321: 'sliceop',\r\n\t 322: 'small_stmt',\r\n\t 323: 'stmt',\r\n\t 324: 'subscript',\r\n\t 325: 'subscriptlist',\r\n\t 326: 'suite',\r\n\t 327: 'term',\r\n\t 328: 'test',\r\n\t 329: 'testlist',\r\n\t 330: 'testlist1',\r\n\t 331: 'testlist_comp',\r\n\t 332: 'testlist_safe',\r\n\t 333: 'trailer',\r\n\t 334: 'try_stmt',\r\n\t 335: 'varargslist',\r\n\t 336: 'while_stmt',\r\n\t 337: 'with_item',\r\n\t 338: 'with_stmt',\r\n\t 339: 'xor_expr',\r\n\t 340: 'yield_expr',\r\n\t 341: 'yield_stmt'},\r\n\tdfas:\r\n\t{256: [[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]],\r\n\t       {2: 1,\r\n\t        4: 1,\r\n\t        5: 1,\r\n\t        6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        10: 1,\r\n\t        11: 1,\r\n\t        12: 1,\r\n\t        13: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        16: 1,\r\n\t        17: 1,\r\n\t        18: 1,\r\n\t        19: 1,\r\n\t        20: 1,\r\n\t        21: 1,\r\n\t        22: 1,\r\n\t        23: 1,\r\n\t        24: 1,\r\n\t        25: 1,\r\n\t        26: 1,\r\n\t        27: 1,\r\n\t        28: 1,\r\n\t        29: 1,\r\n\t        30: 1,\r\n\t        31: 1,\r\n\t        32: 1,\r\n\t        33: 1,\r\n\t        34: 1,\r\n\t        35: 1,\r\n\t        36: 1,\r\n\t        37: 1}],\r\n\t 257: [[[[38, 1]], [[39, 0], [0, 1]]],\r\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\r\n\t 258: [[[[40, 1]], [[41, 0], [0, 1]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1}],\r\n\t 259: [[[[42, 1], [43, 2], [44, 3]],\r\n\t        [[45, 4]],\r\n\t        [[46, 5], [0, 2]],\r\n\t        [[45, 6]],\r\n\t        [[46, 7], [0, 4]],\r\n\t        [[42, 1], [43, 2], [44, 3], [0, 5]],\r\n\t        [[0, 6]],\r\n\t        [[43, 4], [44, 3]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1,\r\n\t        42: 1,\r\n\t        44: 1}],\r\n\t 260: [[[[45, 1]], [[47, 2], [48, 3], [0, 1]], [[45, 3]], [[0, 3]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1}],\r\n\t 261: [[[[49, 1]], [[26, 0], [37, 0], [0, 1]]],\r\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\r\n\t 262: [[[[21, 1]], [[45, 2]], [[46, 3], [0, 2]], [[45, 4]], [[0, 4]]],\r\n\t       {21: 1}],\r\n\t 263: [[[[19, 1], [8, 2], [9, 5], [30, 4], [14, 3], [15, 6], [22, 2]],\r\n\t        [[19, 1], [0, 1]],\r\n\t        [[0, 2]],\r\n\t        [[50, 7], [51, 2]],\r\n\t        [[52, 2], [53, 8], [54, 8]],\r\n\t        [[55, 2], [56, 9]],\r\n\t        [[57, 10]],\r\n\t        [[51, 2]],\r\n\t        [[52, 2]],\r\n\t        [[55, 2]],\r\n\t        [[15, 2]]],\r\n\t       {8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 30: 1}],\r\n\t 264: [[[[58, 1],\r\n\t         [59, 1],\r\n\t         [60, 1],\r\n\t         [61, 1],\r\n\t         [62, 1],\r\n\t         [63, 1],\r\n\t         [64, 1],\r\n\t         [65, 1],\r\n\t         [66, 1],\r\n\t         [67, 1],\r\n\t         [68, 1],\r\n\t         [69, 1]],\r\n\t        [[0, 1]]],\r\n\t       {58: 1,\r\n\t        59: 1,\r\n\t        60: 1,\r\n\t        61: 1,\r\n\t        62: 1,\r\n\t        63: 1,\r\n\t        64: 1,\r\n\t        65: 1,\r\n\t        66: 1,\r\n\t        67: 1,\r\n\t        68: 1,\r\n\t        69: 1}],\r\n\t 265: [[[[33, 1]], [[0, 1]]], {33: 1}],\r\n\t 266: [[[[10, 1]],\r\n\t        [[22, 2]],\r\n\t        [[70, 3], [30, 4]],\r\n\t        [[71, 5]],\r\n\t        [[52, 6], [72, 7]],\r\n\t        [[0, 5]],\r\n\t        [[70, 3]],\r\n\t        [[52, 6]]],\r\n\t       {10: 1}],\r\n\t 267: [[[[29, 1]],\r\n\t        [[73, 2]],\r\n\t        [[74, 3]],\r\n\t        [[75, 4]],\r\n\t        [[76, 5], [0, 4]],\r\n\t        [[0, 5]]],\r\n\t       {29: 1}],\r\n\t 268: [[[[32, 1]], [[77, 2]], [[76, 3], [0, 2]], [[0, 3]]], {32: 1}],\r\n\t 269: [[[[78, 1], [48, 1]], [[0, 1]]], {29: 1, 32: 1}],\r\n\t 270: [[[[79, 1],\r\n\t         [80, 1],\r\n\t         [7, 2],\r\n\t         [81, 1],\r\n\t         [79, 1],\r\n\t         [74, 1],\r\n\t         [82, 1],\r\n\t         [83, 3],\r\n\t         [84, 1],\r\n\t         [85, 1]],\r\n\t        [[0, 1]],\r\n\t        [[74, 1]],\r\n\t        [[7, 1], [0, 3]]],\r\n\t       {7: 1, 74: 1, 79: 1, 80: 1, 81: 1, 82: 1, 83: 1, 84: 1, 85: 1}],\r\n\t 271: [[[[86, 1]], [[87, 0], [0, 1]]],\r\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\r\n\t 272: [[[[88, 1],\r\n\t         [89, 1],\r\n\t         [90, 1],\r\n\t         [91, 1],\r\n\t         [92, 1],\r\n\t         [93, 1],\r\n\t         [94, 1],\r\n\t         [95, 1]],\r\n\t        [[0, 1]]],\r\n\t       {4: 1, 10: 1, 16: 1, 18: 1, 29: 1, 32: 1, 35: 1, 36: 1}],\r\n\t 273: [[[[34, 1]], [[0, 1]]], {34: 1}],\r\n\t 274: [[[[13, 1]], [[0, 1]]], {13: 1}],\r\n\t 275: [[[[96, 1]], [[94, 2], [91, 2]], [[0, 2]]], {35: 1}],\r\n\t 276: [[[[35, 1]],\r\n\t        [[97, 2]],\r\n\t        [[2, 4], [30, 3]],\r\n\t        [[52, 5], [98, 6]],\r\n\t        [[0, 4]],\r\n\t        [[2, 4]],\r\n\t        [[52, 5]]],\r\n\t       {35: 1}],\r\n\t 277: [[[[99, 1]], [[99, 1], [0, 1]]], {35: 1}],\r\n\t 278: [[[[23, 1]], [[73, 2]], [[0, 2]]], {23: 1}],\r\n\t 279: [[[[45, 1]],\r\n\t        [[70, 2], [48, 3], [46, 4], [0, 1]],\r\n\t        [[45, 5]],\r\n\t        [[0, 3]],\r\n\t        [[45, 6], [0, 4]],\r\n\t        [[48, 3], [46, 7], [0, 5]],\r\n\t        [[46, 4], [0, 6]],\r\n\t        [[45, 8], [0, 7]],\r\n\t        [[70, 9]],\r\n\t        [[45, 10]],\r\n\t        [[46, 7], [0, 10]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1}],\r\n\t 280: [[[[97, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]], {22: 1}],\r\n\t 281: [[[[101, 1]], [[46, 0], [0, 1]]], {22: 1}],\r\n\t 282: [[[[22, 1]], [[102, 0], [0, 1]]], {22: 1}],\r\n\t 283: [[[[22, 1]], [[0, 1]]], {22: 1}],\r\n\t 284: [[[[72, 1]], [[2, 1], [103, 2]], [[0, 2]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1}],\r\n\t 285: [[[[104, 1]],\r\n\t        [[45, 2], [0, 1]],\r\n\t        [[100, 3], [46, 3], [0, 2]],\r\n\t        [[45, 4]],\r\n\t        [[0, 4]]],\r\n\t       {104: 1}],\r\n\t 286: [[[[17, 1]],\r\n\t        [[86, 2]],\r\n\t        [[74, 3], [0, 2]],\r\n\t        [[45, 4]],\r\n\t        [[46, 5], [0, 4]],\r\n\t        [[45, 6]],\r\n\t        [[0, 6]]],\r\n\t       {17: 1}],\r\n\t 287: [[[[105, 1]], [[106, 0], [0, 1]]],\r\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\r\n\t 288: [[[[72, 1]],\r\n\t        [[107, 2], [47, 3], [0, 1]],\r\n\t        [[72, 4], [53, 4]],\r\n\t        [[72, 5], [53, 5]],\r\n\t        [[0, 4]],\r\n\t        [[47, 3], [0, 5]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1}],\r\n\t 289: [[[[86, 1]], [[46, 2], [0, 1]], [[86, 1], [0, 2]]],\r\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\r\n\t 290: [[[[37, 2], [26, 2], [6, 2], [108, 1]], [[0, 1]], [[109, 1]]],\r\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\r\n\t 291: [[[[2, 0], [103, 1], [110, 0]], [[0, 1]]],\r\n\t       {2: 1,\r\n\t        4: 1,\r\n\t        5: 1,\r\n\t        6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        10: 1,\r\n\t        11: 1,\r\n\t        12: 1,\r\n\t        13: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        16: 1,\r\n\t        17: 1,\r\n\t        18: 1,\r\n\t        19: 1,\r\n\t        20: 1,\r\n\t        21: 1,\r\n\t        22: 1,\r\n\t        23: 1,\r\n\t        24: 1,\r\n\t        25: 1,\r\n\t        26: 1,\r\n\t        27: 1,\r\n\t        28: 1,\r\n\t        29: 1,\r\n\t        30: 1,\r\n\t        31: 1,\r\n\t        32: 1,\r\n\t        33: 1,\r\n\t        34: 1,\r\n\t        35: 1,\r\n\t        36: 1,\r\n\t        37: 1,\r\n\t        103: 1}],\r\n\t 292: [[[[111, 1], [112, 1], [113, 1], [114, 1], [115, 1]], [[0, 1]]],\r\n\t       {5: 1, 20: 1, 27: 1, 33: 1, 34: 1}],\r\n\t 293: [[[[29, 1]],\r\n\t        [[73, 2]],\r\n\t        [[74, 3]],\r\n\t        [[72, 4]],\r\n\t        [[70, 5]],\r\n\t        [[71, 6]],\r\n\t        [[116, 7], [0, 6]],\r\n\t        [[70, 8]],\r\n\t        [[71, 9]],\r\n\t        [[0, 9]]],\r\n\t       {29: 1}],\r\n\t 294: [[[[30, 1], [22, 2]], [[117, 3]], [[0, 2]], [[52, 2]]], {22: 1, 30: 1}],\r\n\t 295: [[[[118, 1]], [[46, 2], [0, 1]], [[118, 1], [0, 2]]], {22: 1, 30: 1}],\r\n\t 296: [[[[4, 1]], [[22, 2]], [[119, 3]], [[70, 4]], [[71, 5]], [[0, 5]]],\r\n\t       {4: 1}],\r\n\t 297: [[[[28, 1]], [[22, 2]], [[46, 1], [0, 2]]], {28: 1}],\r\n\t 298: [[[[32, 1]],\r\n\t        [[45, 2]],\r\n\t        [[70, 3]],\r\n\t        [[71, 4]],\r\n\t        [[116, 5], [120, 1], [0, 4]],\r\n\t        [[70, 6]],\r\n\t        [[71, 7]],\r\n\t        [[0, 7]]],\r\n\t       {32: 1}],\r\n\t 299: [[[[22, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]], {22: 1}],\r\n\t 300: [[[[121, 1]], [[46, 2], [0, 1]], [[121, 1], [0, 2]]], {22: 1}],\r\n\t 301: [[[[31, 1]],\r\n\t        [[97, 2], [102, 3]],\r\n\t        [[25, 4]],\r\n\t        [[97, 2], [25, 4], [102, 3]],\r\n\t        [[122, 5], [42, 5], [30, 6]],\r\n\t        [[0, 5]],\r\n\t        [[122, 7]],\r\n\t        [[52, 5]]],\r\n\t       {31: 1}],\r\n\t 302: [[[[25, 1]], [[123, 2]], [[0, 2]]], {25: 1}],\r\n\t 303: [[[[124, 1], [125, 1]], [[0, 1]]], {25: 1, 31: 1}],\r\n\t 304: [[[[11, 1]], [[70, 2], [126, 3]], [[45, 4]], [[70, 2]], [[0, 4]]],\r\n\t       {11: 1}],\r\n\t 305: [[[[29, 1]],\r\n\t        [[73, 2]],\r\n\t        [[74, 3]],\r\n\t        [[127, 4]],\r\n\t        [[128, 5], [0, 4]],\r\n\t        [[0, 5]]],\r\n\t       {29: 1}],\r\n\t 306: [[[[32, 1]], [[77, 2]], [[128, 3], [0, 2]], [[0, 3]]], {32: 1}],\r\n\t 307: [[[[129, 1], [130, 1]], [[0, 1]]], {29: 1, 32: 1}],\r\n\t 308: [[[[45, 1]],\r\n\t        [[129, 2], [46, 3], [0, 1]],\r\n\t        [[0, 2]],\r\n\t        [[45, 4], [0, 3]],\r\n\t        [[46, 3], [0, 4]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1}],\r\n\t 309: [[[[7, 1], [131, 2]], [[40, 2]], [[0, 2]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1}],\r\n\t 310: [[[[11, 1]], [[70, 2], [126, 3]], [[77, 4]], [[70, 2]], [[0, 4]]],\r\n\t       {11: 1}],\r\n\t 311: [[[[132, 1], [75, 1]], [[0, 1]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1}],\r\n\t 312: [[[[133, 1]], [[134, 0], [0, 1]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1}],\r\n\t 313: [[[[30, 1]], [[52, 2], [126, 3]], [[0, 2]], [[52, 2]]], {30: 1}],\r\n\t 314: [[[[24, 1]], [[0, 1]]], {24: 1}],\r\n\t 315: [[[[135, 1]], [[44, 2], [136, 1], [0, 1]], [[109, 3]], [[0, 3]]],\r\n\t       {8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 30: 1}],\r\n\t 316: [[[[12, 1]],\r\n\t        [[45, 2], [137, 3], [0, 1]],\r\n\t        [[46, 4], [0, 2]],\r\n\t        [[45, 5]],\r\n\t        [[45, 2], [0, 4]],\r\n\t        [[46, 6], [0, 5]],\r\n\t        [[45, 7]],\r\n\t        [[46, 8], [0, 7]],\r\n\t        [[45, 7], [0, 8]]],\r\n\t       {12: 1}],\r\n\t 317: [[[[5, 1]],\r\n\t        [[45, 2], [0, 1]],\r\n\t        [[46, 3], [0, 2]],\r\n\t        [[45, 4]],\r\n\t        [[46, 5], [0, 4]],\r\n\t        [[45, 6]],\r\n\t        [[0, 6]]],\r\n\t       {5: 1}],\r\n\t 318: [[[[20, 1]], [[72, 2], [0, 1]], [[0, 2]]], {20: 1}],\r\n\t 319: [[[[138, 1]], [[139, 0], [137, 0], [0, 1]]],\r\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\r\n\t 320: [[[[140, 1]], [[2, 2], [141, 3]], [[0, 2]], [[140, 1], [2, 2]]],\r\n\t       {5: 1,\r\n\t        6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        12: 1,\r\n\t        13: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        17: 1,\r\n\t        19: 1,\r\n\t        20: 1,\r\n\t        21: 1,\r\n\t        22: 1,\r\n\t        23: 1,\r\n\t        24: 1,\r\n\t        25: 1,\r\n\t        26: 1,\r\n\t        27: 1,\r\n\t        28: 1,\r\n\t        30: 1,\r\n\t        31: 1,\r\n\t        33: 1,\r\n\t        34: 1,\r\n\t        37: 1}],\r\n\t 321: [[[[70, 1]], [[45, 2], [0, 1]], [[0, 2]]], {70: 1}],\r\n\t 322: [[[[142, 1],\r\n\t         [143, 1],\r\n\t         [144, 1],\r\n\t         [145, 1],\r\n\t         [146, 1],\r\n\t         [147, 1],\r\n\t         [148, 1],\r\n\t         [149, 1],\r\n\t         [150, 1],\r\n\t         [151, 1]],\r\n\t        [[0, 1]]],\r\n\t       {5: 1,\r\n\t        6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        12: 1,\r\n\t        13: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        17: 1,\r\n\t        19: 1,\r\n\t        20: 1,\r\n\t        21: 1,\r\n\t        22: 1,\r\n\t        23: 1,\r\n\t        24: 1,\r\n\t        25: 1,\r\n\t        26: 1,\r\n\t        27: 1,\r\n\t        28: 1,\r\n\t        30: 1,\r\n\t        31: 1,\r\n\t        33: 1,\r\n\t        34: 1,\r\n\t        37: 1}],\r\n\t 323: [[[[1, 1], [3, 1]], [[0, 1]]],\r\n\t       {4: 1,\r\n\t        5: 1,\r\n\t        6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        10: 1,\r\n\t        11: 1,\r\n\t        12: 1,\r\n\t        13: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        16: 1,\r\n\t        17: 1,\r\n\t        18: 1,\r\n\t        19: 1,\r\n\t        20: 1,\r\n\t        21: 1,\r\n\t        22: 1,\r\n\t        23: 1,\r\n\t        24: 1,\r\n\t        25: 1,\r\n\t        26: 1,\r\n\t        27: 1,\r\n\t        28: 1,\r\n\t        29: 1,\r\n\t        30: 1,\r\n\t        31: 1,\r\n\t        32: 1,\r\n\t        33: 1,\r\n\t        34: 1,\r\n\t        35: 1,\r\n\t        36: 1,\r\n\t        37: 1}],\r\n\t 324: [[[[45, 1], [70, 2], [102, 3]],\r\n\t        [[70, 2], [0, 1]],\r\n\t        [[45, 4], [152, 5], [0, 2]],\r\n\t        [[102, 6]],\r\n\t        [[152, 5], [0, 4]],\r\n\t        [[0, 5]],\r\n\t        [[102, 5]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1,\r\n\t        70: 1,\r\n\t        102: 1}],\r\n\t 325: [[[[153, 1]], [[46, 2], [0, 1]], [[153, 1], [0, 2]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1,\r\n\t        70: 1,\r\n\t        102: 1}],\r\n\t 326: [[[[1, 1], [2, 2]],\r\n\t        [[0, 1]],\r\n\t        [[154, 3]],\r\n\t        [[110, 4]],\r\n\t        [[155, 1], [110, 4]]],\r\n\t       {2: 1,\r\n\t        5: 1,\r\n\t        6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        12: 1,\r\n\t        13: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        17: 1,\r\n\t        19: 1,\r\n\t        20: 1,\r\n\t        21: 1,\r\n\t        22: 1,\r\n\t        23: 1,\r\n\t        24: 1,\r\n\t        25: 1,\r\n\t        26: 1,\r\n\t        27: 1,\r\n\t        28: 1,\r\n\t        30: 1,\r\n\t        31: 1,\r\n\t        33: 1,\r\n\t        34: 1,\r\n\t        37: 1}],\r\n\t 327: [[[[109, 1]], [[156, 0], [42, 0], [157, 0], [158, 0], [0, 1]]],\r\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\r\n\t 328: [[[[75, 1], [159, 2]],\r\n\t        [[32, 3], [0, 1]],\r\n\t        [[0, 2]],\r\n\t        [[75, 4]],\r\n\t        [[116, 5]],\r\n\t        [[45, 2]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1}],\r\n\t 329: [[[[45, 1]], [[46, 2], [0, 1]], [[45, 1], [0, 2]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1}],\r\n\t 330: [[[[45, 1]], [[46, 0], [0, 1]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1}],\r\n\t 331: [[[[45, 1]],\r\n\t        [[48, 2], [46, 3], [0, 1]],\r\n\t        [[0, 2]],\r\n\t        [[45, 4], [0, 3]],\r\n\t        [[46, 3], [0, 4]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1}],\r\n\t 332: [[[[77, 1]],\r\n\t        [[46, 2], [0, 1]],\r\n\t        [[77, 3]],\r\n\t        [[46, 4], [0, 3]],\r\n\t        [[77, 3], [0, 4]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1}],\r\n\t 333: [[[[30, 1], [102, 2], [14, 3]],\r\n\t        [[52, 4], [98, 5]],\r\n\t        [[22, 4]],\r\n\t        [[160, 6]],\r\n\t        [[0, 4]],\r\n\t        [[52, 4]],\r\n\t        [[51, 4]]],\r\n\t       {14: 1, 30: 1, 102: 1}],\r\n\t 334: [[[[16, 1]],\r\n\t        [[70, 2]],\r\n\t        [[71, 3]],\r\n\t        [[161, 4], [162, 5]],\r\n\t        [[70, 6]],\r\n\t        [[70, 7]],\r\n\t        [[71, 8]],\r\n\t        [[71, 9]],\r\n\t        [[161, 4], [116, 10], [162, 5], [0, 8]],\r\n\t        [[0, 9]],\r\n\t        [[70, 11]],\r\n\t        [[71, 12]],\r\n\t        [[162, 5], [0, 12]]],\r\n\t       {16: 1}],\r\n\t 335: [[[[42, 1], [118, 2], [44, 3]],\r\n\t        [[22, 4]],\r\n\t        [[47, 5], [46, 6], [0, 2]],\r\n\t        [[22, 7]],\r\n\t        [[46, 8], [0, 4]],\r\n\t        [[45, 9]],\r\n\t        [[42, 1], [118, 2], [44, 3], [0, 6]],\r\n\t        [[0, 7]],\r\n\t        [[44, 3]],\r\n\t        [[46, 6], [0, 9]]],\r\n\t       {22: 1, 30: 1, 42: 1, 44: 1}],\r\n\t 336: [[[[18, 1]],\r\n\t        [[45, 2]],\r\n\t        [[70, 3]],\r\n\t        [[71, 4]],\r\n\t        [[116, 5], [0, 4]],\r\n\t        [[70, 6]],\r\n\t        [[71, 7]],\r\n\t        [[0, 7]]],\r\n\t       {18: 1}],\r\n\t 337: [[[[45, 1]], [[100, 2], [0, 1]], [[86, 3]], [[0, 3]]],\r\n\t       {6: 1,\r\n\t        7: 1,\r\n\t        8: 1,\r\n\t        9: 1,\r\n\t        11: 1,\r\n\t        14: 1,\r\n\t        15: 1,\r\n\t        19: 1,\r\n\t        22: 1,\r\n\t        26: 1,\r\n\t        30: 1,\r\n\t        37: 1}],\r\n\t 338: [[[[36, 1]], [[163, 2]], [[70, 3], [46, 1]], [[71, 4]], [[0, 4]]],\r\n\t       {36: 1}],\r\n\t 339: [[[[164, 1]], [[165, 0], [0, 1]]],\r\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\r\n\t 340: [[[[27, 1]], [[72, 2], [0, 1]], [[0, 2]]], {27: 1}],\r\n\t 341: [[[[53, 1]], [[0, 1]]], {27: 1}]},\r\n\tstates:\r\n\t[[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]],\r\n\t [[[38, 1]], [[39, 0], [0, 1]]],\r\n\t [[[40, 1]], [[41, 0], [0, 1]]],\r\n\t [[[42, 1], [43, 2], [44, 3]],\r\n\t  [[45, 4]],\r\n\t  [[46, 5], [0, 2]],\r\n\t  [[45, 6]],\r\n\t  [[46, 7], [0, 4]],\r\n\t  [[42, 1], [43, 2], [44, 3], [0, 5]],\r\n\t  [[0, 6]],\r\n\t  [[43, 4], [44, 3]]],\r\n\t [[[45, 1]], [[47, 2], [48, 3], [0, 1]], [[45, 3]], [[0, 3]]],\r\n\t [[[49, 1]], [[26, 0], [37, 0], [0, 1]]],\r\n\t [[[21, 1]], [[45, 2]], [[46, 3], [0, 2]], [[45, 4]], [[0, 4]]],\r\n\t [[[19, 1], [8, 2], [9, 5], [30, 4], [14, 3], [15, 6], [22, 2]],\r\n\t  [[19, 1], [0, 1]],\r\n\t  [[0, 2]],\r\n\t  [[50, 7], [51, 2]],\r\n\t  [[52, 2], [53, 8], [54, 8]],\r\n\t  [[55, 2], [56, 9]],\r\n\t  [[57, 10]],\r\n\t  [[51, 2]],\r\n\t  [[52, 2]],\r\n\t  [[55, 2]],\r\n\t  [[15, 2]]],\r\n\t [[[58, 1],\r\n\t   [59, 1],\r\n\t   [60, 1],\r\n\t   [61, 1],\r\n\t   [62, 1],\r\n\t   [63, 1],\r\n\t   [64, 1],\r\n\t   [65, 1],\r\n\t   [66, 1],\r\n\t   [67, 1],\r\n\t   [68, 1],\r\n\t   [69, 1]],\r\n\t  [[0, 1]]],\r\n\t [[[33, 1]], [[0, 1]]],\r\n\t [[[10, 1]],\r\n\t  [[22, 2]],\r\n\t  [[70, 3], [30, 4]],\r\n\t  [[71, 5]],\r\n\t  [[52, 6], [72, 7]],\r\n\t  [[0, 5]],\r\n\t  [[70, 3]],\r\n\t  [[52, 6]]],\r\n\t [[[29, 1]], [[73, 2]], [[74, 3]], [[75, 4]], [[76, 5], [0, 4]], [[0, 5]]],\r\n\t [[[32, 1]], [[77, 2]], [[76, 3], [0, 2]], [[0, 3]]],\r\n\t [[[78, 1], [48, 1]], [[0, 1]]],\r\n\t [[[79, 1],\r\n\t   [80, 1],\r\n\t   [7, 2],\r\n\t   [81, 1],\r\n\t   [79, 1],\r\n\t   [74, 1],\r\n\t   [82, 1],\r\n\t   [83, 3],\r\n\t   [84, 1],\r\n\t   [85, 1]],\r\n\t  [[0, 1]],\r\n\t  [[74, 1]],\r\n\t  [[7, 1], [0, 3]]],\r\n\t [[[86, 1]], [[87, 0], [0, 1]]],\r\n\t [[[88, 1], [89, 1], [90, 1], [91, 1], [92, 1], [93, 1], [94, 1], [95, 1]],\r\n\t  [[0, 1]]],\r\n\t [[[34, 1]], [[0, 1]]],\r\n\t [[[13, 1]], [[0, 1]]],\r\n\t [[[96, 1]], [[94, 2], [91, 2]], [[0, 2]]],\r\n\t [[[35, 1]],\r\n\t  [[97, 2]],\r\n\t  [[2, 4], [30, 3]],\r\n\t  [[52, 5], [98, 6]],\r\n\t  [[0, 4]],\r\n\t  [[2, 4]],\r\n\t  [[52, 5]]],\r\n\t [[[99, 1]], [[99, 1], [0, 1]]],\r\n\t [[[23, 1]], [[73, 2]], [[0, 2]]],\r\n\t [[[45, 1]],\r\n\t  [[70, 2], [48, 3], [46, 4], [0, 1]],\r\n\t  [[45, 5]],\r\n\t  [[0, 3]],\r\n\t  [[45, 6], [0, 4]],\r\n\t  [[48, 3], [46, 7], [0, 5]],\r\n\t  [[46, 4], [0, 6]],\r\n\t  [[45, 8], [0, 7]],\r\n\t  [[70, 9]],\r\n\t  [[45, 10]],\r\n\t  [[46, 7], [0, 10]]],\r\n\t [[[97, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]],\r\n\t [[[101, 1]], [[46, 0], [0, 1]]],\r\n\t [[[22, 1]], [[102, 0], [0, 1]]],\r\n\t [[[22, 1]], [[0, 1]]],\r\n\t [[[72, 1]], [[2, 1], [103, 2]], [[0, 2]]],\r\n\t [[[104, 1]],\r\n\t  [[45, 2], [0, 1]],\r\n\t  [[100, 3], [46, 3], [0, 2]],\r\n\t  [[45, 4]],\r\n\t  [[0, 4]]],\r\n\t [[[17, 1]],\r\n\t  [[86, 2]],\r\n\t  [[74, 3], [0, 2]],\r\n\t  [[45, 4]],\r\n\t  [[46, 5], [0, 4]],\r\n\t  [[45, 6]],\r\n\t  [[0, 6]]],\r\n\t [[[105, 1]], [[106, 0], [0, 1]]],\r\n\t [[[72, 1]],\r\n\t  [[107, 2], [47, 3], [0, 1]],\r\n\t  [[72, 4], [53, 4]],\r\n\t  [[72, 5], [53, 5]],\r\n\t  [[0, 4]],\r\n\t  [[47, 3], [0, 5]]],\r\n\t [[[86, 1]], [[46, 2], [0, 1]], [[86, 1], [0, 2]]],\r\n\t [[[37, 2], [26, 2], [6, 2], [108, 1]], [[0, 1]], [[109, 1]]],\r\n\t [[[2, 0], [103, 1], [110, 0]], [[0, 1]]],\r\n\t [[[111, 1], [112, 1], [113, 1], [114, 1], [115, 1]], [[0, 1]]],\r\n\t [[[29, 1]],\r\n\t  [[73, 2]],\r\n\t  [[74, 3]],\r\n\t  [[72, 4]],\r\n\t  [[70, 5]],\r\n\t  [[71, 6]],\r\n\t  [[116, 7], [0, 6]],\r\n\t  [[70, 8]],\r\n\t  [[71, 9]],\r\n\t  [[0, 9]]],\r\n\t [[[30, 1], [22, 2]], [[117, 3]], [[0, 2]], [[52, 2]]],\r\n\t [[[118, 1]], [[46, 2], [0, 1]], [[118, 1], [0, 2]]],\r\n\t [[[4, 1]], [[22, 2]], [[119, 3]], [[70, 4]], [[71, 5]], [[0, 5]]],\r\n\t [[[28, 1]], [[22, 2]], [[46, 1], [0, 2]]],\r\n\t [[[32, 1]],\r\n\t  [[45, 2]],\r\n\t  [[70, 3]],\r\n\t  [[71, 4]],\r\n\t  [[116, 5], [120, 1], [0, 4]],\r\n\t  [[70, 6]],\r\n\t  [[71, 7]],\r\n\t  [[0, 7]]],\r\n\t [[[22, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]],\r\n\t [[[121, 1]], [[46, 2], [0, 1]], [[121, 1], [0, 2]]],\r\n\t [[[31, 1]],\r\n\t  [[97, 2], [102, 3]],\r\n\t  [[25, 4]],\r\n\t  [[97, 2], [25, 4], [102, 3]],\r\n\t  [[122, 5], [42, 5], [30, 6]],\r\n\t  [[0, 5]],\r\n\t  [[122, 7]],\r\n\t  [[52, 5]]],\r\n\t [[[25, 1]], [[123, 2]], [[0, 2]]],\r\n\t [[[124, 1], [125, 1]], [[0, 1]]],\r\n\t [[[11, 1]], [[70, 2], [126, 3]], [[45, 4]], [[70, 2]], [[0, 4]]],\r\n\t [[[29, 1]], [[73, 2]], [[74, 3]], [[127, 4]], [[128, 5], [0, 4]], [[0, 5]]],\r\n\t [[[32, 1]], [[77, 2]], [[128, 3], [0, 2]], [[0, 3]]],\r\n\t [[[129, 1], [130, 1]], [[0, 1]]],\r\n\t [[[45, 1]],\r\n\t  [[129, 2], [46, 3], [0, 1]],\r\n\t  [[0, 2]],\r\n\t  [[45, 4], [0, 3]],\r\n\t  [[46, 3], [0, 4]]],\r\n\t [[[7, 1], [131, 2]], [[40, 2]], [[0, 2]]],\r\n\t [[[11, 1]], [[70, 2], [126, 3]], [[77, 4]], [[70, 2]], [[0, 4]]],\r\n\t [[[132, 1], [75, 1]], [[0, 1]]],\r\n\t [[[133, 1]], [[134, 0], [0, 1]]],\r\n\t [[[30, 1]], [[52, 2], [126, 3]], [[0, 2]], [[52, 2]]],\r\n\t [[[24, 1]], [[0, 1]]],\r\n\t [[[135, 1]], [[44, 2], [136, 1], [0, 1]], [[109, 3]], [[0, 3]]],\r\n\t [[[12, 1]],\r\n\t  [[45, 2], [137, 3], [0, 1]],\r\n\t  [[46, 4], [0, 2]],\r\n\t  [[45, 5]],\r\n\t  [[45, 2], [0, 4]],\r\n\t  [[46, 6], [0, 5]],\r\n\t  [[45, 7]],\r\n\t  [[46, 8], [0, 7]],\r\n\t  [[45, 7], [0, 8]]],\r\n\t [[[5, 1]],\r\n\t  [[45, 2], [0, 1]],\r\n\t  [[46, 3], [0, 2]],\r\n\t  [[45, 4]],\r\n\t  [[46, 5], [0, 4]],\r\n\t  [[45, 6]],\r\n\t  [[0, 6]]],\r\n\t [[[20, 1]], [[72, 2], [0, 1]], [[0, 2]]],\r\n\t [[[138, 1]], [[139, 0], [137, 0], [0, 1]]],\r\n\t [[[140, 1]], [[2, 2], [141, 3]], [[0, 2]], [[140, 1], [2, 2]]],\r\n\t [[[70, 1]], [[45, 2], [0, 1]], [[0, 2]]],\r\n\t [[[142, 1],\r\n\t   [143, 1],\r\n\t   [144, 1],\r\n\t   [145, 1],\r\n\t   [146, 1],\r\n\t   [147, 1],\r\n\t   [148, 1],\r\n\t   [149, 1],\r\n\t   [150, 1],\r\n\t   [151, 1]],\r\n\t  [[0, 1]]],\r\n\t [[[1, 1], [3, 1]], [[0, 1]]],\r\n\t [[[45, 1], [70, 2], [102, 3]],\r\n\t  [[70, 2], [0, 1]],\r\n\t  [[45, 4], [152, 5], [0, 2]],\r\n\t  [[102, 6]],\r\n\t  [[152, 5], [0, 4]],\r\n\t  [[0, 5]],\r\n\t  [[102, 5]]],\r\n\t [[[153, 1]], [[46, 2], [0, 1]], [[153, 1], [0, 2]]],\r\n\t [[[1, 1], [2, 2]], [[0, 1]], [[154, 3]], [[110, 4]], [[155, 1], [110, 4]]],\r\n\t [[[109, 1]], [[156, 0], [42, 0], [157, 0], [158, 0], [0, 1]]],\r\n\t [[[75, 1], [159, 2]],\r\n\t  [[32, 3], [0, 1]],\r\n\t  [[0, 2]],\r\n\t  [[75, 4]],\r\n\t  [[116, 5]],\r\n\t  [[45, 2]]],\r\n\t [[[45, 1]], [[46, 2], [0, 1]], [[45, 1], [0, 2]]],\r\n\t [[[45, 1]], [[46, 0], [0, 1]]],\r\n\t [[[45, 1]],\r\n\t  [[48, 2], [46, 3], [0, 1]],\r\n\t  [[0, 2]],\r\n\t  [[45, 4], [0, 3]],\r\n\t  [[46, 3], [0, 4]]],\r\n\t [[[77, 1]],\r\n\t  [[46, 2], [0, 1]],\r\n\t  [[77, 3]],\r\n\t  [[46, 4], [0, 3]],\r\n\t  [[77, 3], [0, 4]]],\r\n\t [[[30, 1], [102, 2], [14, 3]],\r\n\t  [[52, 4], [98, 5]],\r\n\t  [[22, 4]],\r\n\t  [[160, 6]],\r\n\t  [[0, 4]],\r\n\t  [[52, 4]],\r\n\t  [[51, 4]]],\r\n\t [[[16, 1]],\r\n\t  [[70, 2]],\r\n\t  [[71, 3]],\r\n\t  [[161, 4], [162, 5]],\r\n\t  [[70, 6]],\r\n\t  [[70, 7]],\r\n\t  [[71, 8]],\r\n\t  [[71, 9]],\r\n\t  [[161, 4], [116, 10], [162, 5], [0, 8]],\r\n\t  [[0, 9]],\r\n\t  [[70, 11]],\r\n\t  [[71, 12]],\r\n\t  [[162, 5], [0, 12]]],\r\n\t [[[42, 1], [118, 2], [44, 3]],\r\n\t  [[22, 4]],\r\n\t  [[47, 5], [46, 6], [0, 2]],\r\n\t  [[22, 7]],\r\n\t  [[46, 8], [0, 4]],\r\n\t  [[45, 9]],\r\n\t  [[42, 1], [118, 2], [44, 3], [0, 6]],\r\n\t  [[0, 7]],\r\n\t  [[44, 3]],\r\n\t  [[46, 6], [0, 9]]],\r\n\t [[[18, 1]],\r\n\t  [[45, 2]],\r\n\t  [[70, 3]],\r\n\t  [[71, 4]],\r\n\t  [[116, 5], [0, 4]],\r\n\t  [[70, 6]],\r\n\t  [[71, 7]],\r\n\t  [[0, 7]]],\r\n\t [[[45, 1]], [[100, 2], [0, 1]], [[86, 3]], [[0, 3]]],\r\n\t [[[36, 1]], [[163, 2]], [[70, 3], [46, 1]], [[71, 4]], [[0, 4]]],\r\n\t [[[164, 1]], [[165, 0], [0, 1]]],\r\n\t [[[27, 1]], [[72, 2], [0, 1]], [[0, 2]]],\r\n\t [[[53, 1]], [[0, 1]]]],\r\n\tlabels:\r\n\t[[0, 'EMPTY'],\r\n\t [320, null],\r\n\t [4, null],\r\n\t [272, null],\r\n\t [1, 'def'],\r\n\t [1, 'raise'],\r\n\t [32, null],\r\n\t [1, 'not'],\r\n\t [2, null],\r\n\t [26, null],\r\n\t [1, 'class'],\r\n\t [1, 'lambda'],\r\n\t [1, 'print'],\r\n\t [1, 'debugger'],\r\n\t [9, null],\r\n\t [25, null],\r\n\t [1, 'try'],\r\n\t [1, 'exec'],\r\n\t [1, 'while'],\r\n\t [3, null],\r\n\t [1, 'return'],\r\n\t [1, 'assert'],\r\n\t [1, null],\r\n\t [1, 'del'],\r\n\t [1, 'pass'],\r\n\t [1, 'import'],\r\n\t [15, null],\r\n\t [1, 'yield'],\r\n\t [1, 'global'],\r\n\t [1, 'for'],\r\n\t [7, null],\r\n\t [1, 'from'],\r\n\t [1, 'if'],\r\n\t [1, 'break'],\r\n\t [1, 'continue'],\r\n\t [50, null],\r\n\t [1, 'with'],\r\n\t [14, null],\r\n\t [319, null],\r\n\t [19, null],\r\n\t [309, null],\r\n\t [1, 'and'],\r\n\t [16, null],\r\n\t [260, null],\r\n\t [36, null],\r\n\t [328, null],\r\n\t [12, null],\r\n\t [22, null],\r\n\t [267, null],\r\n\t [327, null],\r\n\t [308, null],\r\n\t [10, null],\r\n\t [8, null],\r\n\t [340, null],\r\n\t [331, null],\r\n\t [27, null],\r\n\t [279, null],\r\n\t [330, null],\r\n\t [46, null],\r\n\t [39, null],\r\n\t [41, null],\r\n\t [47, null],\r\n\t [42, null],\r\n\t [43, null],\r\n\t [37, null],\r\n\t [44, null],\r\n\t [49, null],\r\n\t [45, null],\r\n\t [38, null],\r\n\t [40, null],\r\n\t [11, null],\r\n\t [326, null],\r\n\t [329, null],\r\n\t [289, null],\r\n\t [1, 'in'],\r\n\t [312, null],\r\n\t [269, null],\r\n\t [311, null],\r\n\t [268, null],\r\n\t [29, null],\r\n\t [21, null],\r\n\t [28, null],\r\n\t [30, null],\r\n\t [1, 'is'],\r\n\t [31, null],\r\n\t [20, null],\r\n\t [287, null],\r\n\t [270, null],\r\n\t [334, null],\r\n\t [298, null],\r\n\t [293, null],\r\n\t [266, null],\r\n\t [338, null],\r\n\t [336, null],\r\n\t [296, null],\r\n\t [275, null],\r\n\t [277, null],\r\n\t [282, null],\r\n\t [259, null],\r\n\t [276, null],\r\n\t [1, 'as'],\r\n\t [280, null],\r\n\t [23, null],\r\n\t [0, null],\r\n\t [1, 'except'],\r\n\t [339, null],\r\n\t [18, null],\r\n\t [264, null],\r\n\t [315, null],\r\n\t [290, null],\r\n\t [323, null],\r\n\t [265, null],\r\n\t [273, null],\r\n\t [317, null],\r\n\t [318, null],\r\n\t [341, null],\r\n\t [1, 'else'],\r\n\t [295, null],\r\n\t [294, null],\r\n\t [313, null],\r\n\t [1, 'elif'],\r\n\t [299, null],\r\n\t [300, null],\r\n\t [281, null],\r\n\t [302, null],\r\n\t [301, null],\r\n\t [335, null],\r\n\t [332, null],\r\n\t [307, null],\r\n\t [305, null],\r\n\t [306, null],\r\n\t [271, null],\r\n\t [310, null],\r\n\t [258, null],\r\n\t [1, 'or'],\r\n\t [263, null],\r\n\t [333, null],\r\n\t [35, null],\r\n\t [261, null],\r\n\t [34, null],\r\n\t [322, null],\r\n\t [13, null],\r\n\t [292, null],\r\n\t [278, null],\r\n\t [288, null],\r\n\t [314, null],\r\n\t [316, null],\r\n\t [262, null],\r\n\t [286, null],\r\n\t [297, null],\r\n\t [303, null],\r\n\t [274, null],\r\n\t [321, null],\r\n\t [324, null],\r\n\t [5, null],\r\n\t [6, null],\r\n\t [48, null],\r\n\t [17, null],\r\n\t [24, null],\r\n\t [304, null],\r\n\t [325, null],\r\n\t [285, null],\r\n\t [1, 'finally'],\r\n\t [337, null],\r\n\t [257, null],\r\n\t [33, null]],\r\n\tkeywords:\r\n\t{'and': 41,\r\n\t 'as': 100,\r\n\t 'assert': 21,\r\n\t 'break': 33,\r\n\t 'class': 10,\r\n\t 'continue': 34,\r\n\t 'debugger': 13,\r\n\t 'def': 4,\r\n\t 'del': 23,\r\n\t 'elif': 120,\r\n\t 'else': 116,\r\n\t 'except': 104,\r\n\t 'exec': 17,\r\n\t 'finally': 162,\r\n\t 'for': 29,\r\n\t 'from': 31,\r\n\t 'global': 28,\r\n\t 'if': 32,\r\n\t 'import': 25,\r\n\t 'in': 74,\r\n\t 'is': 83,\r\n\t 'lambda': 11,\r\n\t 'not': 7,\r\n\t 'or': 134,\r\n\t 'pass': 24,\r\n\t 'print': 12,\r\n\t 'raise': 5,\r\n\t 'return': 20,\r\n\t 'try': 16,\r\n\t 'while': 18,\r\n\t 'with': 36,\r\n\t 'yield': 27},\r\n\ttokens:\r\n\t{0: 103,\r\n\t 1: 22,\r\n\t 2: 8,\r\n\t 3: 19,\r\n\t 4: 2,\r\n\t 5: 154,\r\n\t 6: 155,\r\n\t 7: 30,\r\n\t 8: 52,\r\n\t 9: 14,\r\n\t 10: 51,\r\n\t 11: 70,\r\n\t 12: 46,\r\n\t 13: 141,\r\n\t 14: 37,\r\n\t 15: 26,\r\n\t 16: 42,\r\n\t 17: 157,\r\n\t 18: 106,\r\n\t 19: 39,\r\n\t 20: 85,\r\n\t 21: 80,\r\n\t 22: 47,\r\n\t 23: 102,\r\n\t 24: 158,\r\n\t 25: 15,\r\n\t 26: 9,\r\n\t 27: 55,\r\n\t 28: 81,\r\n\t 29: 79,\r\n\t 30: 82,\r\n\t 31: 84,\r\n\t 32: 6,\r\n\t 33: 165,\r\n\t 34: 139,\r\n\t 35: 137,\r\n\t 36: 44,\r\n\t 37: 64,\r\n\t 38: 68,\r\n\t 39: 59,\r\n\t 40: 69,\r\n\t 41: 60,\r\n\t 42: 62,\r\n\t 43: 63,\r\n\t 44: 65,\r\n\t 45: 67,\r\n\t 46: 58,\r\n\t 47: 61,\r\n\t 48: 156,\r\n\t 49: 66,\r\n\t 50: 35},\r\n\tstart: 256\r\n\t};\r\n\r\n\r\n\r\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/parser.js ---- */ \r\n\r\n\t// low level parser to a concrete syntax tree, derived from cpython's lib2to3\r\n\r\n\t/**\r\n\t *\r\n\t * @constructor\r\n\t * @param {Object} grammar\r\n\t *\r\n\t * p = new Parser(grammar);\r\n\t * p.setup([start]);\r\n\t * foreach input token:\r\n\t *     if p.addtoken(...):\r\n\t *         break\r\n\t * root = p.rootnode\r\n\t *\r\n\t * can throw SyntaxError\r\n\t */\r\n\tfunction Parser (filename, grammar) {\r\n\t    this.filename = filename;\r\n\t    this.grammar = grammar;\r\n\t    this.p_flags = 0;\r\n\t    return this;\r\n\t}\r\n\r\n\t// all possible parser flags\r\n\tParser.FUTURE_PRINT_FUNCTION = \"print_function\";\r\n\tParser.FUTURE_UNICODE_LITERALS = \"unicode_literals\";\r\n\tParser.FUTURE_DIVISION = \"division\";\r\n\tParser.FUTURE_ABSOLUTE_IMPORT = \"absolute_import\";\r\n\tParser.FUTURE_WITH_STATEMENT = \"with_statement\";\r\n\tParser.FUTURE_NESTED_SCOPES = \"nested_scopes\";\r\n\tParser.FUTURE_GENERATORS = \"generators\";\r\n\tParser.CO_FUTURE_PRINT_FUNCTION = 0x10000;\r\n\tParser.CO_FUTURE_UNICODE_LITERALS = 0x20000;\r\n\tParser.CO_FUTURE_DIVISON = 0x2000;\r\n\tParser.CO_FUTURE_ABSOLUTE_IMPORT = 0x4000;\r\n\tParser.CO_FUTURE_WITH_STATEMENT = 0x8000;\r\n\r\n\tParser.prototype.setup = function (start) {\r\n\t    var stackentry;\r\n\t    var newnode;\r\n\t    start = start || this.grammar.start;\r\n\t    //print(\"START:\"+start);\r\n\r\n\t    newnode =\r\n\t    {\r\n\t        type    : start,\r\n\t        value   : null,\r\n\t        context : null,\r\n\t        children: []\r\n\t    };\r\n\t    stackentry =\r\n\t    {\r\n\t        dfa  : this.grammar.dfas[start],\r\n\t        state: 0,\r\n\t        node : newnode\r\n\t    };\r\n\t    this.stack = [stackentry];\r\n\t    this.used_names = {};\r\n\t};\r\n\r\n\tfunction findInDfa (a, obj) {\r\n\t    var i = a.length;\r\n\t    while (i--) {\r\n\t        if (a[i][0] === obj[0] && a[i][1] === obj[1]) {\r\n\t            return true;\r\n\t        }\r\n\t    }\r\n\t    return false;\r\n\t}\r\n\r\n\r\n\t// Add a token; return true if we're done\r\n\tParser.prototype.addtoken = function (type, value, context) {\r\n\t    var errline;\r\n\t    var itsfirst;\r\n\t    var itsdfa;\r\n\t    var state;\r\n\t    var v;\r\n\t    var t;\r\n\t    var newstate;\r\n\t    var i;\r\n\t    var a;\r\n\t    var arcs;\r\n\t    var first;\r\n\t    var states;\r\n\t    var tp;\r\n\t    var ilabel = this.classify(type, value, context);\r\n\t    //print(\"ilabel:\"+ilabel);\r\n\r\n\t    OUTERWHILE:\r\n\t    while (true) {\r\n\t        tp = this.stack[this.stack.length - 1];\r\n\t        states = tp.dfa[0];\r\n\t        first = tp.dfa[1];\r\n\t        arcs = states[tp.state];\r\n\r\n\t        // look for a state with this label\r\n\t        for (a = 0; a < arcs.length; ++a) {\r\n\t            i = arcs[a][0];\r\n\t            newstate = arcs[a][1];\r\n\t            t = this.grammar.labels[i][0];\r\n\t            v = this.grammar.labels[i][1];\r\n\t            if (ilabel === i) {\r\n\t                // look it up in the list of labels\r\n\t                goog.asserts.assert(t < 256);\r\n\t                // shift a token; we're done with it\r\n\t                this.shift(type, value, newstate, context);\r\n\t                // pop while we are in an accept-only state\r\n\t                state = newstate;\r\n\t                //print(\"before:\"+JSON.stringify(states[state]) + \":state:\"+state+\":\"+JSON.stringify(states[state]));\r\n\t                /* jshint ignore:start */\r\n\t                while (states[state].length === 1\r\n\t                    && states[state][0][0] === 0\r\n\t                    && states[state][0][1] === state) {\r\n\t                    // states[state] == [(0, state)])\r\n\t                    this.pop();\r\n\t                    //print(\"in after pop:\"+JSON.stringify(states[state]) + \":state:\"+state+\":\"+JSON.stringify(states[state]));\r\n\t                    if (this.stack.length === 0) {\r\n\t                        // done!\r\n\t                        return true;\r\n\t                    }\r\n\t                    tp = this.stack[this.stack.length - 1];\r\n\t                    state = tp.state;\r\n\t                    states = tp.dfa[0];\r\n\t                    first = tp.dfa[1];\r\n\t                    //print(JSON.stringify(states), JSON.stringify(first));\r\n\t                    //print(\"bottom:\"+JSON.stringify(states[state]) + \":state:\"+state+\":\"+JSON.stringify(states[state]));\r\n\t                }\r\n\t                /* jshint ignore:end */\r\n\t                // done with this token\r\n\t                //print(\"DONE, return false\");\r\n\t                return false;\r\n\t            } else if (t >= 256) {\r\n\t                itsdfa = this.grammar.dfas[t];\r\n\t                itsfirst = itsdfa[1];\r\n\t                if (itsfirst.hasOwnProperty(ilabel)) {\r\n\t                    // push a symbol\r\n\t                    this.push(t, this.grammar.dfas[t], newstate, context);\r\n\t                    continue OUTERWHILE;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        //print(\"findInDfa: \" + JSON.stringify(arcs)+\" vs. \" + tp.state);\r\n\t        if (findInDfa(arcs, [0, tp.state])) {\r\n\t            // an accepting state, pop it and try somethign else\r\n\t            //print(\"WAA\");\r\n\t            this.pop();\r\n\t            if (this.stack.length === 0) {\r\n\t                throw new Sk.builtin.SyntaxError(\"too much input\", this.filename);\r\n\t            }\r\n\t        } else {\r\n\t            // no transition\r\n\t            errline = context[0][0];\r\n\r\n\t            var that = this;\r\n\t            var ar = arcs.map(function(a) {\r\n\t                var i = a[0];\r\n\t                var t = that.grammar.labels[i][0];\r\n\t                return Sk.nameForToken(t);\r\n\t            });\r\n\t            var extra = {\r\n\t                kind: \"DAG_MISS\",\r\n\t                expected: ar,\r\n\t                found: Sk.nameForToken(type),\r\n\t                found_val: value,\r\n\t                inside: Sk.nameForToken(tp.node.type),\r\n\t                node: tp.node,\r\n\t                parent: this.stack.length > 1 ? this.stack[this.stack.length - 2].node : undefined\r\n\t            };\r\n\t            var reason = \"expected \" + ar.join(', ') + \" but found \" + extra.found + \" while parsing \" + extra.inside;\r\n\r\n\t            throw new Sk.builtin.SyntaxError(reason, this.filename, errline, context, extra);\r\n\t        }\r\n\t    }\r\n\t};\r\n\r\n\t// turn a token into a label\r\n\tParser.prototype.classify = function (type, value, context) {\r\n\t    var ilabel;\r\n\t    if (type === Sk.Tokenizer.Tokens.T_NAME) {\r\n\t        this.used_names[value] = true;\r\n\t        ilabel = this.grammar.keywords.hasOwnProperty(value) && this.grammar.keywords[value];\r\n\r\n\t        /* Check for handling print as an builtin function */\r\n\t        if(value === \"print\" && (this.p_flags & Parser.CO_FUTURE_PRINT_FUNCTION || Sk.python3 === true)) {\r\n\t            ilabel = false; // ilabel determines if the value is a keyword\r\n\t        }\r\n\r\n\t        if (ilabel) {\r\n\t            //print(\"is keyword\");\r\n\t            return ilabel;\r\n\t        }\r\n\t    }\r\n\t    ilabel = this.grammar.tokens.hasOwnProperty(type) && this.grammar.tokens[type];\r\n\t    if (!ilabel) {\r\n\t        // throw new Sk.builtin.SyntaxError(\"bad token\", type, value, context);\r\n\t        // Questionable modification to put line number in position 2\r\n\t        // like everywhere else and filename in position 1.\r\n\t        var extra = {\r\n\t            kind: \"CLASSIFY\",\r\n\t            type: type,\r\n\t            value: value\r\n\t        };\r\n\t        throw new Sk.builtin.SyntaxError(\"bad token\", this.filename, context[0][0], context, extra);\r\n\t    }\r\n\t    return ilabel;\r\n\t};\r\n\r\n\t// shift a token\r\n\tParser.prototype.shift = function (type, value, newstate, context) {\r\n\t    var dfa = this.stack[this.stack.length - 1].dfa;\r\n\t    var state = this.stack[this.stack.length - 1].state;\r\n\t    var node = this.stack[this.stack.length - 1].node;\r\n\t    //print(\"context\", context);\r\n\t    var newnode = {\r\n\t        type      : type,\r\n\t        value     : value,\r\n\t        lineno    : context[0][0],         // throwing away end here to match cpython\r\n\t        col_offset: context[0][1],\r\n\t        children  : null\r\n\t    };\r\n\t    if (newnode) {\r\n\t        node.children.push(newnode);\r\n\t    }\r\n\t    this.stack[this.stack.length - 1] = {\r\n\t        dfa  : dfa,\r\n\t        state: newstate,\r\n\t        node : node\r\n\t    };\r\n\t};\r\n\r\n\t// push a nonterminal\r\n\tParser.prototype.push = function (type, newdfa, newstate, context) {\r\n\t    var dfa = this.stack[this.stack.length - 1].dfa;\r\n\t    var node = this.stack[this.stack.length - 1].node;\r\n\t    var newnode = {\r\n\t        type      : type,\r\n\t        value     : null,\r\n\t        lineno    : context[0][0],      // throwing away end here to match cpython\r\n\t        col_offset: context[0][1],\r\n\t        children  : []\r\n\t    };\r\n\t    this.stack[this.stack.length - 1] = {\r\n\t        dfa  : dfa,\r\n\t        state: newstate,\r\n\t        node : node\r\n\t    };\r\n\t    this.stack.push({\r\n\t        dfa  : newdfa,\r\n\t        state: 0,\r\n\t        node : newnode\r\n\t    });\r\n\t};\r\n\r\n\t//var ac = 0;\r\n\t//var bc = 0;\r\n\r\n\t// pop a nonterminal\r\n\tParser.prototype.pop = function () {\r\n\t    var node;\r\n\t    var pop = this.stack.pop();\r\n\t    var newnode = pop.node;\r\n\t    //print(\"POP\");\r\n\t    if (newnode) {\r\n\t        //print(\"A\", ac++, newnode.type);\r\n\t        //print(\"stacklen:\"+this.stack.length);\r\n\t        if (this.stack.length !== 0) {\r\n\t            //print(\"B\", bc++);\r\n\t            node = this.stack[this.stack.length - 1].node;\r\n\t            node.children.push(newnode);\r\n\t        } else {\r\n\t            //print(\"C\");\r\n\t            this.rootnode = newnode;\r\n\t            this.rootnode.used_names = this.used_names;\r\n\t        }\r\n\t    }\r\n\t};\r\n\r\n\t/**\r\n\t * parser for interactive input. returns a function that should be called with\r\n\t * lines of input as they are entered. the function will return false\r\n\t * until the input is complete, when it will return the rootnode of the parse.\r\n\t *\r\n\t * @param {string} filename\r\n\t * @param {string=} style root of parse tree (optional)\r\n\t */\r\n\tfunction makeParser (filename, style) {\r\n\t    var tokenizer;\r\n\t    var T_OP;\r\n\t    var T_NL;\r\n\t    var T_COMMENT;\r\n\t    var prefix;\r\n\t    var column;\r\n\t    var lineno;\r\n\t    var p;\r\n\t    if (style === undefined) {\r\n\t        style = \"file_input\";\r\n\t    }\r\n\t    p = new Parser(filename, Sk.ParseTables);\r\n\t    // for closure's benefit\r\n\t    if (style === \"file_input\") {\r\n\t        p.setup(Sk.ParseTables.sym.file_input);\r\n\t    } else {\r\n\t        goog.asserts.fail(\"todo;\");\r\n\t    }\r\n\t    lineno = 1;\r\n\t    column = 0;\r\n\t    prefix = \"\";\r\n\t    T_COMMENT = Sk.Tokenizer.Tokens.T_COMMENT;\r\n\t    T_NL = Sk.Tokenizer.Tokens.T_NL;\r\n\t    T_OP = Sk.Tokenizer.Tokens.T_OP;\r\n\t    tokenizer = new Sk.Tokenizer(filename, style === \"single_input\", function (type, value, start, end, line) {\r\n\t        var s_lineno = start[0];\r\n\t        var s_column = start[1];\r\n\t        /*\r\n\t         if (s_lineno !== lineno && s_column !== column)\r\n\t         {\r\n\t         // todo; update prefix and line/col\r\n\t         }\r\n\t         */\r\n\t        if (type === T_COMMENT || type === T_NL) {\r\n\t            prefix += value;\r\n\t            lineno = end[0];\r\n\t            column = end[1];\r\n\t            if (value[value.length - 1] === \"\\n\") {\r\n\t                lineno += 1;\r\n\t                column = 0;\r\n\t            }\r\n\t            //print(\"  not calling addtoken\");\r\n\t            return undefined;\r\n\t        }\r\n\t        if (type === T_OP) {\r\n\t            type = Sk.OpMap[value];\r\n\t        }\r\n\t        if (p.addtoken(type, value, [start, end, line])) {\r\n\t            return true;\r\n\t        }\r\n\t    });\r\n\r\n\t    // create parser function\r\n\t    var parseFunc = function (line) {\r\n\t        var ret = tokenizer.generateTokens(line);\r\n\t        //print(\"tok:\"+ret);\r\n\t        if (ret) {\r\n\t            if (ret !== \"done\") {\r\n\t                throw new Sk.builtin.SyntaxError(\"incomplete input\", this.filename);\r\n\t            }\r\n\t            return p.rootnode;\r\n\t        }\r\n\t        return false;\r\n\t    };\r\n\r\n\t    // set flags, and return\r\n\t    parseFunc.p_flags = p.p_flags;\r\n\t    return parseFunc;\r\n\t}\r\n\r\n\tSk.parse = function parse (filename, input) {\r\n\t    var i;\r\n\t    var ret;\r\n\t    var lines;\r\n\t    var parseFunc = makeParser(filename);\r\n\t    if (input.substr(input.length - 1, 1) !== \"\\n\") {\r\n\t        input += \"\\n\";\r\n\t    }\r\n\t    //print(\"input:\"+input);\r\n\t    lines = input.split(\"\\n\");\r\n\t    for (i = 0; i < lines.length; ++i) {\r\n\t        ret = parseFunc(lines[i] + ((i === lines.length - 1) ? \"\" : \"\\n\"));\r\n\t    }\r\n\r\n\t    /*\r\n\t     * Small adjustments here in order to return th flags and the cst\r\n\t     */\r\n\t    return {\"cst\": ret, \"flags\": parseFunc.p_flags};\r\n\t};\r\n\r\n\tSk.parseTreeDump = function parseTreeDump (n, indent) {\r\n\t    //return JSON.stringify(n, null, 2);\r\n\t    var i;\r\n\t    var ret;\r\n\t    indent = indent || \"\";\r\n\t    ret = \"\";\r\n\t    ret += indent;\r\n\t    if (n.type >= 256) { // non-term\r\n\t        ret += Sk.ParseTables.number2symbol[n.type] + \"\\n\";\r\n\t        for (i = 0; i < n.children.length; ++i) {\r\n\t            ret += Sk.parseTreeDump(n.children[i], indent + \"  \");\r\n\t        }\r\n\t    } else {\r\n\t        ret += Sk.Tokenizer.tokenNames[n.type] + \": \" + new Sk.builtin.str(n.value)[\"$r\"]().v + \"\\n\";\r\n\t    }\r\n\t    return ret;\r\n\t};\r\n\r\n\r\n\tgoog.exportSymbol(\"Sk.parse\", Sk.parse);\r\n\tgoog.exportSymbol(\"Sk.parseTreeDump\", Sk.parseTreeDump);\r\n\r\n\r\n\r\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/gen/astnodes.js ---- */ \r\n\r\n\t/* File automatically generated by ./asdl_js.py. */\r\n\r\n\t/* ----- expr_context ----- */\r\n\t/** @constructor */\r\n\tfunction Load() {}\r\n\t/** @constructor */\r\n\tfunction Store() {}\r\n\t/** @constructor */\r\n\tfunction Del() {}\r\n\t/** @constructor */\r\n\tfunction AugLoad() {}\r\n\t/** @constructor */\r\n\tfunction AugStore() {}\r\n\t/** @constructor */\r\n\tfunction Param() {}\r\n\r\n\t/* ----- boolop ----- */\r\n\t/** @constructor */\r\n\tfunction And() {}\r\n\t/** @constructor */\r\n\tfunction Or() {}\r\n\r\n\t/* ----- operator ----- */\r\n\t/** @constructor */\r\n\tfunction Add() {}\r\n\t/** @constructor */\r\n\tfunction Sub() {}\r\n\t/** @constructor */\r\n\tfunction Mult() {}\r\n\t/** @constructor */\r\n\tfunction Div() {}\r\n\t/** @constructor */\r\n\tfunction Mod() {}\r\n\t/** @constructor */\r\n\tfunction Pow() {}\r\n\t/** @constructor */\r\n\tfunction LShift() {}\r\n\t/** @constructor */\r\n\tfunction RShift() {}\r\n\t/** @constructor */\r\n\tfunction BitOr() {}\r\n\t/** @constructor */\r\n\tfunction BitXor() {}\r\n\t/** @constructor */\r\n\tfunction BitAnd() {}\r\n\t/** @constructor */\r\n\tfunction FloorDiv() {}\r\n\r\n\t/* ----- unaryop ----- */\r\n\t/** @constructor */\r\n\tfunction Invert() {}\r\n\t/** @constructor */\r\n\tfunction Not() {}\r\n\t/** @constructor */\r\n\tfunction UAdd() {}\r\n\t/** @constructor */\r\n\tfunction USub() {}\r\n\r\n\t/* ----- cmpop ----- */\r\n\t/** @constructor */\r\n\tfunction Eq() {}\r\n\t/** @constructor */\r\n\tfunction NotEq() {}\r\n\t/** @constructor */\r\n\tfunction Lt() {}\r\n\t/** @constructor */\r\n\tfunction LtE() {}\r\n\t/** @constructor */\r\n\tfunction Gt() {}\r\n\t/** @constructor */\r\n\tfunction GtE() {}\r\n\t/** @constructor */\r\n\tfunction Is() {}\r\n\t/** @constructor */\r\n\tfunction IsNot() {}\r\n\t/** @constructor */\r\n\tfunction In_() {}\r\n\t/** @constructor */\r\n\tfunction NotIn() {}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t/* ---------------------- */\r\n\t/* constructors for nodes */\r\n\t/* ---------------------- */\r\n\r\n\r\n\r\n\r\n\r\n\t/** @constructor */\r\n\tfunction Module(/* {asdl_seq *} */ body)\r\n\t{\r\n\t    this.body = body;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Interactive(/* {asdl_seq *} */ body)\r\n\t{\r\n\t    this.body = body;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Expression(/* {expr_ty} */ body)\r\n\t{\r\n\t    goog.asserts.assert(body !== null && body !== undefined);\r\n\t    this.body = body;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Suite(/* {asdl_seq *} */ body)\r\n\t{\r\n\t    this.body = body;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction FunctionDef(/* {identifier} */ name, /* {arguments__ty} */ args, /*\r\n\t                          {asdl_seq *} */ body, /* {asdl_seq *} */\r\n\t                          decorator_list, /* {int} */ lineno, /* {int} */\r\n\t                          col_offset)\r\n\t{\r\n\t    goog.asserts.assert(name !== null && name !== undefined);\r\n\t    goog.asserts.assert(args !== null && args !== undefined);\r\n\t    this.name = name;\r\n\t    this.args = args;\r\n\t    this.body = body;\r\n\t    this.decorator_list = decorator_list;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction ClassDef(/* {identifier} */ name, /* {asdl_seq *} */ bases, /*\r\n\t                       {asdl_seq *} */ body, /* {asdl_seq *} */ decorator_list,\r\n\t                       /* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(name !== null && name !== undefined);\r\n\t    this.name = name;\r\n\t    this.bases = bases;\r\n\t    this.body = body;\r\n\t    this.decorator_list = decorator_list;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Return_(/* {expr_ty} */ value, /* {int} */ lineno, /* {int} */\r\n\t                      col_offset)\r\n\t{\r\n\t    this.value = value;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Delete_(/* {asdl_seq *} */ targets, /* {int} */ lineno, /* {int} */\r\n\t                      col_offset)\r\n\t{\r\n\t    this.targets = targets;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Assign(/* {asdl_seq *} */ targets, /* {expr_ty} */ value, /* {int} */\r\n\t                     lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(value !== null && value !== undefined);\r\n\t    this.targets = targets;\r\n\t    this.value = value;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction AugAssign(/* {expr_ty} */ target, /* {operator_ty} */ op, /* {expr_ty}\r\n\t                        */ value, /* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(target !== null && target !== undefined);\r\n\t    goog.asserts.assert(op !== null && op !== undefined);\r\n\t    goog.asserts.assert(value !== null && value !== undefined);\r\n\t    this.target = target;\r\n\t    this.op = op;\r\n\t    this.value = value;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Print(/* {expr_ty} */ dest, /* {asdl_seq *} */ values, /* {bool} */\r\n\t                    nl, /* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    this.dest = dest;\r\n\t    this.values = values;\r\n\t    this.nl = nl;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction For_(/* {expr_ty} */ target, /* {expr_ty} */ iter, /* {asdl_seq *} */\r\n\t                   body, /* {asdl_seq *} */ orelse, /* {int} */ lineno, /*\r\n\t                   {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(target !== null && target !== undefined);\r\n\t    goog.asserts.assert(iter !== null && iter !== undefined);\r\n\t    this.target = target;\r\n\t    this.iter = iter;\r\n\t    this.body = body;\r\n\t    this.orelse = orelse;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction While_(/* {expr_ty} */ test, /* {asdl_seq *} */ body, /* {asdl_seq *}\r\n\t                     */ orelse, /* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(test !== null && test !== undefined);\r\n\t    this.test = test;\r\n\t    this.body = body;\r\n\t    this.orelse = orelse;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction If_(/* {expr_ty} */ test, /* {asdl_seq *} */ body, /* {asdl_seq *} */\r\n\t                  orelse, /* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(test !== null && test !== undefined);\r\n\t    this.test = test;\r\n\t    this.body = body;\r\n\t    this.orelse = orelse;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction With_(/* {expr_ty} */ context_expr, /* {expr_ty} */ optional_vars, /*\r\n\t                    {asdl_seq *} */ body, /* {int} */ lineno, /* {int} */\r\n\t                    col_offset)\r\n\t{\r\n\t    goog.asserts.assert(context_expr !== null && context_expr !== undefined);\r\n\t    this.context_expr = context_expr;\r\n\t    this.optional_vars = optional_vars;\r\n\t    this.body = body;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Raise(/* {expr_ty} */ type, /* {expr_ty} */ inst, /* {expr_ty} */\r\n\t                    tback, /* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    this.type = type;\r\n\t    this.inst = inst;\r\n\t    this.tback = tback;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction TryExcept(/* {asdl_seq *} */ body, /* {asdl_seq *} */ handlers, /*\r\n\t                        {asdl_seq *} */ orelse, /* {int} */ lineno, /* {int} */\r\n\t                        col_offset)\r\n\t{\r\n\t    this.body = body;\r\n\t    this.handlers = handlers;\r\n\t    this.orelse = orelse;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction TryFinally(/* {asdl_seq *} */ body, /* {asdl_seq *} */ finalbody, /*\r\n\t                         {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    this.body = body;\r\n\t    this.finalbody = finalbody;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Assert(/* {expr_ty} */ test, /* {expr_ty} */ msg, /* {int} */ lineno,\r\n\t                     /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(test !== null && test !== undefined);\r\n\t    this.test = test;\r\n\t    this.msg = msg;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Import_(/* {asdl_seq *} */ names, /* {int} */ lineno, /* {int} */\r\n\t                      col_offset)\r\n\t{\r\n\t    this.names = names;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction ImportFrom(/* {identifier} */ module, /* {asdl_seq *} */ names, /*\r\n\t                         {int} */ level, /* {int} */ lineno, /* {int} */\r\n\t                         col_offset)\r\n\t{\r\n\t    goog.asserts.assert(module !== null && module !== undefined);\r\n\t    this.module = module;\r\n\t    this.names = names;\r\n\t    this.level = level;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Exec(/* {expr_ty} */ body, /* {expr_ty} */ globals, /* {expr_ty} */\r\n\t                   locals, /* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(body !== null && body !== undefined);\r\n\t    this.body = body;\r\n\t    this.globals = globals;\r\n\t    this.locals = locals;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Global(/* {asdl_seq *} */ names, /* {int} */ lineno, /* {int} */\r\n\t                     col_offset)\r\n\t{\r\n\t    this.names = names;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Expr(/* {expr_ty} */ value, /* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(value !== null && value !== undefined);\r\n\t    this.value = value;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Pass(/* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Break_(/* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Continue_(/* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Debugger_(/* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction BoolOp(/* {boolop_ty} */ op, /* {asdl_seq *} */ values, /* {int} */\r\n\t                     lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(op !== null && op !== undefined);\r\n\t    this.op = op;\r\n\t    this.values = values;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction BinOp(/* {expr_ty} */ left, /* {operator_ty} */ op, /* {expr_ty} */\r\n\t                    right, /* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(left !== null && left !== undefined);\r\n\t    goog.asserts.assert(op !== null && op !== undefined);\r\n\t    goog.asserts.assert(right !== null && right !== undefined);\r\n\t    this.left = left;\r\n\t    this.op = op;\r\n\t    this.right = right;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction UnaryOp(/* {unaryop_ty} */ op, /* {expr_ty} */ operand, /* {int} */\r\n\t                      lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(op !== null && op !== undefined);\r\n\t    goog.asserts.assert(operand !== null && operand !== undefined);\r\n\t    this.op = op;\r\n\t    this.operand = operand;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Lambda(/* {arguments__ty} */ args, /* {expr_ty} */ body, /* {int} */\r\n\t                     lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(args !== null && args !== undefined);\r\n\t    goog.asserts.assert(body !== null && body !== undefined);\r\n\t    this.args = args;\r\n\t    this.body = body;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction IfExp(/* {expr_ty} */ test, /* {expr_ty} */ body, /* {expr_ty} */\r\n\t                    orelse, /* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(test !== null && test !== undefined);\r\n\t    goog.asserts.assert(body !== null && body !== undefined);\r\n\t    goog.asserts.assert(orelse !== null && orelse !== undefined);\r\n\t    this.test = test;\r\n\t    this.body = body;\r\n\t    this.orelse = orelse;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Dict(/* {asdl_seq *} */ keys, /* {asdl_seq *} */ values, /* {int} */\r\n\t                   lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    this.keys = keys;\r\n\t    this.values = values;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Set(/* {asdl_seq *} */ elts, /* {int} */ lineno, /* {int} */\r\n\t                  col_offset)\r\n\t{\r\n\t    this.elts = elts;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction ListComp(/* {expr_ty} */ elt, /* {asdl_seq *} */ generators, /* {int}\r\n\t                       */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(elt !== null && elt !== undefined);\r\n\t    this.elt = elt;\r\n\t    this.generators = generators;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction SetComp(/* {expr_ty} */ elt, /* {asdl_seq *} */ generators, /* {int}\r\n\t                      */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(elt !== null && elt !== undefined);\r\n\t    this.elt = elt;\r\n\t    this.generators = generators;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction DictComp(/* {expr_ty} */ key, /* {expr_ty} */ value, /* {asdl_seq *}\r\n\t                       */ generators, /* {int} */ lineno, /* {int} */\r\n\t                       col_offset)\r\n\t{\r\n\t    goog.asserts.assert(key !== null && key !== undefined);\r\n\t    goog.asserts.assert(value !== null && value !== undefined);\r\n\t    this.key = key;\r\n\t    this.value = value;\r\n\t    this.generators = generators;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction GeneratorExp(/* {expr_ty} */ elt, /* {asdl_seq *} */ generators, /*\r\n\t                           {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(elt !== null && elt !== undefined);\r\n\t    this.elt = elt;\r\n\t    this.generators = generators;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Yield(/* {expr_ty} */ value, /* {int} */ lineno, /* {int} */\r\n\t                    col_offset)\r\n\t{\r\n\t    this.value = value;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Compare(/* {expr_ty} */ left, /* {asdl_int_seq *} */ ops, /* {asdl_seq\r\n\t                      *} */ comparators, /* {int} */ lineno, /* {int} */\r\n\t                      col_offset)\r\n\t{\r\n\t    goog.asserts.assert(left !== null && left !== undefined);\r\n\t    this.left = left;\r\n\t    this.ops = ops;\r\n\t    this.comparators = comparators;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Call(/* {expr_ty} */ func, /* {asdl_seq *} */ args, /* {asdl_seq *} */\r\n\t                   keywords, /* {expr_ty} */ starargs, /* {expr_ty} */ kwargs,\r\n\t                   /* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(func !== null && func !== undefined);\r\n\t    this.func = func;\r\n\t    this.args = args;\r\n\t    this.keywords = keywords;\r\n\t    this.starargs = starargs;\r\n\t    this.kwargs = kwargs;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Repr(/* {expr_ty} */ value, /* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(value !== null && value !== undefined);\r\n\t    this.value = value;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Num(/* {object} */ n, /* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(n !== null && n !== undefined);\r\n\t    this.n = n;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Str(/* {string} */ s, /* {int} */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(s !== null && s !== undefined);\r\n\t    this.s = s;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Attribute(/* {expr_ty} */ value, /* {identifier} */ attr, /*\r\n\t                        {expr_context_ty} */ ctx, /* {int} */ lineno, /* {int}\r\n\t                        */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(value !== null && value !== undefined);\r\n\t    goog.asserts.assert(attr !== null && attr !== undefined);\r\n\t    goog.asserts.assert(ctx !== null && ctx !== undefined);\r\n\t    this.value = value;\r\n\t    this.attr = attr;\r\n\t    this.ctx = ctx;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Subscript(/* {expr_ty} */ value, /* {slice_ty} */ slice, /*\r\n\t                        {expr_context_ty} */ ctx, /* {int} */ lineno, /* {int}\r\n\t                        */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(value !== null && value !== undefined);\r\n\t    goog.asserts.assert(slice !== null && slice !== undefined);\r\n\t    goog.asserts.assert(ctx !== null && ctx !== undefined);\r\n\t    this.value = value;\r\n\t    this.slice = slice;\r\n\t    this.ctx = ctx;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Name(/* {identifier} */ id, /* {expr_context_ty} */ ctx, /* {int} */\r\n\t                   lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(id !== null && id !== undefined);\r\n\t    goog.asserts.assert(ctx !== null && ctx !== undefined);\r\n\t    this.id = id;\r\n\t    this.ctx = ctx;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction List(/* {asdl_seq *} */ elts, /* {expr_context_ty} */ ctx, /* {int} */\r\n\t                   lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(ctx !== null && ctx !== undefined);\r\n\t    this.elts = elts;\r\n\t    this.ctx = ctx;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Tuple(/* {asdl_seq *} */ elts, /* {expr_context_ty} */ ctx, /* {int}\r\n\t                    */ lineno, /* {int} */ col_offset)\r\n\t{\r\n\t    goog.asserts.assert(ctx !== null && ctx !== undefined);\r\n\t    this.elts = elts;\r\n\t    this.ctx = ctx;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Ellipsis()\r\n\t{\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Slice(/* {expr_ty} */ lower, /* {expr_ty} */ upper, /* {expr_ty} */\r\n\t                    step)\r\n\t{\r\n\t    this.lower = lower;\r\n\t    this.upper = upper;\r\n\t    this.step = step;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction ExtSlice(/* {asdl_seq *} */ dims)\r\n\t{\r\n\t    this.dims = dims;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction Index(/* {expr_ty} */ value)\r\n\t{\r\n\t    goog.asserts.assert(value !== null && value !== undefined);\r\n\t    this.value = value;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction comprehension(/* {expr_ty} */ target, /* {expr_ty} */ iter, /*\r\n\t                            {asdl_seq *} */ ifs)\r\n\t{\r\n\t    goog.asserts.assert(target !== null && target !== undefined);\r\n\t    goog.asserts.assert(iter !== null && iter !== undefined);\r\n\t    this.target = target;\r\n\t    this.iter = iter;\r\n\t    this.ifs = ifs;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction ExceptHandler(/* {expr_ty} */ type, /* {expr_ty} */ name, /* {asdl_seq\r\n\t                            *} */ body, /* {int} */ lineno, /* {int} */\r\n\t                            col_offset)\r\n\t{\r\n\t    this.type = type;\r\n\t    this.name = name;\r\n\t    this.body = body;\r\n\t    this.lineno = lineno;\r\n\t    this.col_offset = col_offset;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction arguments_(/* {asdl_seq *} */ args, /* {identifier} */ vararg, /*\r\n\t                         {identifier} */ kwarg, /* {asdl_seq *} */ defaults)\r\n\t{\r\n\t    this.args = args;\r\n\t    this.vararg = vararg;\r\n\t    this.kwarg = kwarg;\r\n\t    this.defaults = defaults;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction keyword(/* {identifier} */ arg, /* {expr_ty} */ value)\r\n\t{\r\n\t    goog.asserts.assert(arg !== null && arg !== undefined);\r\n\t    goog.asserts.assert(value !== null && value !== undefined);\r\n\t    this.arg = arg;\r\n\t    this.value = value;\r\n\t    return this;\r\n\t}\r\n\r\n\t/** @constructor */\r\n\tfunction alias(/* {identifier} */ name, /* {identifier} */ asname)\r\n\t{\r\n\t    goog.asserts.assert(name !== null && name !== undefined);\r\n\t    this.name = name;\r\n\t    this.asname = asname;\r\n\t    return this;\r\n\t}\r\n\r\n\r\n\tModule.prototype._astname = \"Module\";\r\n\tModule.prototype._fields = [\r\n\t    \"body\", function(n) { return n.body; }\r\n\t];\r\n\tInteractive.prototype._astname = \"Interactive\";\r\n\tInteractive.prototype._fields = [\r\n\t    \"body\", function(n) { return n.body; }\r\n\t];\r\n\tExpression.prototype._astname = \"Expression\";\r\n\tExpression.prototype._fields = [\r\n\t    \"body\", function(n) { return n.body; }\r\n\t];\r\n\tSuite.prototype._astname = \"Suite\";\r\n\tSuite.prototype._fields = [\r\n\t    \"body\", function(n) { return n.body; }\r\n\t];\r\n\tFunctionDef.prototype._astname = \"FunctionDef\";\r\n\tFunctionDef.prototype._fields = [\r\n\t    \"name\", function(n) { return n.name; },\r\n\t    \"args\", function(n) { return n.args; },\r\n\t    \"body\", function(n) { return n.body; },\r\n\t    \"decorator_list\", function(n) { return n.decorator_list; }\r\n\t];\r\n\tClassDef.prototype._astname = \"ClassDef\";\r\n\tClassDef.prototype._fields = [\r\n\t    \"name\", function(n) { return n.name; },\r\n\t    \"bases\", function(n) { return n.bases; },\r\n\t    \"body\", function(n) { return n.body; },\r\n\t    \"decorator_list\", function(n) { return n.decorator_list; }\r\n\t];\r\n\tReturn_.prototype._astname = \"Return\";\r\n\tReturn_.prototype._fields = [\r\n\t    \"value\", function(n) { return n.value; }\r\n\t];\r\n\tDelete_.prototype._astname = \"Delete\";\r\n\tDelete_.prototype._fields = [\r\n\t    \"targets\", function(n) { return n.targets; }\r\n\t];\r\n\tAssign.prototype._astname = \"Assign\";\r\n\tAssign.prototype._fields = [\r\n\t    \"targets\", function(n) { return n.targets; },\r\n\t    \"value\", function(n) { return n.value; }\r\n\t];\r\n\tAugAssign.prototype._astname = \"AugAssign\";\r\n\tAugAssign.prototype._fields = [\r\n\t    \"target\", function(n) { return n.target; },\r\n\t    \"op\", function(n) { return n.op; },\r\n\t    \"value\", function(n) { return n.value; }\r\n\t];\r\n\tPrint.prototype._astname = \"Print\";\r\n\tPrint.prototype._fields = [\r\n\t    \"dest\", function(n) { return n.dest; },\r\n\t    \"values\", function(n) { return n.values; },\r\n\t    \"nl\", function(n) { return n.nl; }\r\n\t];\r\n\tFor_.prototype._astname = \"For\";\r\n\tFor_.prototype._fields = [\r\n\t    \"target\", function(n) { return n.target; },\r\n\t    \"iter\", function(n) { return n.iter; },\r\n\t    \"body\", function(n) { return n.body; },\r\n\t    \"orelse\", function(n) { return n.orelse; }\r\n\t];\r\n\tWhile_.prototype._astname = \"While\";\r\n\tWhile_.prototype._fields = [\r\n\t    \"test\", function(n) { return n.test; },\r\n\t    \"body\", function(n) { return n.body; },\r\n\t    \"orelse\", function(n) { return n.orelse; }\r\n\t];\r\n\tIf_.prototype._astname = \"If\";\r\n\tIf_.prototype._fields = [\r\n\t    \"test\", function(n) { return n.test; },\r\n\t    \"body\", function(n) { return n.body; },\r\n\t    \"orelse\", function(n) { return n.orelse; }\r\n\t];\r\n\tWith_.prototype._astname = \"With\";\r\n\tWith_.prototype._fields = [\r\n\t    \"context_expr\", function(n) { return n.context_expr; },\r\n\t    \"optional_vars\", function(n) { return n.optional_vars; },\r\n\t    \"body\", function(n) { return n.body; }\r\n\t];\r\n\tRaise.prototype._astname = \"Raise\";\r\n\tRaise.prototype._fields = [\r\n\t    \"type\", function(n) { return n.type; },\r\n\t    \"inst\", function(n) { return n.inst; },\r\n\t    \"tback\", function(n) { return n.tback; }\r\n\t];\r\n\tTryExcept.prototype._astname = \"TryExcept\";\r\n\tTryExcept.prototype._fields = [\r\n\t    \"body\", function(n) { return n.body; },\r\n\t    \"handlers\", function(n) { return n.handlers; },\r\n\t    \"orelse\", function(n) { return n.orelse; }\r\n\t];\r\n\tTryFinally.prototype._astname = \"TryFinally\";\r\n\tTryFinally.prototype._fields = [\r\n\t    \"body\", function(n) { return n.body; },\r\n\t    \"finalbody\", function(n) { return n.finalbody; }\r\n\t];\r\n\tAssert.prototype._astname = \"Assert\";\r\n\tAssert.prototype._fields = [\r\n\t    \"test\", function(n) { return n.test; },\r\n\t    \"msg\", function(n) { return n.msg; }\r\n\t];\r\n\tImport_.prototype._astname = \"Import\";\r\n\tImport_.prototype._fields = [\r\n\t    \"names\", function(n) { return n.names; }\r\n\t];\r\n\tImportFrom.prototype._astname = \"ImportFrom\";\r\n\tImportFrom.prototype._fields = [\r\n\t    \"module\", function(n) { return n.module; },\r\n\t    \"names\", function(n) { return n.names; },\r\n\t    \"level\", function(n) { return n.level; }\r\n\t];\r\n\tExec.prototype._astname = \"Exec\";\r\n\tExec.prototype._fields = [\r\n\t    \"body\", function(n) { return n.body; },\r\n\t    \"globals\", function(n) { return n.globals; },\r\n\t    \"locals\", function(n) { return n.locals; }\r\n\t];\r\n\tGlobal.prototype._astname = \"Global\";\r\n\tGlobal.prototype._fields = [\r\n\t    \"names\", function(n) { return n.names; }\r\n\t];\r\n\tExpr.prototype._astname = \"Expr\";\r\n\tExpr.prototype._fields = [\r\n\t    \"value\", function(n) { return n.value; }\r\n\t];\r\n\tPass.prototype._astname = \"Pass\";\r\n\tPass.prototype._fields = [\r\n\t];\r\n\tBreak_.prototype._astname = \"Break\";\r\n\tBreak_.prototype._fields = [\r\n\t];\r\n\tContinue_.prototype._astname = \"Continue\";\r\n\tContinue_.prototype._fields = [\r\n\t];\r\n\tDebugger_.prototype._astname = \"Debugger\";\r\n\tDebugger_.prototype._fields = [\r\n\t];\r\n\tBoolOp.prototype._astname = \"BoolOp\";\r\n\tBoolOp.prototype._fields = [\r\n\t    \"op\", function(n) { return n.op; },\r\n\t    \"values\", function(n) { return n.values; }\r\n\t];\r\n\tBinOp.prototype._astname = \"BinOp\";\r\n\tBinOp.prototype._fields = [\r\n\t    \"left\", function(n) { return n.left; },\r\n\t    \"op\", function(n) { return n.op; },\r\n\t    \"right\", function(n) { return n.right; }\r\n\t];\r\n\tUnaryOp.prototype._astname = \"UnaryOp\";\r\n\tUnaryOp.prototype._fields = [\r\n\t    \"op\", function(n) { return n.op; },\r\n\t    \"operand\", function(n) { return n.operand; }\r\n\t];\r\n\tLambda.prototype._astname = \"Lambda\";\r\n\tLambda.prototype._fields = [\r\n\t    \"args\", function(n) { return n.args; },\r\n\t    \"body\", function(n) { return n.body; }\r\n\t];\r\n\tIfExp.prototype._astname = \"IfExp\";\r\n\tIfExp.prototype._fields = [\r\n\t    \"test\", function(n) { return n.test; },\r\n\t    \"body\", function(n) { return n.body; },\r\n\t    \"orelse\", function(n) { return n.orelse; }\r\n\t];\r\n\tDict.prototype._astname = \"Dict\";\r\n\tDict.prototype._fields = [\r\n\t    \"keys\", function(n) { return n.keys; },\r\n\t    \"values\", function(n) { return n.values; }\r\n\t];\r\n\tSet.prototype._astname = \"Set\";\r\n\tSet.prototype._fields = [\r\n\t    \"elts\", function(n) { return n.elts; }\r\n\t];\r\n\tListComp.prototype._astname = \"ListComp\";\r\n\tListComp.prototype._fields = [\r\n\t    \"elt\", function(n) { return n.elt; },\r\n\t    \"generators\", function(n) { return n.generators; }\r\n\t];\r\n\tSetComp.prototype._astname = \"SetComp\";\r\n\tSetComp.prototype._fields = [\r\n\t    \"elt\", function(n) { return n.elt; },\r\n\t    \"generators\", function(n) { return n.generators; }\r\n\t];\r\n\tDictComp.prototype._astname = \"DictComp\";\r\n\tDictComp.prototype._fields = [\r\n\t    \"key\", function(n) { return n.key; },\r\n\t    \"value\", function(n) { return n.value; },\r\n\t    \"generators\", function(n) { return n.generators; }\r\n\t];\r\n\tGeneratorExp.prototype._astname = \"GeneratorExp\";\r\n\tGeneratorExp.prototype._fields = [\r\n\t    \"elt\", function(n) { return n.elt; },\r\n\t    \"generators\", function(n) { return n.generators; }\r\n\t];\r\n\tYield.prototype._astname = \"Yield\";\r\n\tYield.prototype._fields = [\r\n\t    \"value\", function(n) { return n.value; }\r\n\t];\r\n\tCompare.prototype._astname = \"Compare\";\r\n\tCompare.prototype._fields = [\r\n\t    \"left\", function(n) { return n.left; },\r\n\t    \"ops\", function(n) { return n.ops; },\r\n\t    \"comparators\", function(n) { return n.comparators; }\r\n\t];\r\n\tCall.prototype._astname = \"Call\";\r\n\tCall.prototype._fields = [\r\n\t    \"func\", function(n) { return n.func; },\r\n\t    \"args\", function(n) { return n.args; },\r\n\t    \"keywords\", function(n) { return n.keywords; },\r\n\t    \"starargs\", function(n) { return n.starargs; },\r\n\t    \"kwargs\", function(n) { return n.kwargs; }\r\n\t];\r\n\tRepr.prototype._astname = \"Repr\";\r\n\tRepr.prototype._fields = [\r\n\t    \"value\", function(n) { return n.value; }\r\n\t];\r\n\tNum.prototype._astname = \"Num\";\r\n\tNum.prototype._fields = [\r\n\t    \"n\", function(n) { return n.n; }\r\n\t];\r\n\tStr.prototype._astname = \"Str\";\r\n\tStr.prototype._fields = [\r\n\t    \"s\", function(n) { return n.s; }\r\n\t];\r\n\tAttribute.prototype._astname = \"Attribute\";\r\n\tAttribute.prototype._fields = [\r\n\t    \"value\", function(n) { return n.value; },\r\n\t    \"attr\", function(n) { return n.attr; },\r\n\t    \"ctx\", function(n) { return n.ctx; }\r\n\t];\r\n\tSubscript.prototype._astname = \"Subscript\";\r\n\tSubscript.prototype._fields = [\r\n\t    \"value\", function(n) { return n.value; },\r\n\t    \"slice\", function(n) { return n.slice; },\r\n\t    \"ctx\", function(n) { return n.ctx; }\r\n\t];\r\n\tName.prototype._astname = \"Name\";\r\n\tName.prototype._fields = [\r\n\t    \"id\", function(n) { return n.id; },\r\n\t    \"ctx\", function(n) { return n.ctx; }\r\n\t];\r\n\tList.prototype._astname = \"List\";\r\n\tList.prototype._fields = [\r\n\t    \"elts\", function(n) { return n.elts; },\r\n\t    \"ctx\", function(n) { return n.ctx; }\r\n\t];\r\n\tTuple.prototype._astname = \"Tuple\";\r\n\tTuple.prototype._fields = [\r\n\t    \"elts\", function(n) { return n.elts; },\r\n\t    \"ctx\", function(n) { return n.ctx; }\r\n\t];\r\n\tLoad.prototype._astname = \"Load\";\r\n\tLoad.prototype._isenum = true;\r\n\tStore.prototype._astname = \"Store\";\r\n\tStore.prototype._isenum = true;\r\n\tDel.prototype._astname = \"Del\";\r\n\tDel.prototype._isenum = true;\r\n\tAugLoad.prototype._astname = \"AugLoad\";\r\n\tAugLoad.prototype._isenum = true;\r\n\tAugStore.prototype._astname = \"AugStore\";\r\n\tAugStore.prototype._isenum = true;\r\n\tParam.prototype._astname = \"Param\";\r\n\tParam.prototype._isenum = true;\r\n\tEllipsis.prototype._astname = \"Ellipsis\";\r\n\tEllipsis.prototype._fields = [\r\n\t];\r\n\tSlice.prototype._astname = \"Slice\";\r\n\tSlice.prototype._fields = [\r\n\t    \"lower\", function(n) { return n.lower; },\r\n\t    \"upper\", function(n) { return n.upper; },\r\n\t    \"step\", function(n) { return n.step; }\r\n\t];\r\n\tExtSlice.prototype._astname = \"ExtSlice\";\r\n\tExtSlice.prototype._fields = [\r\n\t    \"dims\", function(n) { return n.dims; }\r\n\t];\r\n\tIndex.prototype._astname = \"Index\";\r\n\tIndex.prototype._fields = [\r\n\t    \"value\", function(n) { return n.value; }\r\n\t];\r\n\tAnd.prototype._astname = \"And\";\r\n\tAnd.prototype._isenum = true;\r\n\tOr.prototype._astname = \"Or\";\r\n\tOr.prototype._isenum = true;\r\n\tAdd.prototype._astname = \"Add\";\r\n\tAdd.prototype._isenum = true;\r\n\tSub.prototype._astname = \"Sub\";\r\n\tSub.prototype._isenum = true;\r\n\tMult.prototype._astname = \"Mult\";\r\n\tMult.prototype._isenum = true;\r\n\tDiv.prototype._astname = \"Div\";\r\n\tDiv.prototype._isenum = true;\r\n\tMod.prototype._astname = \"Mod\";\r\n\tMod.prototype._isenum = true;\r\n\tPow.prototype._astname = \"Pow\";\r\n\tPow.prototype._isenum = true;\r\n\tLShift.prototype._astname = \"LShift\";\r\n\tLShift.prototype._isenum = true;\r\n\tRShift.prototype._astname = \"RShift\";\r\n\tRShift.prototype._isenum = true;\r\n\tBitOr.prototype._astname = \"BitOr\";\r\n\tBitOr.prototype._isenum = true;\r\n\tBitXor.prototype._astname = \"BitXor\";\r\n\tBitXor.prototype._isenum = true;\r\n\tBitAnd.prototype._astname = \"BitAnd\";\r\n\tBitAnd.prototype._isenum = true;\r\n\tFloorDiv.prototype._astname = \"FloorDiv\";\r\n\tFloorDiv.prototype._isenum = true;\r\n\tInvert.prototype._astname = \"Invert\";\r\n\tInvert.prototype._isenum = true;\r\n\tNot.prototype._astname = \"Not\";\r\n\tNot.prototype._isenum = true;\r\n\tUAdd.prototype._astname = \"UAdd\";\r\n\tUAdd.prototype._isenum = true;\r\n\tUSub.prototype._astname = \"USub\";\r\n\tUSub.prototype._isenum = true;\r\n\tEq.prototype._astname = \"Eq\";\r\n\tEq.prototype._isenum = true;\r\n\tNotEq.prototype._astname = \"NotEq\";\r\n\tNotEq.prototype._isenum = true;\r\n\tLt.prototype._astname = \"Lt\";\r\n\tLt.prototype._isenum = true;\r\n\tLtE.prototype._astname = \"LtE\";\r\n\tLtE.prototype._isenum = true;\r\n\tGt.prototype._astname = \"Gt\";\r\n\tGt.prototype._isenum = true;\r\n\tGtE.prototype._astname = \"GtE\";\r\n\tGtE.prototype._isenum = true;\r\n\tIs.prototype._astname = \"Is\";\r\n\tIs.prototype._isenum = true;\r\n\tIsNot.prototype._astname = \"IsNot\";\r\n\tIsNot.prototype._isenum = true;\r\n\tIn_.prototype._astname = \"In\";\r\n\tIn_.prototype._isenum = true;\r\n\tNotIn.prototype._astname = \"NotIn\";\r\n\tNotIn.prototype._isenum = true;\r\n\tcomprehension.prototype._astname = \"comprehension\";\r\n\tcomprehension.prototype._fields = [\r\n\t    \"target\", function(n) { return n.target; },\r\n\t    \"iter\", function(n) { return n.iter; },\r\n\t    \"ifs\", function(n) { return n.ifs; }\r\n\t];\r\n\tExceptHandler.prototype._astname = \"ExceptHandler\";\r\n\tExceptHandler.prototype._fields = [\r\n\t    \"type\", function(n) { return n.type; },\r\n\t    \"name\", function(n) { return n.name; },\r\n\t    \"body\", function(n) { return n.body; }\r\n\t];\r\n\targuments_.prototype._astname = \"arguments\";\r\n\targuments_.prototype._fields = [\r\n\t    \"args\", function(n) { return n.args; },\r\n\t    \"vararg\", function(n) { return n.vararg; },\r\n\t    \"kwarg\", function(n) { return n.kwarg; },\r\n\t    \"defaults\", function(n) { return n.defaults; }\r\n\t];\r\n\tkeyword.prototype._astname = \"keyword\";\r\n\tkeyword.prototype._fields = [\r\n\t    \"arg\", function(n) { return n.arg; },\r\n\t    \"value\", function(n) { return n.value; }\r\n\t];\r\n\talias.prototype._astname = \"alias\";\r\n\talias.prototype._fields = [\r\n\t    \"name\", function(n) { return n.name; },\r\n\t    \"asname\", function(n) { return n.asname; }\r\n\t];\r\n\r\n\r\n\r\n\r\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/ast.js ---- */ \r\n\r\n\t//\r\n\t// This is pretty much a straight port of ast.c from CPython 2.6.5.\r\n\t//\r\n\t// The previous version was easier to work with and more JS-ish, but having a\r\n\t// somewhat different ast structure than cpython makes testing more difficult.\r\n\t//\r\n\t// This way, we can use a dump from the ast module on any arbitrary python\r\n\t// code and know that we're the same up to ast level, at least.\r\n\t//\r\n\r\n\tvar SYM = Sk.ParseTables.sym;\r\n\tvar TOK = Sk.Tokenizer.Tokens;\r\n\tvar COMP_GENEXP = 0;\r\n\tvar COMP_SETCOMP = 1;\r\n\r\n\t/** @constructor */\r\n\tfunction Compiling (encoding, filename, c_flags) {\r\n\t    this.c_encoding = encoding;\r\n\t    this.c_filename = filename;\r\n\t    this.c_flags = c_flags || 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @return {number}\r\n\t */\r\n\tfunction NCH (n) {\r\n\t    goog.asserts.assert(n !== undefined);\r\n\t    if (n.children === null) {\r\n\t        return 0;\r\n\t    }\r\n\t    return n.children.length;\r\n\t}\r\n\r\n\tfunction CHILD (n, i) {\r\n\t    goog.asserts.assert(n !== undefined);\r\n\t    goog.asserts.assert(i !== undefined);\r\n\t    return n.children[i];\r\n\t}\r\n\r\n\tfunction REQ (n, type) {\r\n\t    goog.asserts.assert(n.type === type, \"node wasn't expected type\");\r\n\t}\r\n\r\n\tfunction strobj (s) {\r\n\t    goog.asserts.assert(typeof s === \"string\", \"expecting string, got \" + (typeof s));\r\n\t    return new Sk.builtin.str(s);\r\n\t}\r\n\r\n\t/** @return {number} */\r\n\tfunction numStmts (n) {\r\n\t    var ch;\r\n\t    var i;\r\n\t    var cnt;\r\n\t    switch (n.type) {\r\n\t        case SYM.single_input:\r\n\t            if (CHILD(n, 0).type === TOK.T_NEWLINE) {\r\n\t                return 0;\r\n\t            }\r\n\t            else {\r\n\t                return numStmts(CHILD(n, 0));\r\n\t            }\r\n\t        case SYM.file_input:\r\n\t            cnt = 0;\r\n\t            for (i = 0; i < NCH(n); ++i) {\r\n\t                ch = CHILD(n, i);\r\n\t                if (ch.type === SYM.stmt) {\r\n\t                    cnt += numStmts(ch);\r\n\t                }\r\n\t            }\r\n\t            return cnt;\r\n\t        case SYM.stmt:\r\n\t            return numStmts(CHILD(n, 0));\r\n\t        case SYM.compound_stmt:\r\n\t            return 1;\r\n\t        case SYM.simple_stmt:\r\n\t            return Math.floor(NCH(n) / 2); // div 2 is to remove count of ;s\r\n\t        case SYM.suite:\r\n\t            if (NCH(n) === 1) {\r\n\t                return numStmts(CHILD(n, 0));\r\n\t            }\r\n\t            else {\r\n\t                cnt = 0;\r\n\t                for (i = 2; i < NCH(n) - 1; ++i) {\r\n\t                    cnt += numStmts(CHILD(n, i));\r\n\t                }\r\n\t                return cnt;\r\n\t            }\r\n\t            break;\r\n\t        default:\r\n\t            goog.asserts.fail(\"Non-statement found\");\r\n\t    }\r\n\t    return 0;\r\n\t}\r\n\r\n\tfunction forbiddenCheck (c, n, x, lineno) {\r\n\t    if (x === \"None\") {\r\n\t        throw new Sk.builtin.SyntaxError(\"assignment to None\", c.c_filename, lineno, [], {node: n});\r\n\t    }\r\n\t    if (x === \"True\" || x === \"False\") {\r\n\t        throw new Sk.builtin.SyntaxError(\"assignment to True or False is forbidden\", c.c_filename, lineno, [], {node: n});\r\n\t    }\r\n\t}\r\n\r\n\t/**\r\n\t * Set the context ctx for e, recursively traversing e.\r\n\t *\r\n\t * Only sets context for expr kinds that can appear in assignment context as\r\n\t * per the asdl file.\r\n\t */\r\n\tfunction setContext (c, e, ctx, n) {\r\n\t    var i;\r\n\t    var exprName;\r\n\t    var s;\r\n\t    goog.asserts.assert(ctx !== AugStore && ctx !== AugLoad);\r\n\t    s = null;\r\n\t    exprName = null;\r\n\r\n\t    switch (e.constructor) {\r\n\t        case Attribute:\r\n\t        case Name:\r\n\t            if (ctx === Store) {\r\n\t                forbiddenCheck(c, n, e.attr, n.lineno);\r\n\t            }\r\n\t            e.ctx = ctx;\r\n\t            break;\r\n\t        case Subscript:\r\n\t            e.ctx = ctx;\r\n\t            break;\r\n\t        case List:\r\n\t            e.ctx = ctx;\r\n\t            s = e.elts;\r\n\t            break;\r\n\t        case Tuple:\r\n\t            if (e.elts.length === 0) {\r\n\t                throw new Sk.builtin.SyntaxError(\"can't assign to ()\", c.c_filename, n.lineno, ctx, {node: n});\r\n\t            }\r\n\t            e.ctx = ctx;\r\n\t            s = e.elts;\r\n\t            break;\r\n\t        case Lambda:\r\n\t            exprName = \"lambda\";\r\n\t            break;\r\n\t        case Call:\r\n\t            exprName = \"function call\";\r\n\t            break;\r\n\t        case BoolOp:\r\n\t        case BinOp:\r\n\t        case UnaryOp:\r\n\t            exprName = \"operator\";\r\n\t            break;\r\n\t        case GeneratorExp:\r\n\t            exprName = \"generator expression\";\r\n\t            break;\r\n\t        case Yield:\r\n\t            exprName = \"yield expression\";\r\n\t            break;\r\n\t        case ListComp:\r\n\t            exprName = \"list comprehension\";\r\n\t            break;\r\n\t        case SetComp:\r\n\t            exprName = \"set comprehension\";\r\n\t            break;\r\n\t        case DictComp:\r\n\t            exprName = \"dict comprehension\";\r\n\t            break;\r\n\t        case Dict:\r\n\t        case Set:\r\n\t        case Num:\r\n\t        case Str:\r\n\t            exprName = \"literal\";\r\n\t            break;\r\n\t        case Compare:\r\n\t            exprName = \"comparison\";\r\n\t            break;\r\n\t        case Repr:\r\n\t            exprName = \"repr\";\r\n\t            break;\r\n\t        case IfExp:\r\n\t            exprName = \"conditional expression\";\r\n\t            break;\r\n\t        default:\r\n\t            goog.asserts.fail(\"unhandled expression in assignment\");\r\n\t    }\r\n\t    if (exprName) {\r\n\t        throw new Sk.builtin.SyntaxError(\"can't \" + (ctx === Store ? \"assign to\" : \"delete\") + \" \" + exprName, c.c_filename, n.lineno, [], {node: n});\r\n\t    }\r\n\r\n\t    if (s) {\r\n\t        for (i = 0; i < s.length; ++i) {\r\n\t            setContext(c, s[i], ctx, n);\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tvar operatorMap = {};\r\n\t(function () {\r\n\t    operatorMap[TOK.T_VBAR] = BitOr;\r\n\t    operatorMap[TOK.T_CIRCUMFLEX] = BitXor;\r\n\t    operatorMap[TOK.T_AMPER] = BitAnd;\r\n\t    operatorMap[TOK.T_LEFTSHIFT] = LShift;\r\n\t    operatorMap[TOK.T_RIGHTSHIFT] = RShift;\r\n\t    operatorMap[TOK.T_PLUS] = Add;\r\n\t    operatorMap[TOK.T_MINUS] = Sub;\r\n\t    operatorMap[TOK.T_STAR] = Mult;\r\n\t    operatorMap[TOK.T_SLASH] = Div;\r\n\t    operatorMap[TOK.T_DOUBLESLASH] = FloorDiv;\r\n\t    operatorMap[TOK.T_PERCENT] = Mod;\r\n\t}());\r\n\r\n\tfunction getOperator (n) {\r\n\t    goog.asserts.assert(operatorMap[n.type] !== undefined);\r\n\t    return operatorMap[n.type];\r\n\t}\r\n\r\n\tfunction astForCompOp (c, n) {\r\n\t    /* comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'\r\n\t     |'is' 'not'\r\n\t     */\r\n\t    REQ(n, SYM.comp_op);\r\n\t    if (NCH(n) === 1) {\r\n\t        n = CHILD(n, 0);\r\n\t        switch (n.type) {\r\n\t            case TOK.T_LESS:\r\n\t                return Lt;\r\n\t            case TOK.T_GREATER:\r\n\t                return Gt;\r\n\t            case TOK.T_EQEQUAL:\r\n\t                return Eq;\r\n\t            case TOK.T_LESSEQUAL:\r\n\t                return LtE;\r\n\t            case TOK.T_GREATEREQUAL:\r\n\t                return GtE;\r\n\t            case TOK.T_NOTEQUAL:\r\n\t                return NotEq;\r\n\t            case TOK.T_NAME:\r\n\t                if (n.value === \"in\") {\r\n\t                    return In_;\r\n\t                }\r\n\t                if (n.value === \"is\") {\r\n\t                    return Is;\r\n\t                }\r\n\t        }\r\n\t    }\r\n\t    else if (NCH(n) === 2) {\r\n\t        if (CHILD(n, 0).type === TOK.T_NAME) {\r\n\t            if (CHILD(n, 1).value === \"in\") {\r\n\t                return NotIn;\r\n\t            }\r\n\t            if (CHILD(n, 0).value === \"is\") {\r\n\t                return IsNot;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    goog.asserts.fail(\"invalid comp_op\");\r\n\t}\r\n\r\n\tfunction seqForTestlist (c, n) {\r\n\t    /* testlist: test (',' test)* [','] */\r\n\t    var i;\r\n\t    var seq = [];\r\n\t    goog.asserts.assert(n.type === SYM.testlist ||\r\n\t        n.type === SYM.listmaker ||\r\n\t        n.type === SYM.testlist_comp ||\r\n\t        n.type === SYM.testlist_safe ||\r\n\t        n.type === SYM.testlist1);\r\n\t    for (i = 0; i < NCH(n); i += 2) {\r\n\t        goog.asserts.assert(CHILD(n, i).type === SYM.test || CHILD(n, i).type === SYM.old_test);\r\n\t        seq[i / 2] = astForExpr(c, CHILD(n, i));\r\n\t    }\r\n\t    return seq;\r\n\t}\r\n\r\n\tfunction astForSuite (c, n) {\r\n\t    /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */\r\n\t    var j;\r\n\t    var num;\r\n\t    var i;\r\n\t    var end;\r\n\t    var ch;\r\n\t    var pos;\r\n\t    var seq;\r\n\t    REQ(n, SYM.suite);\r\n\t    seq = [];\r\n\t    pos = 0;\r\n\t    if (CHILD(n, 0).type === SYM.simple_stmt) {\r\n\t        n = CHILD(n, 0);\r\n\t        /* simple_stmt always ends with an NEWLINE and may have a trailing\r\n\t         * SEMI. */\r\n\t        end = NCH(n) - 1;\r\n\t        if (CHILD(n, end - 1).type === TOK.T_SEMI) {\r\n\t            end -= 1;\r\n\t        }\r\n\t        for (i = 0; i < end; i += 2) // by 2 to skip ;\r\n\t        {\r\n\t            seq[pos++] = astForStmt(c, CHILD(n, i));\r\n\t        }\r\n\t    }\r\n\t    else {\r\n\t        for (i = 2; i < NCH(n) - 1; ++i) {\r\n\t            ch = CHILD(n, i);\r\n\t            REQ(ch, SYM.stmt);\r\n\t            num = numStmts(ch);\r\n\t            if (num === 1) {\r\n\t                // small_stmt or compound_stmt w/ only 1 child\r\n\t                seq[pos++] = astForStmt(c, ch);\r\n\t            }\r\n\t            else {\r\n\t                ch = CHILD(ch, 0);\r\n\t                REQ(ch, SYM.simple_stmt);\r\n\t                for (j = 0; j < NCH(ch); j += 2) {\r\n\t                    if (NCH(CHILD(ch, j)) === 0) {\r\n\t                        goog.asserts.assert(j + 1 === NCH(ch));\r\n\t                        break;\r\n\t                    }\r\n\t                    seq[pos++] = astForStmt(c, CHILD(ch, j));\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    goog.asserts.assert(pos === numStmts(n));\r\n\t    return seq;\r\n\t}\r\n\r\n\tfunction astForExceptClause (c, exc, body) {\r\n\t    /* except_clause: 'except' [test [(',' | 'as') test]] */\r\n\t    var e;\r\n\t    REQ(exc, SYM.except_clause);\r\n\t    REQ(body, SYM.suite);\r\n\t    if (NCH(exc) === 1) {\r\n\t        return new ExceptHandler(null, null, astForSuite(c, body), exc.lineno, exc.col_offset);\r\n\t    }\r\n\t    else if (NCH(exc) === 2) {\r\n\t        return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), null, astForSuite(c, body), exc.lineno, exc.col_offset);\r\n\t    }\r\n\t    else if (NCH(exc) === 4) {\r\n\t        e = astForExpr(c, CHILD(exc, 3));\r\n\t        setContext(c, e, Store, CHILD(exc, 3));\r\n\t        return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), e, astForSuite(c, body), exc.lineno, exc.col_offset);\r\n\t    }\r\n\t    goog.asserts.fail(\"wrong number of children for except clause\");\r\n\t}\r\n\r\n\tfunction astForTryStmt (c, n) {\r\n\t    var exceptSt;\r\n\t    var i;\r\n\t    var handlers;\r\n\t    var nc = NCH(n);\r\n\t    var nexcept = (nc - 3) / 3;\r\n\t    var body, orelse = [],\r\n\t        finally_ = null;\r\n\r\n\t    REQ(n, SYM.try_stmt);\r\n\t    body = astForSuite(c, CHILD(n, 2));\r\n\t    if (CHILD(n, nc - 3).type === TOK.T_NAME) {\r\n\t        if (CHILD(n, nc - 3).value === \"finally\") {\r\n\t            if (nc >= 9 && CHILD(n, nc - 6).type === TOK.T_NAME) {\r\n\t                /* we can assume it's an \"else\",\r\n\t                 because nc >= 9 for try-else-finally and\r\n\t                 it would otherwise have a type of except_clause */\r\n\t                orelse = astForSuite(c, CHILD(n, nc - 4));\r\n\t                nexcept--;\r\n\t            }\r\n\r\n\t            finally_ = astForSuite(c, CHILD(n, nc - 1));\r\n\t            nexcept--;\r\n\t        }\r\n\t        else {\r\n\t            /* we can assume it's an \"else\",\r\n\t             otherwise it would have a type of except_clause */\r\n\t            orelse = astForSuite(c, CHILD(n, nc - 1));\r\n\t            nexcept--;\r\n\t        }\r\n\t    }\r\n\t    else if (CHILD(n, nc - 3).type !== SYM.except_clause) {\r\n\t        throw new Sk.builtin.SyntaxError(\"malformed 'try' statement\", c.c_filename, n.lineno);\r\n\t    }\r\n\r\n\t    if (nexcept > 0) {\r\n\t        handlers = [];\r\n\t        for (i = 0; i < nexcept; ++i) {\r\n\t            handlers[i] = astForExceptClause(c, CHILD(n, 3 + i * 3), CHILD(n, 5 + i * 3));\r\n\t        }\r\n\t        exceptSt = new TryExcept(body, handlers, orelse, n.lineno, n.col_offset);\r\n\r\n\t        if (!finally_) {\r\n\t            return exceptSt;\r\n\t        }\r\n\r\n\t        /* if a 'finally' is present too, we nest the TryExcept within a\r\n\t         TryFinally to emulate try ... except ... finally */\r\n\t        body = [exceptSt];\r\n\t    }\r\n\r\n\t    goog.asserts.assert(finally_ !== null);\r\n\t    return new TryFinally(body, finally_, n.lineno, n.col_offset);\r\n\t}\r\n\r\n\r\n\tfunction astForDottedName (c, n) {\r\n\t    var i;\r\n\t    var e;\r\n\t    var id;\r\n\t    var col_offset;\r\n\t    var lineno;\r\n\t    REQ(n, SYM.dotted_name);\r\n\t    lineno = n.lineno;\r\n\t    col_offset = n.col_offset;\r\n\t    id = strobj(CHILD(n, 0).value);\r\n\t    e = new Name(id, Load, lineno, col_offset);\r\n\t    for (i = 2; i < NCH(n); i += 2) {\r\n\t        id = strobj(CHILD(n, i).value);\r\n\t        e = new Attribute(e, id, Load, lineno, col_offset);\r\n\t    }\r\n\t    return e;\r\n\t}\r\n\r\n\tfunction astForDecorator (c, n) {\r\n\t    /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */\r\n\t    var nameExpr;\r\n\t    REQ(n, SYM.decorator);\r\n\t    REQ(CHILD(n, 0), TOK.T_AT);\r\n\t    REQ(CHILD(n, NCH(n) - 1), TOK.T_NEWLINE);\r\n\t    nameExpr = astForDottedName(c, CHILD(n, 1));\r\n\t    if (NCH(n) === 3) // no args\r\n\t    {\r\n\t        return nameExpr;\r\n\t    }\r\n\t    else if (NCH(n) === 5) // call with no args\r\n\t    {\r\n\t        return new Call(nameExpr, [], [], null, null, n.lineno, n.col_offset);\r\n\t    }\r\n\t    else {\r\n\t        return astForCall(c, CHILD(n, 3), nameExpr);\r\n\t    }\r\n\t}\r\n\r\n\tfunction astForDecorators (c, n) {\r\n\t    var i;\r\n\t    var decoratorSeq;\r\n\t    REQ(n, SYM.decorators);\r\n\t    decoratorSeq = [];\r\n\t    for (i = 0; i < NCH(n); ++i) {\r\n\t        decoratorSeq[i] = astForDecorator(c, CHILD(n, i));\r\n\t    }\r\n\t    return decoratorSeq;\r\n\t}\r\n\r\n\tfunction astForDecorated (c, n) {\r\n\t    var thing;\r\n\t    var decoratorSeq;\r\n\t    REQ(n, SYM.decorated);\r\n\t    decoratorSeq = astForDecorators(c, CHILD(n, 0));\r\n\t    goog.asserts.assert(CHILD(n, 1).type === SYM.funcdef || CHILD(n, 1).type === SYM.classdef);\r\n\r\n\t    thing = null;\r\n\t    if (CHILD(n, 1).type === SYM.funcdef) {\r\n\t        thing = astForFuncdef(c, CHILD(n, 1), decoratorSeq);\r\n\t    }\r\n\t    else if (CHILD(n, 1) === SYM.classdef) {\r\n\t        thing = astForClassdef(c, CHILD(n, 1), decoratorSeq);\r\n\t    }\r\n\t    if (thing) {\r\n\t        thing.lineno = n.lineno;\r\n\t        thing.col_offset = n.col_offset;\r\n\t    }\r\n\t    return thing;\r\n\t}\r\n\r\n\t//note: with statements need to be updated to 2.7\r\n\t//see: ast.c lines: 3127 -> 3185\r\n\r\n\tfunction astForWithVar (c, n) {\r\n\t    REQ(n, SYM.with_item);\r\n\t    return astForExpr(c, CHILD(n, 1));\r\n\t}\r\n\r\n\tfunction astForWithStmt (c, n) {\r\n\t    /* with_stmt: 'with' test [ with_var ] ':' suite */\r\n\t    var optionalVars;\r\n\t    var contextExpr;\r\n\t    var suiteIndex = 3; // skip with, test, :\r\n\t    goog.asserts.assert(n.type === SYM.with_stmt);\r\n\t    contextExpr = astForExpr(c, CHILD(n, 1));\r\n\t    if (CHILD(n, 2).type === SYM.with_item) {\r\n\t        optionalVars = astForWithVar(c, CHILD(n, 2));\r\n\t        setContext(c, optionalVars, Store, n);\r\n\t        suiteIndex = 4;\r\n\t    }\r\n\t    return new With_(contextExpr, optionalVars, astForSuite(c, CHILD(n, suiteIndex)), n.lineno, n.col_offset);\r\n\t}\r\n\r\n\tfunction astForExecStmt (c, n) {\r\n\t    var expr1, globals = null, locals = null;\r\n\t    var nchildren = NCH(n);\r\n\t    goog.asserts.assert(nchildren === 2 || nchildren === 4 || nchildren === 6);\r\n\r\n\t    /* exec_stmt: 'exec' expr ['in' test [',' test]] */\r\n\t    REQ(n, SYM.exec_stmt);\r\n\t    expr1 = astForExpr(c, CHILD(n, 1));\r\n\t    if (nchildren >= 4) {\r\n\t        globals = astForExpr(c, CHILD(n, 3));\r\n\t    }\r\n\t    if (nchildren === 6) {\r\n\t        locals = astForExpr(c, CHILD(n, 5));\r\n\t    }\r\n\t    return new Exec(expr1, globals, locals, n.lineno, n.col_offset);\r\n\t}\r\n\r\n\tfunction astForIfStmt (c, n) {\r\n\t    /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*\r\n\t     ['else' ':' suite]\r\n\t     */\r\n\t    var off;\r\n\t    var i;\r\n\t    var orelse;\r\n\t    var hasElse;\r\n\t    var nElif;\r\n\t    var decider;\r\n\t    var s;\r\n\t    REQ(n, SYM.if_stmt);\r\n\t    if (NCH(n) === 4) {\r\n\t        return new If_(\r\n\t            astForExpr(c, CHILD(n, 1)),\r\n\t            astForSuite(c, CHILD(n, 3)),\r\n\t            [], n.lineno, n.col_offset);\r\n\t    }\r\n\r\n\t    s = CHILD(n, 4).value;\r\n\t    decider = s.charAt(2); // elSe or elIf\r\n\t    if (decider === \"s\") {\r\n\t        return new If_(\r\n\t            astForExpr(c, CHILD(n, 1)),\r\n\t            astForSuite(c, CHILD(n, 3)),\r\n\t            astForSuite(c, CHILD(n, 6)),\r\n\t            n.lineno, n.col_offset);\r\n\t    }\r\n\t    else if (decider === \"i\") {\r\n\t        nElif = NCH(n) - 4;\r\n\t        hasElse = false;\r\n\t        orelse = [];\r\n\r\n\t        /* must reference the child nElif+1 since 'else' token is third, not\r\n\t         * fourth child from the end. */\r\n\t        if (CHILD(n, nElif + 1).type === TOK.T_NAME &&\r\n\t            CHILD(n, nElif + 1).value.charAt(2) === \"s\") {\r\n\t            hasElse = true;\r\n\t            nElif -= 3;\r\n\t        }\r\n\t        nElif /= 4;\r\n\r\n\t        if (hasElse) {\r\n\t            orelse = [\r\n\t                new If_(\r\n\t                    astForExpr(c, CHILD(n, NCH(n) - 6)),\r\n\t                    astForSuite(c, CHILD(n, NCH(n) - 4)),\r\n\t                    astForSuite(c, CHILD(n, NCH(n) - 1)),\r\n\t                    CHILD(n, NCH(n) - 6).lineno,\r\n\t                    CHILD(n, NCH(n) - 6).col_offset)];\r\n\t            nElif--;\r\n\t        }\r\n\r\n\t        for (i = 0; i < nElif; ++i) {\r\n\t            off = 5 + (nElif - i - 1) * 4;\r\n\t            orelse = [\r\n\t                new If_(\r\n\t                    astForExpr(c, CHILD(n, off)),\r\n\t                    astForSuite(c, CHILD(n, off + 2)),\r\n\t                    orelse,\r\n\t                    CHILD(n, off).lineno,\r\n\t                    CHILD(n, off).col_offset)];\r\n\t        }\r\n\t        return new If_(\r\n\t            astForExpr(c, CHILD(n, 1)),\r\n\t            astForSuite(c, CHILD(n, 3)),\r\n\t            orelse, n.lineno, n.col_offset);\r\n\t    }\r\n\r\n\t    goog.asserts.fail(\"unexpected token in 'if' statement\");\r\n\t}\r\n\r\n\tfunction astForExprlist (c, n, context) {\r\n\t    var e;\r\n\t    var i;\r\n\t    var seq;\r\n\t    REQ(n, SYM.exprlist);\r\n\t    seq = [];\r\n\t    for (i = 0; i < NCH(n); i += 2) {\r\n\t        e = astForExpr(c, CHILD(n, i));\r\n\t        seq[i / 2] = e;\r\n\t        if (context) {\r\n\t            setContext(c, e, context, CHILD(n, i));\r\n\t        }\r\n\t    }\r\n\t    return seq;\r\n\t}\r\n\r\n\tfunction astForDelStmt (c, n) {\r\n\t    /* del_stmt: 'del' exprlist */\r\n\t    REQ(n, SYM.del_stmt);\r\n\t    return new Delete_(astForExprlist(c, CHILD(n, 1), Del), n.lineno, n.col_offset);\r\n\t}\r\n\r\n\tfunction astForGlobalStmt (c, n) {\r\n\t    /* global_stmt: 'global' NAME (',' NAME)* */\r\n\t    var i;\r\n\t    var s = [];\r\n\t    REQ(n, SYM.global_stmt);\r\n\t    for (i = 1; i < NCH(n); i += 2) {\r\n\t        s[(i - 1) / 2] = strobj(CHILD(n, i).value);\r\n\t    }\r\n\t    return new Global(s, n.lineno, n.col_offset);\r\n\t}\r\n\r\n\tfunction astForAssertStmt (c, n) {\r\n\t    /* assert_stmt: 'assert' test [',' test] */\r\n\t    REQ(n, SYM.assert_stmt);\r\n\t    if (NCH(n) === 2) {\r\n\t        return new Assert(astForExpr(c, CHILD(n, 1)), null, n.lineno, n.col_offset);\r\n\t    }\r\n\t    else if (NCH(n) === 4) {\r\n\t        return new Assert(astForExpr(c, CHILD(n, 1)), astForExpr(c, CHILD(n, 3)), n.lineno, n.col_offset);\r\n\t    }\r\n\t    goog.asserts.fail(\"improper number of parts to assert stmt\");\r\n\t}\r\n\r\n\tfunction aliasForImportName (c, n) {\r\n\t    /*\r\n\t     import_as_name: NAME ['as' NAME]\r\n\t     dotted_as_name: dotted_name ['as' NAME]\r\n\t     dotted_name: NAME ('.' NAME)*\r\n\t     */\r\n\r\n\t    var i;\r\n\t    var a;\r\n\t    var name;\r\n\t    var str;\r\n\t    loop: while (true) {\r\n\t        switch (n.type) {\r\n\t            case SYM.import_as_name:\r\n\t                str = null;\r\n\t                name = strobj(CHILD(n, 0).value);\r\n\t                if (NCH(n) === 3) {\r\n\t                    str = CHILD(n, 2).value;\r\n\t                }\r\n\t                return new alias(name, str == null ? null : strobj(str));\r\n\t            case SYM.dotted_as_name:\r\n\t                if (NCH(n) === 1) {\r\n\t                    n = CHILD(n, 0);\r\n\t                    continue loop;\r\n\t                }\r\n\t                else {\r\n\t                    a = aliasForImportName(c, CHILD(n, 0));\r\n\t                    goog.asserts.assert(!a.asname);\r\n\t                    a.asname = strobj(CHILD(n, 2).value);\r\n\t                    return a;\r\n\t                }\r\n\t                break;\r\n\t            case SYM.dotted_name:\r\n\t                if (NCH(n) === 1) {\r\n\t                    return new alias(strobj(CHILD(n, 0).value), null);\r\n\t                }\r\n\t                else {\r\n\t                    // create a string of the form a.b.c\r\n\t                    str = \"\";\r\n\t                    for (i = 0; i < NCH(n); i += 2) {\r\n\t                        str += CHILD(n, i).value + \".\";\r\n\t                    }\r\n\t                    return new alias(strobj(str.substr(0, str.length - 1)), null);\r\n\t                }\r\n\t                break;\r\n\t            case TOK.T_STAR:\r\n\t                return new alias(strobj(\"*\"), null);\r\n\t            default:\r\n\t                throw new Sk.builtin.SyntaxError(\"unexpected import name\", c.c_filename, n.lineno);\r\n\t        }\r\n\t        break;\r\n\t    }\r\n\t}\r\n\r\n\tfunction astForImportStmt (c, n) {\r\n\t    /*\r\n\t     import_stmt: import_name | import_from\r\n\t     import_name: 'import' dotted_as_names\r\n\t     import_from: 'from' ('.'* dotted_name | '.') 'import'\r\n\t     ('*' | '(' import_as_names ')' | import_as_names)\r\n\t     */\r\n\t    var modname;\r\n\t    var idx;\r\n\t    var nchildren;\r\n\t    var ndots;\r\n\t    var mod;\r\n\t    var i;\r\n\t    var aliases;\r\n\t    var col_offset;\r\n\t    var lineno;\r\n\t    REQ(n, SYM.import_stmt);\r\n\t    lineno = n.lineno;\r\n\t    col_offset = n.col_offset;\r\n\t    n = CHILD(n, 0);\r\n\t    if (n.type === SYM.import_name) {\r\n\t        n = CHILD(n, 1);\r\n\t        REQ(n, SYM.dotted_as_names);\r\n\t        aliases = [];\r\n\t        for (i = 0; i < NCH(n); i += 2) {\r\n\t            aliases[i / 2] = aliasForImportName(c, CHILD(n, i));\r\n\t        }\r\n\t        return new Import_(aliases, lineno, col_offset);\r\n\t    }\r\n\t    else if (n.type === SYM.import_from) {\r\n\t        mod = null;\r\n\t        ndots = 0;\r\n\r\n\t        for (idx = 1; idx < NCH(n); ++idx) {\r\n\t            if (CHILD(n, idx).type === SYM.dotted_name) {\r\n\t                mod = aliasForImportName(c, CHILD(n, idx));\r\n\t                idx++;\r\n\t                break;\r\n\t            }\r\n\t            else if (CHILD(n, idx).type !== TOK.T_DOT) {\r\n\t                break;\r\n\t            }\r\n\t            ndots++;\r\n\t        }\r\n\t        ++idx; // skip the import keyword\r\n\t        switch (CHILD(n, idx).type) {\r\n\t            case TOK.T_STAR:\r\n\t                // from ... import\r\n\t                n = CHILD(n, idx);\r\n\t                nchildren = 1;\r\n\t                break;\r\n\t            case TOK.T_LPAR:\r\n\t                // from ... import (x, y, z)\r\n\t                n = CHILD(n, idx + 1);\r\n\t                nchildren = NCH(n);\r\n\t                break;\r\n\t            case SYM.import_as_names:\r\n\t                // from ... import x, y, z\r\n\t                n = CHILD(n, idx);\r\n\t                nchildren = NCH(n);\r\n\t                if (nchildren % 2 === 0) {\r\n\t                    throw new Sk.builtin.SyntaxError(\"trailing comma not allowed without surrounding parentheses\", c.c_filename, n.lineno);\r\n\t                }\r\n\t                break;\r\n\t            default:\r\n\t                throw new Sk.builtin.SyntaxError(\"Unexpected node-type in from-import\", c.c_filename, n.lineno);\r\n\t        }\r\n\t        aliases = [];\r\n\t        if (n.type === TOK.T_STAR) {\r\n\t            aliases[0] = aliasForImportName(c, n);\r\n\t        }\r\n\t        else {\r\n\t            for (i = 0; i < NCH(n); i += 2) {\r\n\t                aliases[i / 2] = aliasForImportName(c, CHILD(n, i));\r\n\t            }\r\n\t        }\r\n\t        modname = mod ? mod.name.v : \"\";\r\n\t        return new ImportFrom(strobj(modname), aliases, ndots, lineno, col_offset);\r\n\t    }\r\n\t    throw new Sk.builtin.SyntaxError(\"unknown import statement\", c.c_filename, n.lineno);\r\n\t}\r\n\r\n\tfunction astForTestlistComp(c, n) {\r\n\t    /* testlist_comp: test ( comp_for | (',' test)* [','] ) */\r\n\t    /* argument: test [comp_for] */\r\n\t    goog.asserts.assert(n.type === SYM.testlist_comp || n.type === SYM.argument);\r\n\t    if (NCH(n) > 1 && CHILD(n, 1).type === SYM.comp_for) {\r\n\t        return astForGenExpr(c, n);\r\n\t    }\r\n\t    return astForTestlist(c, n);\r\n\t}\r\n\r\n\tfunction astForListcomp (c, n) {\r\n\t    /* listmaker: test ( list_for | (',' test)* [','] )\r\n\t     list_for: 'for' exprlist 'in' testlist_safe [list_iter]\r\n\t     list_iter: list_for | list_if\r\n\t     list_if: 'if' test [list_iter]\r\n\t     testlist_safe: test [(',' test)+ [',']]\r\n\t     */\r\n\r\n\t    function countListFors (c, n) {\r\n\t        var nfors = 0;\r\n\t        var ch = CHILD(n, 1);\r\n\t        count_list_for: while (true) {\r\n\t            nfors++;\r\n\t            REQ(ch, SYM.list_for);\r\n\t            if (NCH(ch) === 5) {\r\n\t                ch = CHILD(ch, 4);\r\n\t            }\r\n\t            else {\r\n\t                return nfors;\r\n\t            }\r\n\t            count_list_iter: while (true) {\r\n\t                REQ(ch, SYM.list_iter);\r\n\t                ch = CHILD(ch, 0);\r\n\t                if (ch.type === SYM.list_for) {\r\n\t                    continue count_list_for;\r\n\t                }\r\n\t                else if (ch.type === SYM.list_if) {\r\n\t                    if (NCH(ch) === 3) {\r\n\t                        ch = CHILD(ch, 2);\r\n\t                        continue count_list_iter;\r\n\t                    }\r\n\t                    else {\r\n\t                        return nfors;\r\n\t                    }\r\n\t                }\r\n\t                break;\r\n\t            }\r\n\t            break;\r\n\t        }\r\n\t    }\r\n\r\n\t    function countListIfs (c, n) {\r\n\t        var nifs = 0;\r\n\t        while (true) {\r\n\t            REQ(n, SYM.list_iter);\r\n\t            if (CHILD(n, 0).type === SYM.list_for) {\r\n\t                return nifs;\r\n\t            }\r\n\t            n = CHILD(n, 0);\r\n\t            REQ(n, SYM.list_if);\r\n\t            nifs++;\r\n\t            if (NCH(n) == 2) {\r\n\t                return nifs;\r\n\t            }\r\n\t            n = CHILD(n, 2);\r\n\t        }\r\n\t    }\r\n\r\n\t    var j;\r\n\t    var ifs;\r\n\t    var nifs;\r\n\t    var lc;\r\n\t    var expression;\r\n\t    var t;\r\n\t    var forch;\r\n\t    var i;\r\n\t    var ch;\r\n\t    var listcomps;\r\n\t    var nfors;\r\n\t    var elt;\r\n\t    REQ(n, SYM.listmaker);\r\n\t    goog.asserts.assert(NCH(n) > 1);\r\n\t    elt = astForExpr(c, CHILD(n, 0));\r\n\t    nfors = countListFors(c, n);\r\n\t    listcomps = [];\r\n\t    ch = CHILD(n, 1);\r\n\t    for (i = 0; i < nfors; ++i) {\r\n\t        REQ(ch, SYM.list_for);\r\n\t        forch = CHILD(ch, 1);\r\n\t        t = astForExprlist(c, forch, Store);\r\n\t        expression = astForTestlist(c, CHILD(ch, 3));\r\n\t        if (NCH(forch) === 1) {\r\n\t            lc = new comprehension(t[0], expression, []);\r\n\t        }\r\n\t        else {\r\n\t            lc = new comprehension(new Tuple(t, Store, ch.lineno, ch.col_offset), expression, []);\r\n\t        }\r\n\r\n\t        if (NCH(ch) === 5) {\r\n\t            ch = CHILD(ch, 4);\r\n\t            nifs = countListIfs(c, ch);\r\n\t            ifs = [];\r\n\t            for (j = 0; j < nifs; ++j) {\r\n\t                REQ(ch, SYM.list_iter);\r\n\t                ch = CHILD(ch, 0);\r\n\t                REQ(ch, SYM.list_if);\r\n\t                ifs[j] = astForExpr(c, CHILD(ch, 1));\r\n\t                if (NCH(ch) === 3) {\r\n\t                    ch = CHILD(ch, 2);\r\n\t                }\r\n\t            }\r\n\t            if (ch.type === SYM.list_iter) {\r\n\t                ch = CHILD(ch, 0);\r\n\t            }\r\n\t            lc.ifs = ifs;\r\n\t        }\r\n\t        listcomps[i] = lc;\r\n\t    }\r\n\t    return new ListComp(elt, listcomps, n.lineno, n.col_offset);\r\n\t}\r\n\r\n\tfunction astForFactor (c, n) {\r\n\t    /* some random peephole thing that cpy does */\r\n\t    var expression;\r\n\t    var pnum;\r\n\t    var patom;\r\n\t    var ppower;\r\n\t    var pfactor;\r\n\t    if (CHILD(n, 0).type === TOK.T_MINUS && NCH(n) === 2) {\r\n\t        pfactor = CHILD(n, 1);\r\n\t        if (pfactor.type === SYM.factor && NCH(pfactor) === 1) {\r\n\t            ppower = CHILD(pfactor, 0);\r\n\t            if (ppower.type === SYM.power && NCH(ppower) === 1) {\r\n\t                patom = CHILD(ppower, 0);\r\n\t                if (patom.type === SYM.atom) {\r\n\t                    pnum = CHILD(patom, 0);\r\n\t                    if (pnum.type === TOK.T_NUMBER) {\r\n\t                        pnum.value = \"-\" + pnum.value;\r\n\t                        return astForAtom(c, patom);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    expression = astForExpr(c, CHILD(n, 1));\r\n\t    switch (CHILD(n, 0).type) {\r\n\t        case TOK.T_PLUS:\r\n\t            return new UnaryOp(UAdd, expression, n.lineno, n.col_offset);\r\n\t        case TOK.T_MINUS:\r\n\t            return new UnaryOp(USub, expression, n.lineno, n.col_offset);\r\n\t        case TOK.T_TILDE:\r\n\t            return new UnaryOp(Invert, expression, n.lineno, n.col_offset);\r\n\t    }\r\n\r\n\t    goog.asserts.fail(\"unhandled factor\");\r\n\t}\r\n\r\n\tfunction astForForStmt (c, n) {\r\n\t    /* for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite] */\r\n\t    var target;\r\n\t    var _target;\r\n\t    var nodeTarget;\r\n\t    var seq = [];\r\n\t    REQ(n, SYM.for_stmt);\r\n\t    if (NCH(n) === 9) {\r\n\t        seq = astForSuite(c, CHILD(n, 8));\r\n\t    }\r\n\t    nodeTarget = CHILD(n, 1);\r\n\t    _target = astForExprlist(c, nodeTarget, Store);\r\n\t    if (NCH(nodeTarget) === 1) {\r\n\t        target = _target[0];\r\n\t    }\r\n\t    else {\r\n\t        target = new Tuple(_target, Store, n.lineno, n.col_offset);\r\n\t    }\r\n\r\n\t    return new For_(target,\r\n\t        astForTestlist(c, CHILD(n, 3)),\r\n\t        astForSuite(c, CHILD(n, 5)),\r\n\t        seq, n.lineno, n.col_offset);\r\n\t}\r\n\r\n\tfunction astForCall (c, n, func) {\r\n\t    /*\r\n\t      arglist: (argument ',')* (argument [',']| '*' test [',' '**' test]\r\n\t               | '**' test)\r\n\t      argument: test [comp_for] | test '=' test       # Really [keyword '='] test\r\n\t    */\r\n\t    var tmp;\r\n\t    var k;\r\n\t    var key;\r\n\t    var e;\r\n\t    var kwarg;\r\n\t    var vararg;\r\n\t    var keywords;\r\n\t    var args;\r\n\t    var ch;\r\n\t    var i;\r\n\t    var ngens;\r\n\t    var nkeywords;\r\n\t    var nargs;\r\n\r\n\t    REQ(n, SYM.arglist);\r\n\t    nargs = 0;\r\n\t    nkeywords = 0;\r\n\t    ngens = 0;\r\n\t    for (i = 0; i < NCH(n); i++) {\r\n\t        ch = CHILD(n, i);\r\n\t        if (ch.type === SYM.argument) {\r\n\t            if (NCH(ch) === 1) {\r\n\t                nargs++;\r\n\t            }\r\n\t            else if (CHILD(ch, 1).type === SYM.comp_for) {\r\n\t                ngens++;\r\n\t            }\r\n\t            else {\r\n\t                nkeywords++;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    if (ngens > 1 || (ngens && (nargs || nkeywords))) {\r\n\t        throw new Sk.builtin.SyntaxError(\"Generator expression must be parenthesized if not sole argument\", c.c_filename, n.lineno);\r\n\t    }\r\n\t    if (nargs + nkeywords + ngens > 255) {\r\n\t        throw new Sk.builtin.SyntaxError(\"more than 255 arguments\", c.c_filename, n.lineno);\r\n\t    }\r\n\t    args = [];\r\n\t    keywords = [];\r\n\t    nargs = 0;\r\n\t    nkeywords = 0;\r\n\t    vararg = null;\r\n\t    kwarg = null;\r\n\t    for (i = 0; i < NCH(n); i++) {\r\n\t        ch = CHILD(n, i);\r\n\t        if (ch.type === SYM.argument) {\r\n\t            if (NCH(ch) === 1) {\r\n\t                if (nkeywords) {\r\n\t                    throw new Sk.builtin.SyntaxError(\"non-keyword arg after keyword arg\", c.c_filename, n.lineno);\r\n\t                }\r\n\t                if (vararg) {\r\n\t                    throw new Sk.builtin.SyntaxError(\"only named arguments may follow *expression\", c.c_filename, n.lineno);\r\n\t                }\r\n\t                args[nargs++] = astForExpr(c, CHILD(ch, 0));\r\n\t            }\r\n\t            else if (CHILD(ch, 1).type === SYM.comp_for) {\r\n\t                args[nargs++] = astForGenExpr(c, ch);\r\n\t            }\r\n\t            else {\r\n\t                e = astForExpr(c, CHILD(ch, 0));\r\n\t                if (e.constructor === Lambda) {\r\n\t                    throw new Sk.builtin.SyntaxError(\"lambda cannot contain assignment\", c.c_filename, n.lineno);\r\n\t                }\r\n\t                else if (e.constructor !== Name) {\r\n\t                    throw new Sk.builtin.SyntaxError(\"keyword can't be an expression\", c.c_filename, n.lineno);\r\n\t                }\r\n\t                key = e.id;\r\n\t                forbiddenCheck(c, CHILD(ch, 0), key, n.lineno);\r\n\t                for (k = 0; k < nkeywords; ++k) {\r\n\t                    tmp = keywords[k].arg;\r\n\t                    if (tmp === key) {\r\n\t                        throw new Sk.builtin.SyntaxError(\"keyword argument repeated\", c.c_filename, n.lineno);\r\n\t                    }\r\n\t                }\r\n\t                keywords[nkeywords++] = new keyword(key, astForExpr(c, CHILD(ch, 2)));\r\n\t            }\r\n\t        }\r\n\t        else if (ch.type === TOK.T_STAR) {\r\n\t            vararg = astForExpr(c, CHILD(n, ++i));\r\n\t        }\r\n\t        else if (ch.type === TOK.T_DOUBLESTAR) {\r\n\t            kwarg = astForExpr(c, CHILD(n, ++i));\r\n\t        }\r\n\t    }\r\n\t    return new Call(func, args, keywords, vararg, kwarg, func.lineno, func.col_offset);\r\n\t}\r\n\r\n\tfunction astForTrailer (c, n, leftExpr) {\r\n\t    /* trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME \r\n\t     subscriptlist: subscript (',' subscript)* [',']\r\n\t     subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]\r\n\t     */\r\n\t    var e;\r\n\t    var elts;\r\n\t    var slc;\r\n\t    var j;\r\n\t    var slices;\r\n\t    var simple;\r\n\t    REQ(n, SYM.trailer);\r\n\t    if (CHILD(n, 0).type === TOK.T_LPAR) {\r\n\t        if (NCH(n) === 2) {\r\n\t            return new Call(leftExpr, [], [], null, null, n.lineno, n.col_offset);\r\n\t        }\r\n\t        else {\r\n\t            return astForCall(c, CHILD(n, 1), leftExpr);\r\n\t        }\r\n\t    }\r\n\t    else if (CHILD(n, 0).type === TOK.T_DOT) {\r\n\t        return new Attribute(leftExpr, strobj(CHILD(n, 1).value), Load, n.lineno, n.col_offset);\r\n\t    }\r\n\t    else {\r\n\t        REQ(CHILD(n, 0), TOK.T_LSQB);\r\n\t        REQ(CHILD(n, 2), TOK.T_RSQB);\r\n\t        n = CHILD(n, 1);\r\n\t        if (NCH(n) === 1) {\r\n\t            return new Subscript(leftExpr, astForSlice(c, CHILD(n, 0)), Load, n.lineno, n.col_offset);\r\n\t        }\r\n\t        else {\r\n\t            /* The grammar is ambiguous here. The ambiguity is resolved \r\n\t             by treating the sequence as a tuple literal if there are\r\n\t             no slice features.\r\n\t             */\r\n\t            simple = true;\r\n\t            slices = [];\r\n\t            for (j = 0; j < NCH(n); j += 2) {\r\n\t                slc = astForSlice(c, CHILD(n, j));\r\n\t                if (slc.constructor !== Index) {\r\n\t                    simple = false;\r\n\t                }\r\n\t                slices[j / 2] = slc;\r\n\t            }\r\n\t            if (!simple) {\r\n\t                return new Subscript(leftExpr, new ExtSlice(slices), Load, n.lineno, n.col_offset);\r\n\t            }\r\n\t            elts = [];\r\n\t            for (j = 0; j < slices.length; ++j) {\r\n\t                slc = slices[j];\r\n\t                goog.asserts.assert(slc.constructor === Index && slc.value !== null && slc.value !== undefined);\r\n\t                elts[j] = slc.value;\r\n\t            }\r\n\t            e = new Tuple(elts, Load, n.lineno, n.col_offset);\r\n\t            return new Subscript(leftExpr, new Index(e), Load, n.lineno, n.col_offset);\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tfunction astForFlowStmt (c, n) {\r\n\t    /*\r\n\t     flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt\r\n\t     | yield_stmt\r\n\t     break_stmt: 'break'\r\n\t     continue_stmt: 'continue'\r\n\t     return_stmt: 'return' [testlist]\r\n\t     yield_stmt: yield_expr\r\n\t     yield_expr: 'yield' testlist\r\n\t     raise_stmt: 'raise' [test [',' test [',' test]]]\r\n\t     */\r\n\t    var ch;\r\n\t    REQ(n, SYM.flow_stmt);\r\n\t    ch = CHILD(n, 0);\r\n\t    switch (ch.type) {\r\n\t        case SYM.break_stmt:\r\n\t            return new Break_(n.lineno, n.col_offset);\r\n\t        case SYM.continue_stmt:\r\n\t            return new Continue_(n.lineno, n.col_offset);\r\n\t        case SYM.yield_stmt:\r\n\t            return new Expr(astForExpr(c, CHILD(ch, 0)), n.lineno, n.col_offset);\r\n\t        case SYM.return_stmt:\r\n\t            if (NCH(ch) === 1) {\r\n\t                return new Return_(null, n.lineno, n.col_offset);\r\n\t            }\r\n\t            else {\r\n\t                return new Return_(astForTestlist(c, CHILD(ch, 1)), n.lineno, n.col_offset);\r\n\t            }\r\n\t            break;\r\n\t        case SYM.raise_stmt:\r\n\t            if (NCH(ch) === 1) {\r\n\t                return new Raise(null, null, null, n.lineno, n.col_offset);\r\n\t            }\r\n\t            else if (NCH(ch) === 2) {\r\n\t                return new Raise(astForExpr(c, CHILD(ch, 1)), null, null, n.lineno, n.col_offset);\r\n\t            }\r\n\t            else if (NCH(ch) === 4) {\r\n\t                return new Raise(\r\n\t                    astForExpr(c, CHILD(ch, 1)),\r\n\t                    astForExpr(c, CHILD(ch, 3)),\r\n\t                    null, n.lineno, n.col_offset);\r\n\t            }\r\n\t            else if (NCH(ch) === 6) {\r\n\t                return new Raise(\r\n\t                    astForExpr(c, CHILD(ch, 1)),\r\n\t                    astForExpr(c, CHILD(ch, 3)),\r\n\t                    astForExpr(c, CHILD(ch, 5)),\r\n\t                    n.lineno, n.col_offset);\r\n\t            }\r\n\t            break;\r\n\t        default:\r\n\t            goog.asserts.fail(\"unexpected flow_stmt\");\r\n\t    }\r\n\t    goog.asserts.fail(\"unhandled flow statement\");\r\n\t}\r\n\r\n\tfunction astForArguments (c, n) {\r\n\t    /* parameters: '(' [varargslist] ')'\r\n\t     varargslist: (fpdef ['=' test] ',')* ('*' NAME [',' '**' NAME]\r\n\t     | '**' NAME) | fpdef ['=' test] (',' fpdef ['=' test])* [',']\r\n\t     */\r\n\t    var parenthesized;\r\n\t    var id;\r\n\t    var complexArgs;\r\n\t    var k;\r\n\t    var j;\r\n\t    var i;\r\n\t    var foundDefault;\r\n\t    var defaults;\r\n\t    var args;\r\n\t    var ch;\r\n\t    var vararg = null;\r\n\t    var kwarg = null;\r\n\t    if (n.type === SYM.parameters) {\r\n\t        if (NCH(n) === 2) // () as arglist\r\n\t        {\r\n\t            return new arguments_([], null, null, []);\r\n\t        }\r\n\t        n = CHILD(n, 1);\r\n\t    }\r\n\t    REQ(n, SYM.varargslist);\r\n\r\n\t    args = [];\r\n\t    defaults = [];\r\n\r\n\t    /* fpdef: NAME | '(' fplist ')'\r\n\t     fplist: fpdef (',' fpdef)* [',']\r\n\t     */\r\n\t    foundDefault = false;\r\n\t    i = 0;\r\n\t    j = 0; // index for defaults\r\n\t    k = 0; // index for args\r\n\t    while (i < NCH(n)) {\r\n\t        ch = CHILD(n, i);\r\n\t        switch (ch.type) {\r\n\t            case SYM.fpdef:\r\n\t                complexArgs = 0;\r\n\t                parenthesized = 0;\r\n\t                handle_fpdef: while (true) {\r\n\t                    if (i + 1 < NCH(n) && CHILD(n, i + 1).type === TOK.T_EQUAL) {\r\n\t                        defaults[j++] = astForExpr(c, CHILD(n, i + 2));\r\n\t                        i += 2;\r\n\t                        foundDefault = true;\r\n\t                    }\r\n\t                    else if (foundDefault) {\r\n\t                        /* def f((x)=4): pass should raise an error.\r\n\t                         def f((x, (y))): pass will just incur the tuple unpacking warning. */\r\n\t                        if (parenthesized && !complexArgs) {\r\n\t                            throw new Sk.builtin.SyntaxError(\"parenthesized arg with default\", c.c_filename, n.lineno);\r\n\t                        }\r\n\t                        throw new Sk.builtin.SyntaxError(\"non-default argument follows default argument\", c.c_filename, n.lineno);\r\n\t                    }\r\n\r\n\t                    if (NCH(ch) === 3) {\r\n\t                        ch = CHILD(ch, 1);\r\n\t                        // def foo((x)): is not complex, special case.\r\n\t                        if (NCH(ch) !== 1) {\r\n\t                            throw new Sk.builtin.SyntaxError(\"tuple parameter unpacking has been removed\", c.c_filename, n.lineno);\r\n\t                        }\r\n\t                        else {\r\n\t                            /* def foo((x)): setup for checking NAME below. */\r\n\t                            /* Loop because there can be many parens and tuple\r\n\t                             unpacking mixed in. */\r\n\t                            parenthesized = true;\r\n\t                            ch = CHILD(ch, 0);\r\n\t                            goog.asserts.assert(ch.type === SYM.fpdef);\r\n\t                            continue handle_fpdef;\r\n\t                        }\r\n\t                    }\r\n\t                    if (CHILD(ch, 0).type === TOK.T_NAME) {\r\n\t                        forbiddenCheck(c, n, CHILD(ch, 0).value, n.lineno);\r\n\t                        id = strobj(CHILD(ch, 0).value);\r\n\t                        args[k++] = new Name(id, Param, ch.lineno, ch.col_offset);\r\n\t                    }\r\n\t                    i += 2;\r\n\t                    if (parenthesized) {\r\n\t                        throw new Sk.builtin.SyntaxError(\"parenthesized argument names are invalid\", c.c_filename, n.lineno);\r\n\t                    }\r\n\t                    break;\r\n\t                }\r\n\t                break;\r\n\t            case TOK.T_STAR:\r\n\t                forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.lineno);\r\n\t                vararg = strobj(CHILD(n, i + 1).value);\r\n\t                i += 3;\r\n\t                break;\r\n\t            case TOK.T_DOUBLESTAR:\r\n\t                forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.lineno);\r\n\t                kwarg = strobj(CHILD(n, i + 1).value);\r\n\t                i += 3;\r\n\t                break;\r\n\t            default:\r\n\t                goog.asserts.fail(\"unexpected node in varargslist\");\r\n\t        }\r\n\t    }\r\n\t    return new arguments_(args, vararg, kwarg, defaults);\r\n\t}\r\n\r\n\tfunction astForFuncdef (c, n, decoratorSeq) {\r\n\t    /* funcdef: 'def' NAME parameters ':' suite */\r\n\t    var body;\r\n\t    var args;\r\n\t    var name;\r\n\t    REQ(n, SYM.funcdef);\r\n\t    name = strobj(CHILD(n, 1).value);\r\n\t    forbiddenCheck(c, CHILD(n, 1), CHILD(n, 1).value, n.lineno);\r\n\t    args = astForArguments(c, CHILD(n, 2));\r\n\t    body = astForSuite(c, CHILD(n, 4));\r\n\t    return new FunctionDef(name, args, body, decoratorSeq, n.lineno, n.col_offset);\r\n\t}\r\n\r\n\tfunction astForClassBases (c, n) {\r\n\t    /* testlist: test (',' test)* [','] */\r\n\t    goog.asserts.assert(NCH(n) > 0);\r\n\t    REQ(n, SYM.testlist);\r\n\t    if (NCH(n) === 1) {\r\n\t        return [ astForExpr(c, CHILD(n, 0)) ];\r\n\t    }\r\n\t    return seqForTestlist(c, n);\r\n\t}\r\n\r\n\tfunction astForClassdef (c, n, decoratorSeq) {\r\n\t    /* classdef: 'class' NAME ['(' testlist ')'] ':' suite */\r\n\t    var s;\r\n\t    var bases;\r\n\t    var classname;\r\n\t    REQ(n, SYM.classdef);\r\n\t    forbiddenCheck(c, n, CHILD(n, 1).value, n.lineno);\r\n\t    classname = strobj(CHILD(n, 1).value);\r\n\t    if (NCH(n) === 4) {\r\n\t        return new ClassDef(classname, [], astForSuite(c, CHILD(n, 3)), decoratorSeq, n.lineno, n.col_offset);\r\n\t    }\r\n\t    if (CHILD(n, 3).type === TOK.T_RPAR) {\r\n\t        return new ClassDef(classname, [], astForSuite(c, CHILD(n, 5)), decoratorSeq, n.lineno, n.col_offset);\r\n\t    }\r\n\r\n\t    bases = astForClassBases(c, CHILD(n, 3));\r\n\t    s = astForSuite(c, CHILD(n, 6));\r\n\t    return new ClassDef(classname, bases, s, decoratorSeq, n.lineno, n.col_offset);\r\n\t}\r\n\r\n\tfunction astForLambdef (c, n) {\r\n\t    /* lambdef: 'lambda' [varargslist] ':' test */\r\n\t    var args;\r\n\t    var expression;\r\n\t    if (NCH(n) === 3) {\r\n\t        args = new arguments_([], null, null, []);\r\n\t        expression = astForExpr(c, CHILD(n, 2));\r\n\t    }\r\n\t    else {\r\n\t        args = astForArguments(c, CHILD(n, 1));\r\n\t        expression = astForExpr(c, CHILD(n, 3));\r\n\t    }\r\n\t    return new Lambda(args, expression, n.lineno, n.col_offset);\r\n\t}\r\n\r\n\tfunction astForComprehension(c, n) {\r\n\t    /* testlist_comp: test ( comp_for | (',' test)* [','] )\r\n\t       argument: test [comp_for] | test '=' test       # Really [keyword '='] test */\r\n\t    \r\n\t    var j;\r\n\t    var ifs;\r\n\t    var nifs;\r\n\t    var ge;\r\n\t    var expression;\r\n\t    var t;\r\n\t    var forch;\r\n\t    var i;\r\n\t    var ch;\r\n\t    var genexps;\r\n\t    var nfors;\r\n\t    var elt;\r\n\t    var comps;\r\n\t    var comp;\r\n\r\n\t    function countCompFors(c, n) {\r\n\t        var nfors = 0;\r\n\t        count_comp_for: while (true) {\r\n\t            nfors++;\r\n\t            REQ(n, SYM.comp_for);\r\n\t            if (NCH(n) === 5) {\r\n\t                n = CHILD(n, 4);\r\n\t            } else {\r\n\t                return nfors;\r\n\t            }\r\n\t            count_comp_iter: while (true) {\r\n\t                REQ(n, SYM.comp_iter);\r\n\t                n = CHILD(n, 0);\r\n\t                if (n.type === SYM.comp_for) {\r\n\t                    continue count_comp_for;\r\n\t                } else if (n.type === SYM.comp_if) {\r\n\t                    if (NCH(n) === 3) {\r\n\t                        n = CHILD(n, 2);\r\n\t                        continue count_comp_iter;\r\n\t                    } else {\r\n\t                        return nfors;\r\n\t                    }\r\n\t                }\r\n\t                break;\r\n\t            }\r\n\t            break;\r\n\t        }\r\n\t        goog.asserts.fail(\"logic error in countCompFors\");\r\n\t    }\r\n\r\n\t    function countCompIfs(c, n) {\r\n\t        var nifs = 0;\r\n\t        while (true) {\r\n\t            REQ(n, SYM.comp_iter);\r\n\t            if (CHILD(n, 0).type === SYM.comp_for) {\r\n\t                return nifs;\r\n\t            }\r\n\t            n = CHILD(n, 0);\r\n\t            REQ(n, SYM.comp_if);\r\n\t            nifs++;\r\n\t            if (NCH(n) == 2) {\r\n\t                return nifs;\r\n\t            }\r\n\t            n = CHILD(n, 2);\r\n\t        }\r\n\t    }\r\n\r\n\t    nfors = countCompFors(c, n);\r\n\t    comps = [];\r\n\t    for (i = 0; i < nfors; ++i) {\r\n\t        REQ(n, SYM.comp_for);\r\n\t        forch = CHILD(n, 1);\r\n\t        t = astForExprlist(c, forch, Store);\r\n\t        expression = astForExpr(c, CHILD(n, 3));\r\n\t        if (NCH(forch) === 1) {\r\n\t            comp = new comprehension(t[0], expression, []);\r\n\t        } else {\r\n\t            comp = new comprehension(new Tuple(t, Store, n.lineno, n.col_offset), expression, []);\r\n\t        }\r\n\t        if (NCH(n) === 5) {\r\n\t            n = CHILD(n, 4);\r\n\t            nifs = countCompIfs(c, n);\r\n\t            ifs = [];\r\n\t            for (j = 0; j < nifs; ++j) {\r\n\t                REQ(n, SYM.comp_iter);\r\n\t                n = CHILD(n, 0);\r\n\t                REQ(n, SYM.comp_if);\r\n\t                expression = astForExpr(c, CHILD(n, 1));\r\n\t                ifs[j] = expression;\r\n\t                if (NCH(n) === 3) {\r\n\t                    n = CHILD(n, 2);\r\n\t                }\r\n\t            }\r\n\t            if (n.type === SYM.comp_iter) {\r\n\t                n = CHILD(n, 0);\r\n\t            }\r\n\t            comp.ifs = ifs;\r\n\t        }\r\n\t        comps[i] = comp;\r\n\t    }\r\n\t    return comps;\r\n\t}\r\n\r\n\tfunction astForIterComp(c, n, type) {\r\n\t    var elt, comps;\r\n\t    goog.asserts.assert(NCH(n) > 1);\r\n\t    elt = astForExpr(c, CHILD(n, 0));\r\n\t    comps = astForComprehension(c, CHILD(n, 1));\r\n\t    if (type === COMP_GENEXP) {\r\n\t        return new GeneratorExp(elt, comps, n.lineno, n.col_offset);\r\n\t    } else if (type === COMP_SETCOMP) {\r\n\t        return new SetComp(elt, comps, n.lineno, n.col_offset);\r\n\t    }\r\n\t}\r\n\r\n\tfunction astForDictComp(c, n) {\r\n\t    var key, value;\r\n\t    var comps = [];\r\n\t    goog.asserts.assert(NCH(n) > 3);\r\n\t    REQ(CHILD(n, 1), TOK.T_COLON);\r\n\t    key = astForExpr(c, CHILD(n, 0));\r\n\t    value = astForExpr(c, CHILD(n, 2));\r\n\t    comps = astForComprehension(c, CHILD(n, 3));\r\n\t    return new DictComp(key, value, comps, n.lineno, n.col_offset);\r\n\t}\r\n\r\n\tfunction astForGenExpr(c, n) {\r\n\t    goog.asserts.assert(n.type === SYM.testlist_comp || n.type === SYM.argument);\r\n\t    return astForIterComp(c, n, COMP_GENEXP);\r\n\t}\r\n\r\n\tfunction astForSetComp(c, n) {\r\n\t    goog.asserts.assert(n.type === SYM.dictorsetmaker);\r\n\t    return astForIterComp(c, n, COMP_SETCOMP);\r\n\t}\r\n\r\n\tfunction astForWhileStmt (c, n) {\r\n\t    /* while_stmt: 'while' test ':' suite ['else' ':' suite] */\r\n\t    REQ(n, SYM.while_stmt);\r\n\t    if (NCH(n) === 4) {\r\n\t        return new While_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.lineno, n.col_offset);\r\n\t    }\r\n\t    else if (NCH(n) === 7) {\r\n\t        return new While_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.lineno, n.col_offset);\r\n\t    }\r\n\t    goog.asserts.fail(\"wrong number of tokens for 'while' stmt\");\r\n\t}\r\n\r\n\tfunction astForAugassign (c, n) {\r\n\t    REQ(n, SYM.augassign);\r\n\t    n = CHILD(n, 0);\r\n\t    switch (n.value.charAt(0)) {\r\n\t        case \"+\":\r\n\t            return Add;\r\n\t        case \"-\":\r\n\t            return Sub;\r\n\t        case \"/\":\r\n\t            if (n.value.charAt(1) === \"/\") {\r\n\t                return FloorDiv;\r\n\t            }\r\n\t            return Div;\r\n\t        case \"%\":\r\n\t            return Mod;\r\n\t        case \"<\":\r\n\t            return LShift;\r\n\t        case \">\":\r\n\t            return RShift;\r\n\t        case \"&\":\r\n\t            return BitAnd;\r\n\t        case \"^\":\r\n\t            return BitXor;\r\n\t        case \"|\":\r\n\t            return BitOr;\r\n\t        case \"*\":\r\n\t            if (n.value.charAt(1) === \"*\") {\r\n\t                return Pow;\r\n\t            }\r\n\t            return Mult;\r\n\t        default:\r\n\t            goog.asserts.fail(\"invalid augassign\");\r\n\t    }\r\n\t}\r\n\r\n\tfunction astForBinop (c, n) {\r\n\t    /* Must account for a sequence of expressions.\r\n\t     How should A op B op C by represented?\r\n\t     BinOp(BinOp(A, op, B), op, C).\r\n\t     */\r\n\t    var tmp;\r\n\t    var newoperator;\r\n\t    var nextOper;\r\n\t    var i;\r\n\t    var result = new BinOp(\r\n\t        astForExpr(c, CHILD(n, 0)),\r\n\t        getOperator(CHILD(n, 1)),\r\n\t        astForExpr(c, CHILD(n, 2)),\r\n\t        n.lineno, n.col_offset);\r\n\t    var nops = (NCH(n) - 1) / 2;\r\n\t    for (i = 1; i < nops; ++i) {\r\n\t        nextOper = CHILD(n, i * 2 + 1);\r\n\t        newoperator = getOperator(nextOper);\r\n\t        tmp = astForExpr(c, CHILD(n, i * 2 + 2));\r\n\t        result = new BinOp(result, newoperator, tmp, nextOper.lineno, nextOper.col_offset);\r\n\t    }\r\n\t    return result;\r\n\r\n\t}\r\n\r\n\r\n\tfunction astForTestlist(c, n) {\r\n\t    /* this doesn't show up in Grammar.txt never did: testlist_gexp: test (',' test)* [','] */\r\n\t    /* testlist_comp: test (',' test)* [','] */\r\n\t    /* testlist: test (',' test)* [','] */\r\n\t    /* testlist_safe: test (',' test)+ [','] */\r\n\t    /* testlist1: test (',' test)* */\r\n\t    goog.asserts.assert(NCH(n) > 0);\r\n\t    if (n.type === SYM.testlist_comp) {\r\n\t        if (NCH(n) > 1) {\r\n\t            goog.asserts.assert(CHILD(n, 1).type !== SYM.comp_for);\r\n\t        }\r\n\t    }\r\n\t    else {\r\n\t        goog.asserts.assert(n.type === SYM.testlist || n.type === SYM.testlist_safe || n.type === SYM.testlist1);\r\n\t    }\r\n\r\n\t    if (NCH(n) === 1) {\r\n\t        return astForExpr(c, CHILD(n, 0));\r\n\t    }\r\n\t    else {\r\n\t        return new Tuple(seqForTestlist(c, n), Load, n.lineno, n.col_offset);\r\n\t    }\r\n\r\n\t}\r\n\r\n\tfunction astForExprStmt (c, n) {\r\n\t    var expression;\r\n\t    var value;\r\n\t    var e;\r\n\t    var i;\r\n\t    var targets;\r\n\t    var expr2;\r\n\t    var varName;\r\n\t    var expr1;\r\n\t    var ch;\r\n\t    REQ(n, SYM.expr_stmt);\r\n\t    /* expr_stmt: testlist (augassign (yield_expr|testlist) \r\n\t     | ('=' (yield_expr|testlist))*)\r\n\t     testlist: test (',' test)* [',']\r\n\t     augassign: '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^='\r\n\t     | '<<=' | '>>=' | '**=' | '//='\r\n\t     test: ... here starts the operator precendence dance\r\n\t     */\r\n\t    if (NCH(n) === 1) {\r\n\t        return new Expr(astForTestlist(c, CHILD(n, 0)), n.lineno, n.col_offset);\r\n\t    }\r\n\t    else if (CHILD(n, 1).type === SYM.augassign) {\r\n\t        ch = CHILD(n, 0);\r\n\t        expr1 = astForTestlist(c, ch);\r\n\t        switch (expr1.constructor) {\r\n\t            case GeneratorExp:\r\n\t                throw new Sk.builtin.SyntaxError(\"augmented assignment to generator expression not possible\", c.c_filename, n.lineno);\r\n\t            case Yield:\r\n\t                throw new Sk.builtin.SyntaxError(\"augmented assignment to yield expression not possible\", c.c_filename, n.lineno);\r\n\t            case Name:\r\n\t                varName = expr1.id;\r\n\t                forbiddenCheck(c, ch, varName, n.lineno);\r\n\t                break;\r\n\t            case Attribute:\r\n\t            case Subscript:\r\n\t                break;\r\n\t            default:\r\n\t                throw new Sk.builtin.SyntaxError(\"illegal expression for augmented assignment\", c.c_filename, n.lineno);\r\n\t        }\r\n\t        setContext(c, expr1, Store, ch);\r\n\r\n\t        ch = CHILD(n, 2);\r\n\t        if (ch.type === SYM.testlist) {\r\n\t            expr2 = astForTestlist(c, ch);\r\n\t        }\r\n\t        else {\r\n\t            expr2 = astForExpr(c, ch);\r\n\t        }\r\n\r\n\t        return new AugAssign(expr1, astForAugassign(c, CHILD(n, 1)), expr2, n.lineno, n.col_offset);\r\n\t    }\r\n\t    else {\r\n\t        // normal assignment\r\n\t        REQ(CHILD(n, 1), TOK.T_EQUAL);\r\n\t        targets = [];\r\n\t        for (i = 0; i < NCH(n) - 2; i += 2) {\r\n\t            ch = CHILD(n, i);\r\n\t            if (ch.type === SYM.yield_expr) {\r\n\t                throw new Sk.builtin.SyntaxError(\"assignment to yield expression not possible\", c.c_filename, n.lineno);\r\n\t            }\r\n\t            e = astForTestlist(c, ch);\r\n\t            setContext(c, e, Store, CHILD(n, i));\r\n\t            targets[i / 2] = e;\r\n\t        }\r\n\t        value = CHILD(n, NCH(n) - 1);\r\n\t        if (value.type === SYM.testlist) {\r\n\t            expression = astForTestlist(c, value);\r\n\t        }\r\n\t        else {\r\n\t            expression = astForExpr(c, value);\r\n\t        }\r\n\t        return new Assign(targets, expression, n.lineno, n.col_offset);\r\n\t    }\r\n\t}\r\n\r\n\tfunction astForIfexpr (c, n) {\r\n\t    /* test: or_test 'if' or_test 'else' test */\r\n\t    goog.asserts.assert(NCH(n) === 5);\r\n\t    return new IfExp(\r\n\t        astForExpr(c, CHILD(n, 2)),\r\n\t        astForExpr(c, CHILD(n, 0)),\r\n\t        astForExpr(c, CHILD(n, 4)),\r\n\t        n.lineno, n.col_offset);\r\n\t}\r\n\r\n\t/**\r\n\t * s is a python-style string literal, including quote characters and u/r/b\r\n\t * prefixes. Returns decoded string object.\r\n\t */\r\n\tfunction parsestr (c, s) {\r\n\t    var encodeUtf8 = function (s) {\r\n\t        return unescape(encodeURIComponent(s));\r\n\t    };\r\n\t    var decodeUtf8 = function (s) {\r\n\t        return decodeURIComponent(escape(s));\r\n\t    };\r\n\t    var decodeEscape = function (s, quote) {\r\n\t        var d3;\r\n\t        var d2;\r\n\t        var d1;\r\n\t        var d0;\r\n\t        var c;\r\n\t        var i;\r\n\t        var len = s.length;\r\n\t        var ret = \"\";\r\n\t        for (i = 0; i < len; ++i) {\r\n\t            c = s.charAt(i);\r\n\t            if (c === \"\\\\\") {\r\n\t                ++i;\r\n\t                c = s.charAt(i);\r\n\t                if (c === \"n\") {\r\n\t                    ret += \"\\n\";\r\n\t                }\r\n\t                else if (c === \"\\\\\") {\r\n\t                    ret += \"\\\\\";\r\n\t                }\r\n\t                else if (c === \"t\") {\r\n\t                    ret += \"\\t\";\r\n\t                }\r\n\t                else if (c === \"r\") {\r\n\t                    ret += \"\\r\";\r\n\t                }\r\n\t                else if (c === \"b\") {\r\n\t                    ret += \"\\b\";\r\n\t                }\r\n\t                else if (c === \"f\") {\r\n\t                    ret += \"\\f\";\r\n\t                }\r\n\t                else if (c === \"v\") {\r\n\t                    ret += \"\\v\";\r\n\t                }\r\n\t                else if (c === \"0\") {\r\n\t                    ret += \"\\0\";\r\n\t                }\r\n\t                else if (c === '\"') {\r\n\t                    ret += '\"';\r\n\t                }\r\n\t                else if (c === '\\'') {\r\n\t                    ret += '\\'';\r\n\t                }\r\n\t                else if (c === \"\\n\") /* escaped newline, join lines */ {\r\n\t                }\r\n\t                else if (c === \"x\") {\r\n\t                    d0 = s.charAt(++i);\r\n\t                    d1 = s.charAt(++i);\r\n\t                    ret += String.fromCharCode(parseInt(d0 + d1, 16));\r\n\t                }\r\n\t                else if (c === \"u\" || c === \"U\") {\r\n\t                    d0 = s.charAt(++i);\r\n\t                    d1 = s.charAt(++i);\r\n\t                    d2 = s.charAt(++i);\r\n\t                    d3 = s.charAt(++i);\r\n\t                    ret += String.fromCharCode(parseInt(d0 + d1, 16), parseInt(d2 + d3, 16));\r\n\t                }\r\n\t                else {\r\n\t                    // Leave it alone\r\n\t                    ret += \"\\\\\" + c;\r\n\t                    // goog.asserts.fail(\"unhandled escape: '\" + c.charCodeAt(0) + \"'\");\r\n\t                }\r\n\t            }\r\n\t            else {\r\n\t                ret += c;\r\n\t            }\r\n\t        }\r\n\t        return ret;\r\n\t    };\r\n\r\n\t    //print(\"parsestr\", s);\r\n\r\n\t    var quote = s.charAt(0);\r\n\t    var rawmode = false;\r\n\t    var unicode = false;\r\n\r\n\t    // treats every sequence as unicodes even if they are not treated with uU prefix\r\n\t    // kinda hacking though working for most purposes\r\n\t    if((c.c_flags & Parser.CO_FUTURE_UNICODE_LITERALS || Sk.python3 === true)) {\r\n\t        unicode = true;\r\n\t    }\r\n\r\n\t    if (quote === \"u\" || quote === \"U\") {\r\n\t        s = s.substr(1);\r\n\t        quote = s.charAt(0);\r\n\t        unicode = true;\r\n\t    }\r\n\t    else if (quote === \"r\" || quote === \"R\") {\r\n\t        s = s.substr(1);\r\n\t        quote = s.charAt(0);\r\n\t        rawmode = true;\r\n\t    }\r\n\t    goog.asserts.assert(quote !== \"b\" && quote !== \"B\", \"todo; haven't done b'' strings yet\");\r\n\r\n\t    goog.asserts.assert(quote === \"'\" || quote === '\"' && s.charAt(s.length - 1) === quote);\r\n\t    s = s.substr(1, s.length - 2);\r\n\t    if (unicode) {\r\n\t        s = encodeUtf8(s);\r\n\t    }\r\n\r\n\t    if (s.length >= 4 && s.charAt(0) === quote && s.charAt(1) === quote) {\r\n\t        goog.asserts.assert(s.charAt(s.length - 1) === quote && s.charAt(s.length - 2) === quote);\r\n\t        s = s.substr(2, s.length - 4);\r\n\t    }\r\n\r\n\t    if (rawmode || s.indexOf(\"\\\\\") === -1) {\r\n\t        return strobj(decodeUtf8(s));\r\n\t    }\r\n\t    return strobj(decodeEscape(s, quote));\r\n\t}\r\n\r\n\tfunction parsestrplus (c, n) {\r\n\t    var i;\r\n\t    var ret;\r\n\t    REQ(CHILD(n, 0), TOK.T_STRING);\r\n\t    ret = new Sk.builtin.str(\"\");\r\n\t    for (i = 0; i < NCH(n); ++i) {\r\n\t        try {\r\n\t            ret = ret.sq$concat(parsestr(c, CHILD(n, i).value));\r\n\t        } catch (x) {\r\n\t            throw new Sk.builtin.SyntaxError(\"invalid string (possibly contains a unicode character)\", c.c_filename, CHILD(n, i).lineno);\r\n\t        }\r\n\t    }\r\n\t    return ret;\r\n\t}\r\n\r\n\tfunction parsenumber (c, s, lineno) {\r\n\t    var neg;\r\n\t    var val;\r\n\t    var tmp;\r\n\t    var end = s.charAt(s.length - 1);\r\n\r\n\t    // call internal complex type constructor for complex strings\r\n\t    if (end === \"j\" || end === \"J\") {\r\n\t        return Sk.builtin.complex.complex_subtype_from_string(s);\r\n\t    }\r\n\r\n\t    // Handle longs\r\n\t    if (end === \"l\" || end === \"L\") {\r\n\t        return Sk.longFromStr(s.substr(0, s.length - 1), 0);\r\n\t    }\r\n\r\n\t    // todo; we don't currently distinguish between int and float so\r\n\t    // str is wrong for these.\r\n\t    if (s.indexOf(\".\") !== -1) {\r\n\t        return new Sk.builtin.float_(parseFloat(s));\r\n\t    }\r\n\r\n\t    // Handle integers of various bases\r\n\t    tmp = s;\r\n\t    neg = false;\r\n\t    if (s.charAt(0) === \"-\") {\r\n\t        tmp = s.substr(1);\r\n\t        neg = true;\r\n\t    }\r\n\r\n\t    if (tmp.charAt(0) === \"0\" && (tmp.charAt(1) === \"x\" || tmp.charAt(1) === \"X\")) {\r\n\t        // Hex\r\n\t        tmp = tmp.substring(2);\r\n\t        val = parseInt(tmp, 16);\r\n\t    } else if ((s.indexOf(\"e\") !== -1) || (s.indexOf(\"E\") !== -1)) {\r\n\t        // Float with exponent (needed to make sure e/E wasn't hex first)\r\n\t        return new Sk.builtin.float_(parseFloat(s));\r\n\t    } else if (tmp.charAt(0) === \"0\" && (tmp.charAt(1) === \"b\" || tmp.charAt(1) === \"B\")) {\r\n\t        // Binary\r\n\t        tmp = tmp.substring(2);\r\n\t        val = parseInt(tmp, 2);\r\n\t    } else if (tmp.charAt(0) === \"0\") {\r\n\t        if (tmp === \"0\") {\r\n\t            // Zero\r\n\t            val = 0;\r\n\t        } else {\r\n\t            // Octal\r\n\t            tmp = tmp.substring(1);\r\n\t            if ((tmp.charAt(0) === \"o\") || (tmp.charAt(0) === \"O\")) {\r\n\t                tmp = tmp.substring(1);\r\n\t            }\r\n\t            val = parseInt(tmp, 8);\r\n\t        }\r\n\t    }\r\n\t    else {\r\n\t        // Decimal\r\n\t        val = parseInt(tmp, 10);\r\n\t    }\r\n\r\n\t    // Convert to long\r\n\t    if (val > Sk.builtin.int_.threshold$ &&\r\n\t        Math.floor(val) === val &&\r\n\t        (s.indexOf(\"e\") === -1 && s.indexOf(\"E\") === -1)) {\r\n\t        return Sk.longFromStr(s, 0);\r\n\t    }\r\n\r\n\t    // Small enough, return parsed number\r\n\t    if (neg) {\r\n\t        return new Sk.builtin.int_(-val);\r\n\t    } else {\r\n\t        return new Sk.builtin.int_(val);\r\n\t    }\r\n\t}\r\n\r\n\tfunction astForSlice (c, n) {\r\n\t    var n2;\r\n\t    var step;\r\n\t    var upper;\r\n\t    var lower;\r\n\t    var ch;\r\n\t    REQ(n, SYM.subscript);\r\n\r\n\t    /*\r\n\t     subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]\r\n\t     sliceop: ':' [test]\r\n\t     */\r\n\t    ch = CHILD(n, 0);\r\n\t    lower = null;\r\n\t    upper = null;\r\n\t    step = null;\r\n\t    if (ch.type === TOK.T_DOT) {\r\n\t        return new Ellipsis();\r\n\t    }\r\n\t    if (NCH(n) === 1 && ch.type === SYM.test) {\r\n\t        return new Index(astForExpr(c, ch));\r\n\t    }\r\n\t    if (ch.type === SYM.test) {\r\n\t        lower = astForExpr(c, ch);\r\n\t    }\r\n\t    if (ch.type === TOK.T_COLON) {\r\n\t        if (NCH(n) > 1) {\r\n\t            n2 = CHILD(n, 1);\r\n\t            if (n2.type === SYM.test) {\r\n\t                upper = astForExpr(c, n2);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    else if (NCH(n) > 2) {\r\n\t        n2 = CHILD(n, 2);\r\n\t        if (n2.type === SYM.test) {\r\n\t            upper = astForExpr(c, n2);\r\n\t        }\r\n\t    }\r\n\r\n\t    ch = CHILD(n, NCH(n) - 1);\r\n\t    if (ch.type === SYM.sliceop) {\r\n\t        if (NCH(ch) === 1) {\r\n\t            ch = CHILD(ch, 0);\r\n\t            step = new Name(strobj(\"None\"), Load, ch.lineno, ch.col_offset);\r\n\t        }\r\n\t        else {\r\n\t            ch = CHILD(ch, 1);\r\n\t            if (ch.type === SYM.test) {\r\n\t                step = astForExpr(c, ch);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    return new Slice(lower, upper, step);\r\n\t}\r\n\r\n\tfunction astForAtom(c, n) {\r\n\t    /* atom: ('(' [yield_expr|testlist_comp] ')' |\r\n\t       '[' [listmaker] ']' |\r\n\t       '{' [dictorsetmaker] '}' |\r\n\t       '`' testlist1 '`' |\r\n\t       NAME | NUMBER | STRING+)\r\n\t    */\r\n\t    var i;\r\n\t    var values;\r\n\t    var keys;\r\n\t    var size;\r\n\t    var ch = CHILD(n, 0);\r\n\t    var elts;\r\n\t    switch (ch.type) {\r\n\t        case TOK.T_NAME:\r\n\t            // All names start in Load context, but may be changed later\r\n\t            return new Name(strobj(ch.value), Load, n.lineno, n.col_offset);\r\n\t        case TOK.T_STRING:\r\n\t            return new Str(parsestrplus(c, n), n.lineno, n.col_offset);\r\n\t        case TOK.T_NUMBER:\r\n\t            return new Num(parsenumber(c, ch.value, n.lineno), n.lineno, n.col_offset);\r\n\t        case TOK.T_LPAR: // various uses for parens\r\n\t            ch = CHILD(n, 1);\r\n\t            if (ch.type === TOK.T_RPAR) {\r\n\t                return new Tuple([], Load, n.lineno, n.col_offset);\r\n\t            }\r\n\t            if (ch.type === SYM.yield_expr) {\r\n\t                return astForExpr(c, ch);\r\n\t            }\r\n\t            //            if (NCH(ch) > 1 && CHILD(ch, 1).type === SYM.comp_for) {\r\n\t            //                return astForComprehension(c, ch);\r\n\t            //            }\r\n\t            return astForTestlistComp(c, ch);\r\n\t        case TOK.T_LSQB: // list or listcomp\r\n\t            ch = CHILD(n, 1);\r\n\t            if (ch.type === TOK.T_RSQB) {\r\n\t                return new List([], Load, n.lineno, n.col_offset);\r\n\t            }\r\n\t            REQ(ch, SYM.listmaker);\r\n\t            if (NCH(ch) === 1 || CHILD(ch, 1).type === TOK.T_COMMA) {\r\n\t                return new List(seqForTestlist(c, ch), Load, n.lineno, n.col_offset);\r\n\t            } \r\n\t            return astForListcomp(c, ch);\r\n\t            \r\n\t        case TOK.T_LBRACE:\r\n\t            /* dictorsetmaker: \r\n\t             *     (test ':' test (comp_for : (',' test ':' test)* [','])) |\r\n\t             *     (test (comp_for | (',' test)* [',']))\r\n\t             */\r\n\t            keys = [];\r\n\t            values = [];\r\n\t            ch = CHILD(n, 1);\r\n\t            if (n.type === TOK.T_RBRACE) {\r\n\t                //it's an empty dict\r\n\t                return new Dict([], null, n.lineno, n.col_offset);\r\n\t            } \r\n\t            else if (NCH(ch) === 1 || (NCH(ch) !== 0 && CHILD(ch, 1).type === TOK.T_COMMA)) {\r\n\t                //it's a simple set\r\n\t                elts = [];\r\n\t                size = Math.floor((NCH(ch) + 1) / 2);\r\n\t                for (i = 0; i < NCH(ch); i += 2) {\r\n\t                    var expression = astForExpr(c, CHILD(ch, i));\r\n\t                    elts[i / 2] = expression;\r\n\t                }\r\n\t                return new Set(elts, n.lineno, n.col_offset);\r\n\t            } \r\n\t            else if (NCH(ch) !== 0 && CHILD(ch, 1).type == SYM.comp_for) {\r\n\t                //it's a set comprehension\r\n\t                return astForSetComp(c, ch);\r\n\t            } \r\n\t            else if (NCH(ch) > 3 && CHILD(ch, 3).type === SYM.comp_for) {\r\n\t                //it's a dict compr. I think.\r\n\t                return astForDictComp(c, ch);\r\n\t            } \r\n\t            else {\r\n\t                size = Math.floor((NCH(ch) + 1) / 4); // + 1 for no trailing comma case\r\n\t                for (i = 0; i < NCH(ch); i += 4) {\r\n\t                    keys[i / 4] = astForExpr(c, CHILD(ch, i));\r\n\t                    values[i / 4] = astForExpr(c, CHILD(ch, i + 2));\r\n\t                }\r\n\t                return new Dict(keys, values, n.lineno, n.col_offset);\r\n\t            }\r\n\t        case TOK.T_BACKQUOTE:\r\n\t            //throw new Sk.builtin.SyntaxError(\"backquote not supported, use repr()\", c.c_filename, n.lineno);\r\n\t            return new Repr(astForTestlist(c, CHILD(n, 1)), n.lineno, n.col_offset);\r\n\t        default:\r\n\t            goog.asserts.fail(\"unhandled atom\", ch.type);\r\n\r\n\t    }\r\n\t}\r\n\r\n\tfunction astForPower (c, n) {\r\n\t    /* power: atom trailer* ('**' factor)*\r\n\t     */\r\n\t    var f;\r\n\t    var tmp;\r\n\t    var ch;\r\n\t    var i;\r\n\t    var e;\r\n\t    REQ(n, SYM.power);\r\n\t    e = astForAtom(c, CHILD(n, 0));\r\n\t    if (NCH(n) === 1) {\r\n\t        return e;\r\n\t    }\r\n\t    for (i = 1; i < NCH(n); ++i) {\r\n\t        ch = CHILD(n, i);\r\n\t        if (ch.type !== SYM.trailer) {\r\n\t            break;\r\n\t        }\r\n\t        tmp = astForTrailer(c, ch, e);\r\n\t        tmp.lineno = e.lineno;\r\n\t        tmp.col_offset = e.col_offset;\r\n\t        e = tmp;\r\n\t    }\r\n\t    if (CHILD(n, NCH(n) - 1).type === SYM.factor) {\r\n\t        f = astForExpr(c, CHILD(n, NCH(n) - 1));\r\n\t        e = new BinOp(e, Pow, f, n.lineno, n.col_offset);\r\n\t    }\r\n\t    return e;\r\n\t}\r\n\r\n\tfunction astForExpr (c, n) {\r\n\t    /* handle the full range of simple expressions\r\n\t     test: or_test ['if' or_test 'else' test] | lambdef\r\n\t     or_test: and_test ('or' and_test)*\r\n\t     and_test: not_test ('and' not_test)*\r\n\t     not_test: 'not' not_test | comparison\r\n\t     comparison: expr (comp_op expr)*\r\n\t     expr: xor_expr ('|' xor_expr)*\r\n\t     xor_expr: and_expr ('^' and_expr)*\r\n\t     and_expr: shift_expr ('&' shift_expr)*\r\n\t     shift_expr: arith_expr (('<<'|'>>') arith_expr)*\r\n\t     arith_expr: term (('+'|'-') term)*\r\n\t     term: factor (('*'|'/'|'%'|'//') factor)*\r\n\t     factor: ('+'|'-'|'~') factor | power\r\n\t     power: atom trailer* ('**' factor)*\r\n\r\n\t     As well as modified versions that exist for backward compatibility,\r\n\t     to explicitly allow:\r\n\t     [ x for x in lambda: 0, lambda: 1 ]\r\n\t     (which would be ambiguous without these extra rules)\r\n\r\n\t     old_test: or_test | old_lambdef\r\n\t     old_lambdef: 'lambda' [vararglist] ':' old_test\r\n\r\n\t     */\r\n\r\n\t    var exp;\r\n\t    var cmps;\r\n\t    var ops;\r\n\t    var i;\r\n\t    var seq;\r\n\t    LOOP: while (true) {\r\n\t        switch (n.type) {\r\n\t            case SYM.test:\r\n\t            case SYM.old_test:\r\n\t                if (CHILD(n, 0).type === SYM.lambdef || CHILD(n, 0).type === SYM.old_lambdef) {\r\n\t                    return astForLambdef(c, CHILD(n, 0));\r\n\t                }\r\n\t                else if (NCH(n) > 1) {\r\n\t                    return astForIfexpr(c, n);\r\n\t                }\r\n\t            // fallthrough\r\n\t            case SYM.or_test:\r\n\t            case SYM.and_test:\r\n\t                if (NCH(n) === 1) {\r\n\t                    n = CHILD(n, 0);\r\n\t                    continue LOOP;\r\n\t                }\r\n\t                seq = [];\r\n\t                for (i = 0; i < NCH(n); i += 2) {\r\n\t                    seq[i / 2] = astForExpr(c, CHILD(n, i));\r\n\t                }\r\n\t                if (CHILD(n, 1).value === \"and\") {\r\n\t                    return new BoolOp(And, seq, n.lineno, n.col_offset);\r\n\t                }\r\n\t                goog.asserts.assert(CHILD(n, 1).value === \"or\");\r\n\t                return new BoolOp(Or, seq, n.lineno, n.col_offset);\r\n\t            case SYM.not_test:\r\n\t                if (NCH(n) === 1) {\r\n\t                    n = CHILD(n, 0);\r\n\t                    continue LOOP;\r\n\t                }\r\n\t                else {\r\n\t                    return new UnaryOp(Not, astForExpr(c, CHILD(n, 1)), n.lineno, n.col_offset);\r\n\t                }\r\n\t                break;\r\n\t            case SYM.comparison:\r\n\t                if (NCH(n) === 1) {\r\n\t                    n = CHILD(n, 0);\r\n\t                    continue LOOP;\r\n\t                }\r\n\t                else {\r\n\t                    ops = [];\r\n\t                    cmps = [];\r\n\t                    for (i = 1; i < NCH(n); i += 2) {\r\n\t                        ops[(i - 1) / 2] = astForCompOp(c, CHILD(n, i));\r\n\t                        cmps[(i - 1) / 2] = astForExpr(c, CHILD(n, i + 1));\r\n\t                    }\r\n\t                    return new Compare(astForExpr(c, CHILD(n, 0)), ops, cmps, n.lineno, n.col_offset);\r\n\t                }\r\n\t                break;\r\n\t            case SYM.expr:\r\n\t            case SYM.xor_expr:\r\n\t            case SYM.and_expr:\r\n\t            case SYM.shift_expr:\r\n\t            case SYM.arith_expr:\r\n\t            case SYM.term:\r\n\t                if (NCH(n) === 1) {\r\n\t                    n = CHILD(n, 0);\r\n\t                    continue LOOP;\r\n\t                }\r\n\t                return astForBinop(c, n);\r\n\t            case SYM.yield_expr:\r\n\t                exp = null;\r\n\t                if (NCH(n) === 2) {\r\n\t                    exp = astForTestlist(c, CHILD(n, 1));\r\n\t                }\r\n\t                return new Yield(exp, n.lineno, n.col_offset);\r\n\t            case SYM.factor:\r\n\t                if (NCH(n) === 1) {\r\n\t                    n = CHILD(n, 0);\r\n\t                    continue LOOP;\r\n\t                }\r\n\t                return astForFactor(c, n);\r\n\t            case SYM.power:\r\n\t                return astForPower(c, n);\r\n\t            default:\r\n\t                goog.asserts.fail(\"unhandled expr\", \"n.type: %d\", n.type);\r\n\t        }\r\n\t        break;\r\n\t    }\r\n\t}\r\n\r\n\tfunction astForPrintStmt (c, n) {\r\n\t    /* print_stmt: 'print' ( [ test (',' test)* [','] ]\r\n\t     | '>>' test [ (',' test)+ [','] ] )\r\n\t     */\r\n\t    var nl;\r\n\t    var i, j;\r\n\t    var seq;\r\n\t    var start = 1;\r\n\t    var dest = null;\r\n\t    REQ(n, SYM.print_stmt);\r\n\t    if (NCH(n) >= 2 && CHILD(n, 1).type === TOK.T_RIGHTSHIFT) {\r\n\t        dest = astForExpr(c, CHILD(n, 2));\r\n\t        start = 4;\r\n\t    }\r\n\t    seq = [];\r\n\t    for (i = start, j = 0; i < NCH(n); i += 2, ++j) {\r\n\t        seq[j] = astForExpr(c, CHILD(n, i));\r\n\t    }\r\n\t    nl = (CHILD(n, NCH(n) - 1)).type === TOK.T_COMMA ? false : true;\r\n\t    return new Print(dest, seq, nl, n.lineno, n.col_offset);\r\n\t}\r\n\r\n\tfunction astForStmt (c, n) {\r\n\t    var ch;\r\n\t    if (n.type === SYM.stmt) {\r\n\t        goog.asserts.assert(NCH(n) === 1);\r\n\t        n = CHILD(n, 0);\r\n\t    }\r\n\t    if (n.type === SYM.simple_stmt) {\r\n\t        goog.asserts.assert(numStmts(n) === 1);\r\n\t        n = CHILD(n, 0);\r\n\t    }\r\n\t    if (n.type === SYM.small_stmt) {\r\n\t        REQ(n, SYM.small_stmt);\r\n\t        n = CHILD(n, 0);\r\n\t        /* small_stmt: expr_stmt | print_stmt  | del_stmt | pass_stmt\r\n\t         | flow_stmt | import_stmt | global_stmt | exec_stmt\r\n\t         | assert_stmt\r\n\t         */\r\n\t        switch (n.type) {\r\n\t            case SYM.expr_stmt:\r\n\t                return astForExprStmt(c, n);\r\n\t            case SYM.print_stmt:\r\n\t                return astForPrintStmt(c, n);\r\n\t            case SYM.del_stmt:\r\n\t                return astForDelStmt(c, n);\r\n\t            case SYM.pass_stmt:\r\n\t                return new Pass(n.lineno, n.col_offset);\r\n\t            case SYM.flow_stmt:\r\n\t                return astForFlowStmt(c, n);\r\n\t            case SYM.import_stmt:\r\n\t                return astForImportStmt(c, n);\r\n\t            case SYM.global_stmt:\r\n\t                return astForGlobalStmt(c, n);\r\n\t            case SYM.exec_stmt:\r\n\t                return astForExecStmt(c, n);\r\n\t            case SYM.assert_stmt:\r\n\t                return astForAssertStmt(c, n);\r\n\t            case SYM.debugger_stmt:\r\n\t                return new Debugger_(n.lineno, n.col_offset);\r\n\t            default:\r\n\t                goog.asserts.fail(\"unhandled small_stmt\");\r\n\t        }\r\n\t    }\r\n\t    else {\r\n\t        /* compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt\r\n\t         | funcdef | classdef | decorated\r\n\t         */\r\n\t        ch = CHILD(n, 0);\r\n\t        REQ(n, SYM.compound_stmt);\r\n\t        switch (ch.type) {\r\n\t            case SYM.if_stmt:\r\n\t                return astForIfStmt(c, ch);\r\n\t            case SYM.while_stmt:\r\n\t                return astForWhileStmt(c, ch);\r\n\t            case SYM.for_stmt:\r\n\t                return astForForStmt(c, ch);\r\n\t            case SYM.try_stmt:\r\n\t                return astForTryStmt(c, ch);\r\n\t            case SYM.with_stmt:\r\n\t                return astForWithStmt(c, ch);\r\n\t            case SYM.funcdef:\r\n\t                return astForFuncdef(c, ch, []);\r\n\t            case SYM.classdef:\r\n\t                return astForClassdef(c, ch, []);\r\n\t            case SYM.decorated:\r\n\t                return astForDecorated(c, ch);\r\n\t            default:\r\n\t                goog.asserts.assert(\"unhandled compound_stmt\");\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tSk.astFromParse = function (n, filename, c_flags) {\r\n\t    var j;\r\n\t    var num;\r\n\t    var ch;\r\n\t    var i;\r\n\t    var c = new Compiling(\"utf-8\", filename, c_flags);\r\n\t    var stmts = [];\r\n\t    var k = 0;\r\n\t    switch (n.type) {\r\n\t        case SYM.file_input:\r\n\t            for (i = 0; i < NCH(n) - 1; ++i) {\r\n\t                ch = CHILD(n, i);\r\n\t                if (n.type === TOK.T_NEWLINE) {\r\n\t                    continue;\r\n\t                }\r\n\t                REQ(ch, SYM.stmt);\r\n\t                num = numStmts(ch);\r\n\t                if (num === 1) {\r\n\t                    stmts[k++] = astForStmt(c, ch);\r\n\t                }\r\n\t                else {\r\n\t                    ch = CHILD(ch, 0);\r\n\t                    REQ(ch, SYM.simple_stmt);\r\n\t                    for (j = 0; j < num; ++j) {\r\n\t                        stmts[k++] = astForStmt(c, CHILD(ch, j * 2));\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            return new Module(stmts);\r\n\t        case SYM.eval_input:\r\n\t            goog.asserts.fail(\"todo;\");\r\n\t        case SYM.single_input:\r\n\t            goog.asserts.fail(\"todo;\");\r\n\t        default:\r\n\t            goog.asserts.fail(\"todo;\");\r\n\t    }\r\n\t};\r\n\r\n\tSk.astDump = function (node) {\r\n\t    var spaces = function (n) // todo; blurgh\r\n\t    {\r\n\t        var i;\r\n\t        var ret = \"\";\r\n\t        for (i = 0; i < n; ++i) {\r\n\t            ret += \" \";\r\n\t        }\r\n\t        return ret;\r\n\t    };\r\n\r\n\t    var _format = function (node, indent) {\r\n\t        var ret;\r\n\t        var elemsstr;\r\n\t        var x;\r\n\t        var elems;\r\n\t        var fieldstr;\r\n\t        var field;\r\n\t        var attrs;\r\n\t        var fieldlen;\r\n\t        var b;\r\n\t        var a;\r\n\t        var i;\r\n\t        var fields;\r\n\t        var namelen;\r\n\t        if (node === null) {\r\n\t            return indent + \"None\";\r\n\t        }\r\n\t        else if (node.prototype && node.prototype._astname !== undefined && node.prototype._isenum) {\r\n\t            return indent + node.prototype._astname + \"()\";\r\n\t        }\r\n\t        else if (node._astname !== undefined) {\r\n\t            namelen = spaces(node._astname.length + 1);\r\n\t            fields = [];\r\n\t            for (i = 0; i < node._fields.length; i += 2) // iter_fields\r\n\t            {\r\n\t                a = node._fields[i]; // field name\r\n\t                b = node._fields[i + 1](node); // field getter func\r\n\t                fieldlen = spaces(a.length + 1);\r\n\t                fields.push([a, _format(b, indent + namelen + fieldlen)]);\r\n\t            }\r\n\t            attrs = [];\r\n\t            for (i = 0; i < fields.length; ++i) {\r\n\t                field = fields[i];\r\n\t                attrs.push(field[0] + \"=\" + field[1].replace(/^\\s+/, \"\"));\r\n\t            }\r\n\t            fieldstr = attrs.join(\",\\n\" + indent + namelen);\r\n\t            return indent + node._astname + \"(\" + fieldstr + \")\";\r\n\t        }\r\n\t        else if (goog.isArrayLike(node)) {\r\n\t            //Sk.debugout(\"arr\", node.length);\r\n\t            elems = [];\r\n\t            for (i = 0; i < node.length; ++i) {\r\n\t                x = node[i];\r\n\t                elems.push(_format(x, indent + \" \"));\r\n\t            }\r\n\t            elemsstr = elems.join(\",\\n\");\r\n\t            return indent + \"[\" + elemsstr.replace(/^\\s+/, \"\") + \"]\";\r\n\t        }\r\n\t        else {\r\n\t            if (node === true) {\r\n\t                ret = \"True\";\r\n\t            }\r\n\t            else if (node === false) {\r\n\t                ret = \"False\";\r\n\t            }\r\n\t            else if (node instanceof Sk.builtin.lng) {\r\n\t                ret = node.tp$str().v;\r\n\t            }\r\n\t            else if (node instanceof Sk.builtin.str) {\r\n\t                ret = node[\"$r\"]().v;\r\n\t            }\r\n\t            else {\r\n\t                ret = \"\" + node;\r\n\t            }\r\n\t            return indent + ret;\r\n\t        }\r\n\t    };\r\n\r\n\t    return _format(node, \"\");\r\n\t};\r\n\r\n\tgoog.exportSymbol(\"Sk.astFromParse\", Sk.astFromParse);\r\n\tgoog.exportSymbol(\"Sk.astDump\", Sk.astDump);\r\n\r\n\r\n\r\n\t/* ---- /Users/rob/skulpty/lib/afterword.js ---- */ \r\n\r\n\tfunction wrapAstThing(fx, argpos, debug) {\r\n\t\targpos = argpos || 2;\r\n\t\treturn function(x) {\r\n\t\t\tvar n = arguments[argpos-1];\r\n\t\t\tvar result = fx.apply(undefined, arguments);\r\n\t\t\tresult.range = n.range;\r\n\t\t\tresult.str = n.str;\r\n\t\t\tresult.loc = n.loc;\r\n\t\t\tif ( debug ) {\r\n\t\t\t\tconsole.log(n);\r\n\t\t\t\tconsole.log(result);\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t};\r\n\t}\r\n\r\n\tastForAtom = wrapAstThing(astForAtom);\r\n\tastForCompOp = wrapAstThing(astForCompOp);\r\n\tastForSuite = wrapAstThing(astForSuite);\r\n\tastForExceptClause = wrapAstThing(astForExceptClause);\r\n\tastForDottedName = wrapAstThing(astForDottedName);\r\n\tastForDecorator = wrapAstThing(astForDecorator);\r\n\tastForDecorators = wrapAstThing(astForDecorators);\r\n\tastForDecorated = wrapAstThing(astForDecorated);\r\n\tastForWithVar = wrapAstThing(astForWithVar);\r\n\tastForWithStmt = wrapAstThing(astForWithStmt);\r\n\tastForExecStmt = wrapAstThing(astForExecStmt);\r\n\tastForIfStmt = wrapAstThing(astForIfStmt);\r\n\tastForExprlist = wrapAstThing(astForExprlist);\r\n\tastForDelStmt = wrapAstThing(astForDelStmt);\r\n\tastForGlobalStmt = wrapAstThing(astForGlobalStmt);\r\n\tastForAssertStmt = wrapAstThing(astForAssertStmt);\r\n\tastForImportStmt = wrapAstThing(astForImportStmt);\r\n\tastForTestlistComp = wrapAstThing(astForTestlistComp);\r\n\tastForListcomp = wrapAstThing(astForListcomp);\r\n\tastForFactor = wrapAstThing(astForFactor);\r\n\tastForForStmt = wrapAstThing(astForForStmt);\r\n\tastForTrailer = wrapAstThing(astForTrailer);\r\n\tastForFlowStmt = wrapAstThing(astForFlowStmt);\r\n\tastForArguments = wrapAstThing(astForArguments);\r\n\tastForFuncdef = wrapAstThing(astForFuncdef);\r\n\tastForClassBases = wrapAstThing(astForClassBases);\r\n\tastForClassdef = wrapAstThing(astForClassdef);\r\n\tastForLambdef = wrapAstThing(astForLambdef);\r\n\tastForComprehension = wrapAstThing(astForComprehension);\r\n\tastForIterComp = wrapAstThing(astForIterComp);\r\n\tastForDictComp = wrapAstThing(astForDictComp);\r\n\tastForGenExpr = wrapAstThing(astForGenExpr);\r\n\tastForSetComp = wrapAstThing(astForSetComp);\r\n\tastForWhileStmt = wrapAstThing(astForWhileStmt);\r\n\tastForAugassign = wrapAstThing(astForAugassign);\r\n\tastForBinop = wrapAstThing(astForBinop);\r\n\tastForTestlist = wrapAstThing(astForTestlist);\r\n\tastForExprStmt = wrapAstThing(astForExprStmt);\r\n\tastForIfexpr = wrapAstThing(astForIfexpr);\r\n\tastForExpr = wrapAstThing(astForExpr);\r\n\tSk.astFromParse = wrapAstThing(Sk.astFromParse, 1);\r\n\r\n\tSk.nameForToken = function(v) {\r\n\t\tif ( typeof v === \"string\" ) return v;\r\n\t\tfor ( var name in Sk.Tokenizer.Tokens ) {\r\n\t\t\tif ( Sk.Tokenizer.Tokens[name] == v ) return name;\r\n\t\t}\r\n\t\tif ( v in Sk.ParseTables.number2symbol ) {\r\n\t\t\treturn Sk.ParseTables.number2symbol[v];\r\n\t\t}\r\n\r\n\t\treturn '???:' + v;\r\n\t};\r\n\r\n\t//Sk.python3 = true;\r\n\tSk.Parser = Parser;\r\n\tSk.builtin.str.prototype.valueOf = function() { return this.v; };\r\n\tSk.builtin.str.prototype.toString = function() { return this.v; };\r\n\r\n\tSk.builtin.SyntaxError = function(str, file, line, ctx, extra) {\r\n\t\tvar err = new SyntaxError(str, file, line);\r\n\t\terr.context = ctx;\r\n\t\terr.extra = extra;\r\n\t\terr.line = line;\r\n\t\treturn err;\r\n\t};\r\n\r\n\tSk.builtin.IndentationError = function(str, file, line, row, extra) {\r\n\t\tvar err = new SyntaxError('Indentation Error: ' + str, file, line);\r\n\t\terr.context = [[line, row], [line, row]];\r\n\t\terr.extra = {\r\n\t\t};\r\n\t\terr.line = line;\r\n\t\treturn err;\r\n\t};\r\n\r\n\r\n\tmodule.exports = Sk;\r\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\r\n\r\n/***/ },\r\n/* 2 */\r\n/***/ function(module, exports) {\r\n\r\n\t'use strict';\r\n\r\n\tvar isArray = Array.isArray;\r\n\r\n\t//TODO: Find a way to not have to do this.\r\n\tfunction getOpName(op) {\r\n\t\tif (op.prototype._astname) {\r\n\t\t\treturn op.prototype._astname;\r\n\t\t}\r\n\t\tthrow new Error(\"Coudlnt decode operator name for: \" + (op.name || op.toString()));\r\n\t}\r\n\r\n\tfunction abort(why) {\r\n\t\tconsole.log(new Error(\"ABORT:\" + why).stack);\r\n\t\tthrow new Error(why);\r\n\t}\r\n\r\n\tfunction isExpression(n) {\r\n\t\treturn /Expression$/.test(n.type);\r\n\t}\r\n\r\n\tvar idx = 0;\r\n\tfunction createTempName(hint) {\r\n\t\treturn '__temp$' + hint + '$' + idx++;\r\n\t}\r\n\r\n\tfunction ensureStatement(s) {\r\n\t\tvar f = s;\r\n\t\tif ( !isArray(s) ) f = [f];\r\n\t\tfor ( var i = 0; i < f.length; ++i ) {\r\n\t\t\tvar v = f[i];\r\n\t\t\tif ( isExpression(v) ) {\r\n\t\t\t\tf[i] = {type: \"ExpressionStatement\", expression: v};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( isArray(s) ) return s;\r\n\t\telse return f[0];\r\n\t}\r\n\r\n\tfunction ident(n) {\r\n\t\treturn {type: \"Identifier\", name: n.valueOf()};\r\n\t}\r\n\r\n\tfunction member(o, p) {\r\n\t\treturn {\r\n\t\t\ttype: \"MemberExpression\",\r\n\t\t\tobject: o,\r\n\t\t\tproperty: p,\r\n\t\t\tcomputed: false\r\n\t\t};\r\n\t}\r\n\r\n\tfunction literal(v) {\r\n\t\tif ( typeof v === 'object' ) v = v.valueOf();\r\n\r\n\t\tif ( typeof v === 'number' && (1 / v !== 1 / Math.abs(v)) ) {\r\n\t\t\treturn {type: \"UnaryExpression\", argument: literal(-v), operator: '-' };\r\n\t\t}\r\n\r\n\t\treturn {type: \"Literal\", value: v, raw: JSON.stringify(v)};\r\n\t}\r\n\r\n\tfunction binOp(left, op, right) {\r\n\t\treturn {\r\n\t\t\ttype: \"BinaryExpression\",\r\n\t\t\tleft: left,\r\n\t\t\tright: right,\r\n\t\t\toperator: op\r\n\t\t};\r\n\t}\r\n\r\n\tfunction logicOp(left, op, right) {\r\n\t\treturn {\r\n\t\t\ttype: \"LogicalExpression\",\r\n\t\t\tleft: left,\r\n\t\t\tright: right,\r\n\t\t\toperator: op\r\n\t\t};\r\n\t}\r\n\r\n\tfunction ternary(cond, a, b) {\r\n\t\treturn {\r\n\t\t\ttype: \"ConditionalExpression\",\r\n\t\t\ttest: cond,\r\n\t\t\tconsequent: a,\r\n\t\t\talternate: b\r\n\t\t};\r\n\t}\r\n\r\n\tfunction var_(name, init) {\r\n\t\treturn {\r\n\t\t\ttype: \"VariableDeclaration\",\r\n\t\t\tkind: 'var',\r\n\t\t\tdeclarations: [{\r\n\t\t\t\ttype: \"VariableDeclarator\",\r\n\t\t\t\tid: name,\r\n\t\t\t\tinit: init ? init : undefined\r\n\t\t\t}]\r\n\t\t};\r\n\t}\r\n\r\n\tfunction transform(node, ctx) {\r\n\t\t//console.log(node.lineno, node.col_offset);\r\n\t\tvar result = dispatch(node, ctx);\r\n\t\tif ( node.range ) result.range = [node.range[0], node.range[1]];\r\n\t\tif ( node.loc ) result.loc = node.loc;\r\n\t\tresult.str = node.str;\r\n\t\treturn result;\r\n\t}\r\n\r\n\tfunction dispatch(node, ctx) {\r\n\t\tif ( !ctx.locals ) ctx.locals = Object.create(null);\r\n\r\n\t\tif ( !node ) {\r\n\t\t\tconsole.log(\"WAT!\", new Error().stack);\r\n\t\t\tthrow new Error(\"What?\");\r\n\t\t}\r\n\t\tif ( isArray(node) ) {\r\n\t\t\tvar body = [];\r\n\t\t\tfor ( var i = 0; i < node.length; ++i ) {\r\n\t\t\t\tvar r = transform(node[i], ctx);\r\n\t\t\t\tif ( isArray(r) ) body.push.apply(body, r);\r\n\t\t\t\telse body.push(r);\r\n\t\t\t}\r\n\t\t\treturn body;\r\n\t\t}\r\n\t\tswitch (node._astname) {\r\n\t\t\tcase 'Attribute': return transformAttribute(node, ctx);\r\n\t\t\tcase 'Assign': return transformAssign(node, ctx);\r\n\t\t\tcase 'AugAssign': return transformAugAssign(node, ctx);\r\n\t\t\tcase 'BinOp': return transformBinOp(node, ctx);\r\n\t\t\tcase 'BoolOp': return transformBoolOp(node, ctx);\r\n\t\t\tcase 'Break': return transformBreak(node, ctx);\r\n\t\t\tcase 'Call': return transformCall(node, ctx);\r\n\t\t\tcase 'ClassDef': return transformClassDef(node, ctx);\r\n\t\t\tcase 'Continue': return tranformContinue(node, ctx);\r\n\t\t\tcase 'Compare': return transformCompare(node, ctx);\r\n\t\t\tcase 'Dict': return transformDict(node, ctx);\r\n\t\t\tcase 'Delete': return transformDel(node, ctx);\r\n\t\t\tcase 'Expr': return transformExpr(node, ctx);\r\n\t\t\tcase 'For': return transformFor(node, ctx);\r\n\t\t\tcase 'FunctionDef': return transformFunctionDef(node, ctx);\r\n\t\t\tcase 'GeneratorExp': return transformListComp(node, ctx); //TODO: Make this seperate\r\n\t\t\tcase 'Global': return transformGlobal(node, ctx);\r\n\t\t\tcase 'If': return transformIf(node, ctx);\r\n\t\t\tcase 'Import': return NoOp();\r\n\t\t\tcase 'Lambda': return transformLambda(node, ctx);\r\n\t\t\tcase 'List': return transformList(node, ctx);\r\n\t\t\tcase 'ListComp': return transformListComp(node, ctx);\r\n\t\t\tcase 'Module': return transformModule(node, ctx);\r\n\t\t\tcase 'Name': return transformName(node, ctx);\r\n\t\t\tcase 'Print': return transformPrint(node, ctx);\r\n\t\t\tcase 'Return': return transformReturn(node, ctx);\r\n\t\t\tcase 'Str': return transformStr(node, ctx);\r\n\t\t\tcase 'Subscript': return transformSubscript(node, ctx);\r\n\t\t\tcase 'Tuple': return transformTuple(node, ctx);\r\n\t\t\tcase 'Num': return transformNum(node, ctx);\r\n\t\t\tcase 'Pass': return transformPass(node, ctx);\r\n\t\t\tcase 'UnaryOp': return transformUnaryOp(node, ctx);\r\n\t\t\tcase 'While': return transformWhile(node, ctx);\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.log(\"Dont know how to transform: \" + node._astname);\r\n\t\t\t\tconsole.log(JSON.stringify(node, null, '  '));\r\n\t\t\t\tthrow new Error(\"Dont know how to transform: \" + node._astname);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction NoOp() { return []; }\r\n\r\n\r\n\r\n\tfunction makeVariableName(name) {\r\n\t\tvar parts = Array.isArray(name) ? name : name.split(/\\./g);\r\n\t\tif ( parts.length === 1 ) return ident(name);\r\n\t\tvar prop = parts.pop();\r\n\t\treturn member(makeVariableName(parts), ident(prop));\r\n\t}\r\n\r\n\tfunction transformAttribute(node, ctx) {\r\n\t\tvar n = node.attr;\r\n\t\tif ( n._astname ) n = transform(n, ctx);\r\n\t\telse n = {type: 'Identifier', name: n.valueOf()};\r\n\t\treturn member(transform(node.value, ctx), n);\r\n\t}\r\n\r\n\tfunction transformAugAssign(node, ctx) {\r\n\t\t//TODO: We need to not inject left into the code twice\r\n\t\t//as it could have side effects.\r\n\t\tvar right = transform(node.value, ctx);\r\n\t\tvar left = transform(node.target, ctx);\r\n\t\tvar tn = createTempName(\"left\");\r\n\t\tvar opName = getOpName(node.op);\r\n\t\treturn [\r\n\t\t\tvar_(ident(tn), left),\r\n\t\t\tensureStatement({\r\n\t\t\t\ttype: \"AssignmentExpression\",\r\n\t\t\t\toperator: '=',\r\n\t\t\t\tleft: left,\r\n\t\t\t\tright: createBinOp(left, opName, right)\r\n\t\t\t})\r\n\t\t];\r\n\t}\r\n\r\n\tfunction transformAssign(node, ctx) {\r\n\r\n\t\tvar results = [];\r\n\t\tfor ( var i = 0; i < node.targets.length; ++i ) {\r\n\t\t\tvar left = node.targets[i];\r\n\t\t\tif ( ctx.writeTarget ) {\r\n\t\t\t\tleft = member(ctx.writeTarget, transform(left,ctx));\r\n\t\t\t}\r\n\t\t\tresults.push.apply(results,createTupleUnpackingAssign(left, transform(node.value, ctx), ctx));\r\n\t\t\r\n\t\t}\r\n\t\tif ( results.length == 1 ) return results[0];\r\n\t\treturn {type: \"BlockStatement\", body: results}; \r\n\t}\r\n\r\n\tfunction createBinOp(left, op, right) {\r\n\r\n\t\tif ( op === 'FloorDiv' ) {\r\n\t\t\treturn {\r\n\t\t\t\ttype: \"CallExpression\",\r\n\t\t\t\tcallee: makeVariableName('Math.floor'),\r\n\t\t\t\targuments: [{\r\n\t\t\t\t\ttype: \"BinaryExpression\",\r\n\t\t\t\t\tleft: left,\r\n\t\t\t\t\tright: right,\r\n\t\t\t\t\toperator: '/'\r\n\t\t\t\t}]\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tvar fxOps = {\r\n\t\t\t\"Add\": \"__pythonRuntime.ops.add\",\r\n\t\t\t\"Mult\": \"__pythonRuntime.ops.multiply\",\r\n\t\t\t\"Pow\": \"Math.pow\"\r\n\t\t};\r\n\r\n\t\tif ( op in fxOps  ) {\r\n\t\t\tvar call = {\r\n\t\t\t\ttype: \"CallExpression\",\r\n\t\t\t\tcallee: makeVariableName(fxOps[op]),\r\n\t\t\t\targuments: [left, right]\r\n\t\t\t};\r\n\t\t\treturn call;\r\n\t\t}\r\n\r\n\t\tvar operators = {\r\n\t\t\t\"Add\": \"+\",\r\n\t\t\t\"Sub\": \"-\",\r\n\t\t\t\"Mod\": \"%\",\r\n\t\t\t\"Div\": \"/\",\r\n\t\t\t\"BitAnd\": \"&\",\r\n\t\t\t\"BitOr\": \"|\",\r\n\t\t\t'BitXor': '^',\r\n\t\t\t\"LShift\": \"<<\",\r\n\t\t\t\"RShift\": \">>\"\r\n\r\n\t\t};\r\n\r\n\t\tif ( !(op in operators) ) abort(\"Unknown binary operator: \" + op);\r\n\r\n\t\treturn binOp(left, operators[op], right);\r\n\t}\r\n\r\n\tfunction transformBinOp(node, ctx) {\r\n\t\tvar left = transform(node.left, ctx);\r\n\t\tvar right = transform(node.right, ctx);\r\n\t\treturn createBinOp(left, getOpName(node.op), right);\r\n\t}\r\n\r\n\tfunction transformBoolOp(node, ctx) {\r\n\t\tvar fvals = new Array(node.values.length);\r\n\t\tfor ( var i = 0; i < node.values.length; ++i ) {\r\n\t\t\tfvals[i] = transform(node.values[i], ctx);\r\n\t\t}\r\n\t\tvar opName = getOpName(node.op);\r\n\t\tvar operators = {\r\n\t\t\t'And': '&&',\r\n\t\t\t'Or': '||'\r\n\t\t};\r\n\r\n\t\tif ( !(opName in operators ) ) abort(\"Unknown bool opeartor: \" + opName);\r\n\t\tvar opstr = operators[opName];\r\n\r\n\t\tvar result = fvals.pop();\r\n\t\twhile ( fvals.length > 0 ) {\r\n\t\t\tresult = logicOp(fvals.pop(), opstr, result);\r\n\t\t}\r\n\r\n\r\n\t\t//TODO: Support || as well?\r\n\t\treturn result;\r\n\t}\r\n\r\n\tfunction transformBreak(node, ctx) {\r\n\t\treturn {type: \"BreakStatement\"};\r\n\t}\r\n\r\n\tfunction transformCall(node, ctx) {\r\n\t\tvar builtins = ['len'];\r\n\t\tif ( node.func._astname == 'Name' ) {\r\n\t\t\tswitch ( node.func.id.v ) {\r\n\t\t\t\tcase 'len':\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttype: \"MemberExpression\",\r\n\t\t\t\t\t\tobject: transform(node.args[0], ctx),\r\n\t\t\t\t\t\tproperty: {type: \"Identifier\", name: \"length\"}\r\n\t\t\t\t\t};\r\n\t\t\t\tcase 'all': case 'ord':\r\n\t\t\t\tcase 'sum': case 'any':\r\n\t\t\t\tcase 'str': case 'chr':\r\n\t\t\t\tcase 'ascii': case 'divmod':\r\n\t\t\t\tcase 'range': case 'enumerate':\r\n\t\t\t\tcase 'round': case 'filter':\r\n\t\t\t\tcase 'abs': case 'float':\r\n\t\t\t\tcase 'int': case 'hex':\r\n\t\t\t\tcase 'tuple': case  'map':\r\n\t\t\t\tcase 'bool': case 'max':\r\n\t\t\t\tcase 'sorted': case 'min':\r\n\t\t\t\tcase 'list': case 'oct':\r\n\t\t\t\tcase 'pow': case  'reversed':\r\n\t\t\t\tcase 'repr':\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttype: 'CallExpression',\r\n\t\t\t\t\t\tcallee: makeVariableName('__pythonRuntime.functions.' + node.func.id.v),\r\n\t\t\t\t\t\targuments: transform(node.args, ctx)\r\n\t\t\t\t\t};\r\n\t\t\t\tcase 'dict':\r\n\t\t\t\t\tvar args = [];\r\n\t\t\t\t\tfor ( var i = 0; i < node.keywords.length; ++i ) {\r\n\t\t\t\t\t\targs.push({\r\n\t\t\t\t\t\t\ttype: \"ArrayExpression\",\r\n\t\t\t\t\t\t\telements: [\r\n\t\t\t\t\t\t\t\tliteral(node.keywords[i].arg.v),\r\n\t\t\t\t\t\t\t\ttransform(node.keywords[i].value, ctx)\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\ttype: \"NewExpression\",\r\n\t\t\t\t\t\tcallee: makeVariableName('__pythonRuntime.objects.dict'),\r\n\t\t\t\t\t\targuments: args\r\n\t\t\t\t\t};\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar args = transform(node.args, ctx);\r\n\r\n\t\tif ( node.keywords.length > 0 ) {\r\n\t\t\tvar paramsDict = {\r\n\t\t\t\ttype: \"ObjectExpression\",\r\n\t\t\t\tproperties: [{\r\n\t\t\t\t\ttype: \"Property\",\r\n\t\t\t\t\tkey: ident(\"__kwp\"),\r\n\t\t\t\t\tvalue: literal(true)\r\n\t\t\t\t}]\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0; i < node.keywords.length; ++i ) {\r\n\t\t\t\tvar k = node.keywords[i];\r\n\t\t\t\tparamsDict.properties.push({\r\n\t\t\t\t\ttype: \"Property\",\r\n\t\t\t\t\tkey: ident(k.arg.v),\r\n\t\t\t\t\tvalue: transform(k.value, ctx)\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tvar extraArg = {\r\n\t\t\t\ttype: \"CallExpression\",\r\n\t\t\t\tcallee: makeVariableName('__pythonRuntime.utils.createParamsObj'),\r\n\t\t\t\targuments: [paramsDict]\r\n\t\t\t};\r\n\r\n\t\t\targs.push(extraArg);\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttype: \"CallExpression\",\r\n\t\t\tcallee: transform(node.func, ctx),\r\n\t\t\targuments: args\r\n\t\t};\r\n\t}\r\n\r\n\tfunction transformClassDef(node, ctx) {\r\n\t\tvar body = [];\r\n\t\tvar proto = member(ident(node.name), ident('prototype'));\r\n\t\tvar nctx = {\r\n\t\t\twriteTarget: proto,\r\n\t\t\tinClass: true,\r\n\t\t\tlocals: Object.create(null)\r\n\t\t};\r\n\r\n\t\tif ( node.bases.length > 1 ) alert(\"Multiple base classes not supported.\");\r\n\r\n\t\tvar base = (node.bases.length > 0) ? transform(node.bases[0], ctx) : undefined;\r\n\r\n\t\tvar ctorBody = [];\r\n\t\tctorBody.push({\r\n\t\t\ttype: \"VariableDeclaration\",\r\n\t\t\tkind: 'var',\r\n\t\t\tdeclarations: [{\r\n\t\t\t\ttype: \"VariableDeclarator\",\r\n\t\t\t\tid: ident('that'),\r\n\t\t\t\tinit: {type: \"ThisExpression\"}\r\n\t\t\t}]\r\n\t\t});\r\n\r\n\t\tctorBody.push({\r\n\t\t\ttype: \"IfStatement\",\r\n\t\t\ttest: {\r\n\t\t\t\ttype:\"UnaryExpression\",\r\n\t\t\t\targument: binOp(ident('that'), \"instanceof\", ident(node.name)),\r\n\t\t\t\toperator: \"!\"\r\n\t\t\t},\r\n\t\t\tconsequent: ensureStatement({\r\n\t\t\t\ttype: \"AssignmentExpression\",\r\n\t\t\t\tleft: ident('that'),\r\n\t\t\t\tright: {\r\n\t\t\t\t\ttype:  \"CallExpression\",\r\n\t\t\t\t\tcallee: makeVariableName('Object.create'),\r\n\t\t\t\t\targuments: [ proto ]\r\n\t\t\t\t},\r\n\t\t\t\toperator: '='\r\n\t\t\t})\r\n\t\t});\r\n\r\n\t\tctorBody.push({\r\n\t\t\ttype: \"IfStatement\",\r\n\t\t\ttest: {\r\n\t\t\t\ttype: \"CallExpression\",\r\n\t\t\t\tcallee: member(proto, ident('hasOwnProperty')),\r\n\t\t\t\targuments: [literal('__init__')]\r\n\t\t\t},\r\n\t\t\tconsequent: ensureStatement({\r\n\t\t\t\ttype: \"CallExpression\",\r\n\t\t\t\tcallee: member(member(proto, ident('__init__')), ident('apply')),\r\n\t\t\t\targuments: [ident('that'), ident('arguments')]\r\n\t\t\t})\r\n\t\t});\r\n\r\n\t\tif ( base ) {\r\n\t\t\tctorBody.push(ensureStatement({\r\n\t\t\t\ttype: \"CallExpression\",\r\n\t\t\t\tcallee: {\r\n\t\t\t\t\ttype: \"MemberExpression\",\r\n\t\t\t\t\tobject: base,\r\n\t\t\t\t\tproperty: ident('apply'),\r\n\t\t\t\t\tcomputed: false\r\n\t\t\t\t},\r\n\t\t\t\targuments: [ident('that'), ident('arguments')]\r\n\t\t\t}));\r\n\t\t}\r\n\r\n\t\tctorBody.push({\r\n\t\t\ttype: \"ReturnStatement\",\r\n\t\t\targument: ident('that')\r\n\t\t});\r\n\r\n\r\n\t\tbody.push({\r\n\t\t\ttype: \"FunctionDeclaration\",\r\n\t\t\tid: ident(node.name),\r\n\t\t\tparams: [],\r\n\t\t\tbody: {type: \"BlockStatement\", body:ctorBody}\r\n\t\t});\r\n\r\n\t\tif ( base ) {\r\n\t\t\tbody.push({\r\n\t\t\t\ttype: \"AssignmentExpression\",\r\n\t\t\t\tleft: proto,\r\n\t\t\t\tright: {\r\n\t\t\t\t\ttype:  \"CallExpression\",\r\n\t\t\t\t\tcallee: makeVariableName('Object.create'),\r\n\t\t\t\t\targuments: [ member(base, ident('prototype')) ]\r\n\t\t\t\t},\r\n\t\t\t\toperator: \"=\"\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tbody = body.concat(transform(node.body, nctx));\r\n\r\n\t\tbody.push({\r\n\t\t\ttype: \"ReturnStatement\",\r\n\t\t\targument: ident(node.name)\r\n\t\t});\r\n\r\n\t\treturn {\r\n\t\t\t\"type\": \"VariableDeclaration\",\r\n\t\t\t\"declarations\": [\r\n\t\t\t{\r\n\t\t\t  \"type\": \"VariableDeclarator\",\r\n\t\t\t  \"id\": ident(node.name),\r\n\t\t\t  \"init\": {\r\n\t\t\t  \ttype: \"CallExpression\",\r\n\t\t\t  \tcallee: {\r\n\t\t\t  \t\ttype: \"FunctionExpression\",\r\n\t\t\t  \t\tparams: [],\r\n\t\t\t  \t\tbody: {type: \"BlockStatement\", body: ensureStatement(body)}\r\n\t\t\t  \t},\r\n\t\t\t  \targuments: []\r\n\t\t\t  }\r\n\t\t\t}],\r\n\t\t\t\"kind\": ctx.varType || 'var'\r\n\t\t};\r\n\t}\r\n\r\n\r\n\tfunction tranformContinue(node, ctx) {\r\n\t\treturn {type: \"ContinueStatement\"};\r\n\t}\r\n\r\n\tfunction makeCop(left, op, right) {\r\n\r\n\t\tvar fxOps = {\r\n\t\t\t\"In_\": \"in\",\r\n\t\t\t\"In\": \"in\",\r\n\t\t\t\"NotIn\": \"in\"\r\n\t\t};\r\n\t\tvar opName = getOpName(op);\r\n\t\tif ( opName in fxOps  ) {\r\n\t\t\tvar call = {\r\n\t\t\t\ttype: \"CallExpression\",\r\n\t\t\t\tcallee: makeVariableName(\"__pythonRuntime.ops.\" + fxOps[opName]),\r\n\t\t\t\targuments: [left, right]\r\n\t\t\t};\r\n\r\n\t\t\tif ( opName == \"NotIn\" ) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttype: \"UnaryExpression\",\r\n\t\t\t\t\targument: call,\r\n\t\t\t\t\toperator: \"!\"\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\treturn call;\t\r\n\t\t\t} \r\n\t\t}\r\n\r\n\t\t\r\n\t\tvar operators = {\r\n\t\t\t\"Eq\": \"===\",\r\n\t\t\t\"NotEq\": \"!==\",\r\n\t\t\t\"LtE\": \"<=\",\r\n\t\t\t\"Lt\": \"<\",\r\n\t\t\t\"GtE\": \">=\",\r\n\t\t\t\"Gt\": \">\",\r\n\t\t\t\"Is\": \"===\",\r\n\t\t\t\"IsNot\": \"!==\"\r\n\t\t};\r\n\t\t\r\n\t\tif ( !(opName in operators) ) abort(\"Unsuported Compare operator: \" + opName);\r\n\t\treturn binOp(left, operators[opName], right);\r\n\t}\r\n\r\n\tfunction transformCompare(node, ctx) {\r\n\t\tvar left = transform(node.left, ctx);\r\n\t\tvar result;\r\n\r\n\t\tfor ( var i = 0; i < node.comparators.length; ++i ) {\r\n\t\t\tvar right = transform(node.comparators[i], ctx);\r\n\t\t\tvar cop = makeCop(left, node.ops[i], right);\r\n\t\t\tif ( result ) {\r\n\t\t\t\tresult = binOp(result, '&&', cop);\r\n\t\t\t} else {\r\n\t\t\t\tresult = cop;\r\n\t\t\t}\r\n\t\t\tleft = right;\r\n\t\t}\r\n\r\n\t\t\r\n\r\n\t\treturn result;\r\n\t\t\r\n\t}\r\n\r\n\tfunction transformDel(node, ctx) {\r\n\t\tvar result = [];\r\n\t\tfor ( var i = 0; i < node.targets.length; ++i ) {\r\n\t\t\tvar st = node.targets[i];\r\n\t\t\tvar partial = transform(st, ctx);\r\n\t\t\tresult.push({\r\n\t\t\t\ttype: \"AssignmentExpression\",\r\n\t\t\t\toperator: \"=\",\r\n\t\t\t\tleft: partial,\r\n\t\t\t\tright: {\r\n\t\t\t\t\ttype: \"UnaryExpression\",\r\n\t\t\t\t\targument: literal(0),\r\n\t\t\t\t\toperator: 'void',\r\n\t\t\t\t\tprefix: true\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn ensureStatement({\r\n\t\t\ttype: \"SequenceExpression\",\r\n\t\t\texpressions: result\r\n\t\t});\r\n\t}\r\n\r\n\tfunction transformDict(node, ctx) {\r\n\t\tvar args = [];\r\n\t\tfor ( var i = 0; i < node.keys.length; ++i ) {\r\n\t\t\targs.push({\r\n\t\t\t\ttype: \"ArrayExpression\",\r\n\t\t\t\telements: [\r\n\t\t\t\t\ttransform(node.keys[i], ctx),\r\n\t\t\t\t\ttransform(node.values[i], ctx)\r\n\t\t\t\t]\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn {\r\n\t\t\ttype: \"NewExpression\",\r\n\t\t\tcallee: makeVariableName(\"__pythonRuntime.objects.dict\"),\r\n\t\t\targuments: args\r\n\t\t};\r\n\t}\r\n\r\n\tfunction transformExpr(node, ctx) {\r\n\t\treturn {\r\n\t\t\ttype: \"ExpressionStatement\",\r\n\t\t\texpression: transform(node.value, ctx)\r\n\t\t};\r\n\t}\r\n\r\n\tfunction assignPossiblyWithDeclaration(target, value, ctx) {\r\n\t\tvar left = target._astname ? transform(target, ctx) : target;\r\n\t\tvar varible;\r\n\r\n\t\tif ( left.type === \"Identifier\" ) varible = left.name;\r\n\r\n\t\tif ( !varible || !ctx || !ctx.locals || ctx.locals[varible] ) {\r\n\t\t\treturn {type: \"ExpressionStatement\", expression: {\r\n\t\t\t\ttype: \"AssignmentExpression\",\r\n\t\t\t\toperator: \"=\",\r\n\t\t\t\tleft: left,\r\n\t\t\t\tright: value\r\n\t\t\t}};\r\n\t\t}\r\n\r\n\t\tctx.locals[varible] = true;\r\n\r\n\t\treturn {\r\n\t\t\ttype: \"VariableDeclaration\",\r\n\t\t\tdeclarations: [{\r\n\t\t\t\ttype: \"VariableDeclarator\",\r\n\t\t\t\tid: left,\r\n\t\t\t\tinit: value\r\n\t\t\t}],\r\n\t\t\tkind: ctx.varType || 'var'\r\n\t\t};\r\n\t}\r\n\r\n\tfunction createTupleUnpackingAssign(target, value, ctx) {\r\n\r\n\t\tif ( target._astname === 'Tuple' ) {\r\n\t\t\tvar result = [];\r\n\t\t\tvar tn = createTempName(\"right\");\r\n\t\t\tresult.push({\r\n\t\t\t\ttype: \"VariableDeclaration\",\r\n\t\t\t\tkind: \"var\",\r\n\t\t\t\tdeclarations: [{\r\n\t\t\t\t\ttype: \"VariableDeclarator\",\r\n\t\t\t\t\tid: ident(tn),\r\n\t\t\t\t\tinit: value\r\n\t\t\t\t}]\r\n\t\t\t});\r\n\t\t\tfor ( var i = 0; i < target.elts.length; ++i ) {\r\n\t\t\t\tresult.push.apply(result,createTupleUnpackingAssign(\r\n\t\t\t\t\ttarget.elts[i],\r\n\t\t\t\t\t{type: \"MemberExpression\", object: ident(tn), property: literal(i),  computed: true}\r\n\t\t\t\t,ctx));\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\treturn [assignPossiblyWithDeclaration(target, value, ctx)];\r\n\t}\r\n\r\n\tfunction createForLoop(iident, tident, iter, target, body, ctx) {\r\n\r\n\t\tbody = createTupleUnpackingAssign(\r\n\t\t\ttarget, \r\n\t\t\t{type: \"MemberExpression\", object: tident, property: iident, computed: true},\r\n\t\t\tctx\r\n\t\t).concat(body);\r\n\r\n\t\tvar riter = ternary(\r\n\t\t\t{type: \"CallExpression\", callee: makeVariableName(\"Array.isArray\"), arguments:[iter]},\r\n\t\t\titer,\r\n\t\t\t{type: \"CallExpression\", callee: makeVariableName(\"Object.keys\"), arguments:[iter]}\r\n\t\t);\r\n\r\n\t\treturn {\r\n\t\t\ttype: \"ForStatement\",\r\n\t\t\tinit: {\r\n\t\t\t\t\"type\": \"VariableDeclaration\",\r\n\t\t\t\t\"declarations\": [\r\n\t\t\t\t{\r\n\t\t\t\t  \"type\": \"VariableDeclarator\",\r\n\t\t\t\t  \"id\": iident,\r\n\t\t\t\t  \"init\": literal(0)\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t  \"type\": \"VariableDeclarator\",\r\n\t\t\t\t  \"id\": tident,\r\n\t\t\t\t  \"init\": riter\r\n\t\t\t\t}],\r\n\t\t\t\t\"kind\": ctx.varType\r\n\t\t\t},\r\n\t\t\ttest: binOp(iident, '<', {\r\n\t\t\t\ttype: \"MemberExpression\", object: tident, property: {type: \"Identifier\", name: \"length\"}\r\n\t\t\t}),\r\n\t\t\tupdate: {\r\n\t\t\t\t\"type\": \"UpdateExpression\",\r\n\t\t\t\t\"operator\": \"++\",\r\n\t\t\t\t\"prefix\": true,\r\n\t\t\t\t\"argument\": iident\r\n\t\t\t},\r\n\t\t\tbody: {type: \"BlockStatement\", body: body}\r\n\t\t};\r\n\t}\r\n\r\n\tfunction transformFor(node, ctx) {\r\n\t\tvar name = createTempName('idx');\r\n\t\tvar iident = ident(name);\r\n\t\tvar tname = createTempName('target');\r\n\t\tvar tident = {type: \"Identifier\", name: tname};\r\n\t\tvar iter = transform(node.iter, ctx);\r\n\t\tvar body = ensureStatement(transform(node.body, ctx));\r\n\r\n\t\tif ( node.orelse && node.orelse.length > 0 ) abort(\"else: for-else statement unsupported.\");\r\n\t\treturn createForLoop(iident, tident, iter, node.target, body, ctx);\r\n\t}\r\n\r\n\tfunction prepareFunctionBody(node, ctx) {\r\n\t\tvar args = node.args.args.slice(0);\r\n\t\tif  ( ctx.inClass ) {\r\n\t\t\t//TODO: Make sure it's named self, maybe?\r\n\t\t\targs.shift();\r\n\t\t}\r\n\t\tvar hasAnyArguments = args.length > 0 || node.args.vararg || node.args.kwarg;\r\n\t\tvar nctx = {\r\n\t\t\tlocals: Object.create(null),\r\n\t\t\tvarType: ctx.varType\r\n\t\t};\r\n\t\tvar body = ensureStatement(transform(node.body, nctx));\r\n\t\tvar premble = [];\r\n\r\n\t\tif ( ctx.inClass ) {\r\n\t\t\tpremble.push({\r\n\t\t\t\t\"type\": \"VariableDeclaration\",\r\n\t\t\t\t\"declarations\": [{\r\n\t\t\t\t\t\"type\": \"VariableDeclarator\",\r\n\t\t\t\t\t\"id\": ident('self'),\r\n\t\t\t\t\t\"init\": {type: \"ThisExpression\"}\r\n\t\t\t\t}],\r\n\t\t\t\t\"kind\": \"var\"\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif ( hasAnyArguments ) {\r\n\t\t\t\r\n\t\t\tvar hasParams = createTempName('hasParams');\r\n\t\t\tvar param0 = createTempName('param0');\r\n\t\t\tvar realArgCount = createTempName('realArgCount');\r\n\t\t\tvar argLen = makeVariableName('arguments.length');\r\n\t\t\tvar argN = {type: \"MemberExpression\", object: ident('arguments'), property: binOp(argLen, '-', literal(1)), computed: true};\r\n\t\t\tvar argNKeywords = {type: \"MemberExpression\", object: argN, property: ident('keywords'), computed: false};\r\n\r\n\t\t\tpremble.push({\r\n\t\t\t\t\"type\": \"VariableDeclaration\",\r\n\t\t\t\t\"declarations\": [\r\n\t\t\t\t{\r\n\t\t\t\t  \"type\": \"VariableDeclarator\",\r\n\t\t\t\t  \"id\": ident(hasParams),\r\n\t\t\t\t  \"init\": logicOp(binOp(argLen, '>', literal(0)), '&&', logicOp(argN, '&&', argNKeywords))\r\n\t\t\t\t}],\r\n\t\t\t\t\"kind\":  \"var\"\r\n\t\t\t});\r\n\r\n\t\t\tvar main = [];\r\n\t\t\tmain.push({\r\n\t\t\t\t\"type\": \"VariableDeclaration\",\r\n\t\t\t\t\"declarations\": [{\r\n\t\t\t\t\t\"type\": \"VariableDeclarator\",\r\n\t\t\t\t\t\"id\": ident(param0),\r\n\t\t\t\t\t\"init\": ternary(ident(hasParams), argNKeywords, {type: \"ObjectExpression\", properties: []})\r\n\t\t\t\t},{\r\n\t\t\t\t\t\"type\": \"VariableDeclarator\",\r\n\t\t\t\t\t\"id\": ident(realArgCount),\r\n\t\t\t\t\t\"init\": binOp(argLen, '-', ternary(ident(hasParams), literal(1), literal(0)))\r\n\t\t\t\t}],\r\n\t\t\t\t\"kind\": \"var\"\r\n\t\t\t});\r\n\r\n\t\t\tfor ( var i = 0; i < args.length; ++i ) {\r\n\t\t\t\tvar a = node.args.args[i];\r\n\t\t\t\tvar didx = i - (node.args.args.length - node.args.defaults.length);\r\n\t\t\t\tvar def = didx >= 0 ? transform(node.args.defaults[didx], ctx) : ident('undefined');\r\n\r\n\t\t\t\tmain.push({\r\n\t\t\t\t\ttype: \"IfStatement\",\r\n\t\t\t\t\ttest: binOp(ident(realArgCount), '<', literal(i+1)),\r\n\t\t\t\t\tconsequent: ensureStatement({\r\n\t\t\t\t\t\ttype: \"AssignmentExpression\",\r\n\t\t\t\t\t\toperator: \"=\",\r\n\t\t\t\t\t\tleft: ident(a.id),\r\n\t\t\t\t\t\tright: ternary(\r\n\t\t\t\t\t\t\tbinOp(literal(a.id), 'in', ident(param0)),\r\n\t\t\t\t\t\t\t{type: \"MemberExpression\", object: ident(param0), property: ident(a.id), computed: false},\r\n\t\t\t\t\t\t\tdef\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t})\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif ( node.args.vararg ) {\r\n\t\t\t\tmain.push({\r\n\t\t\t\t\t\"type\": \"VariableDeclaration\",\r\n\t\t\t\t\t\"declarations\": [{\r\n\t\t\t\t\t\t\"type\": \"VariableDeclarator\",\r\n\t\t\t\t\t\t\"id\": ident(node.args.vararg),\r\n\t\t\t\t\t\t\"init\": {\r\n\t\t\t\t\t\t\ttype: \"CallExpression\",\r\n\t\t\t\t\t\t\tcallee: makeVariableName(\"Array.prototype.slice.call\"),\r\n\t\t\t\t\t\t\targuments: [ident('arguments'), literal(node.args.args.length), hasAnyArguments ? ident(realArgCount) : undefined]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}],\r\n\t\t\t\t\t\"kind\": \"var\"\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif ( node.args.kwarg ) {\r\n\t\t\t\tfor ( var i = 0; i < node.args.args.length; ++i ) {\r\n\t\t\t\t\tmain.push(ensureStatement({\r\n\t\t\t\t\t\ttype: \"UnaryExpression\",\r\n\t\t\t\t\t\toperator: \"delete\",\r\n\t\t\t\t\t\targument: {\r\n\t\t\t\t\t\t\ttype: \"MemberExpression\",\r\n\t\t\t\t\t\t\tobject: ident(param0),\r\n\t\t\t\t\t\t\tproperty: ident(node.args.args[i].id),\r\n\t\t\t\t\t\t\tcomputed: false\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}));\r\n\t\t\t\t}\r\n\t\t\t\tmain.push({\r\n\t\t\t\t\t\"type\": \"VariableDeclaration\",\r\n\t\t\t\t\t\"declarations\": [{\r\n\t\t\t\t\t\t\"type\": \"VariableDeclarator\",\r\n\t\t\t\t\t\t\"id\": ident(node.args.kwarg),\r\n\t\t\t\t\t\t\"init\": ident(param0)\r\n\t\t\t\t\t}],\r\n\t\t\t\t\t\"kind\": \"var\"\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tpremble = premble.concat(main); //TODO: If we dont have defauts, we can guard this with __hasParams\t\r\n\t\t}\r\n\r\n\r\n\t\tbody = premble.concat(body);\r\n\t\tvar params = transform(args, ctx);\r\n\t\treturn {\r\n\t\t\tpremble: premble,\r\n\t\t\tbody: body,\r\n\t\t\tparams: params\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tfunction transformFunctionDef(node, ctx) {\r\n\t\tvar data = prepareFunctionBody(node, ctx);\r\n\r\n\r\n\r\n\t\tif ( ctx.writeTarget ) {\r\n\t\t\treturn ensureStatement({\r\n\t\t\t\ttype: \"AssignmentExpression\",\r\n\t\t\t\tleft: {type: \"MemberExpression\", object: ctx.writeTarget, property: ident(node.name)},\r\n\t\t\t\tright: {\r\n\t\t\t\t\ttype: \"FunctionExpression\",\r\n\t\t\t\t\tname: ident(node.name),\r\n\t\t\t\t\tparams: data.params,\r\n\t\t\t\t\tbody: {type: \"BlockStatement\", body: data.body}\r\n\t\t\t\t},\r\n\t\t\t\toperator: '='\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\treturn {\r\n\t\t\t\ttype: \"FunctionDeclaration\",\r\n\t\t\t\tid: {type: \"Identifier\", name: node.name.v},\r\n\t\t\t\tparams: data.params,\r\n\t\t\t\tbody: {type: \"BlockStatement\", body: data.body}\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\tfunction transformGlobal(node, ctx) {\r\n\t\tfor ( var i = 0; i < node.names.length; ++i ) {\r\n\t\t\tctx.locals[node.names[i].v] = true;\r\n\t\t}\r\n\t\treturn [];\r\n\t}\r\n\r\n\tfunction transformIf(node, ctx) {\r\n\t\tvar body = ensureStatement(transform(node.body, ctx));\r\n\t\treturn {\r\n\t\t\ttype: \"IfStatement\",\r\n\t\t\ttest: transform(node.test, ctx),\r\n\t\t\tconsequent: {type: \"BlockStatement\", body: body},\r\n\t\t\talternate: (node.orelse && node.orelse.length > 0) ? {type: \"BlockStatement\", body: ensureStatement(transform(node.orelse, ctx))} : undefined\r\n\t\t};\r\n\t}\r\n\r\n\tfunction transformLambda(node, ctx) {\r\n\t\tvar data = prepareFunctionBody(node, ctx);\r\n\t\t\r\n\t\t//TODO: This is pretty sketchy.\r\n\t\tvar last = data.body[data.body.length - 1];\r\n\t\tdata.body[data.body.length - 1] = {type: \"ReturnStatement\", argument: last.expression};\r\n\r\n\t\treturn {\r\n\t\t\ttype: \"FunctionExpression\",\r\n\t\t\tparams: data.params,\r\n\t\t\tbody: {type: \"BlockStatement\", body: data.body}\r\n\t\t};\r\n\t}\r\n\r\n\tfunction transformList(node, ctx) {\r\n\t\tvar call = {\r\n\t\t\ttype: \"CallExpression\",\r\n\t\t\tcallee: makeVariableName(\"__pythonRuntime.objects.list\"),\r\n\t\t\targuments: transform(node.elts, ctx)\r\n\t\t};\r\n\t\treturn call;\r\n\t}\r\n\r\n\tfunction transformListComp(node, ctx) {\t\r\n\t\tvar body = [];\r\n\t\tvar aggrigator = createTempName('result');\r\n\r\n\t\tbody.push({\r\n\t\t\t\"type\": \"VariableDeclaration\",\r\n\t\t\t\"declarations\": [{\r\n\t\t\t\t\"type\": \"VariableDeclarator\",\r\n\t\t\t\t\"id\": ident(aggrigator),\r\n\t\t\t\t\"init\": {\r\n\t\t\t\t\ttype: \"NewExpression\",\r\n\t\t\t\t\tcallee: makeVariableName('__pythonRuntime.objects.list'),\r\n\t\t\t\t\targuments: []\r\n\t\t\t\t}\r\n\t\t\t}],\r\n\t\t\t\"kind\": \"var\"\r\n\t\t});\r\n\r\n\t\tvar insideBody = [];\r\n\r\n\t\tinsideBody.push(ensureStatement({\r\n\t\t\ttype: \"CallExpression\",\r\n\t\t\tcallee: {type: \"MemberExpression\", object: ident(aggrigator), property: ident('push'), computed: false},\r\n\t\t\targuments: [transform(node.elt, ctx)]\r\n\t\t}));\r\n\r\n\t\t//if ( node.generators.length !== 1 ) abort(\"Unsuported number of generators\");\r\n\t\tvar gen = node.generators[0];\r\n\r\n\t\tfor ( var g = node.generators.length - 1; g >= 0; --g ) {\r\n\t\t\tvar idxName = createTempName('idx');\r\n\t\t\tvar listName = createTempName(\"list\" + g);\r\n\t\t\tvar iterName = createTempName('iter');\r\n\t\t\tvar gen = node.generators[g];\r\n\t\t\tfor ( var i = 0; i < gen.ifs.length; ++i ) {\r\n\t\t\t\tinsideBody.unshift({\r\n\t\t\t\t\ttype: \"IfStatement\",\r\n\t\t\t\t\ttest: {type: \"UnaryExpression\", argument: transform(gen.ifs[i], ctx), operator: \"!\"},\r\n\t\t\t\t\tconsequent: {type: \"ContinueStatement\"}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tinsideBody = [\r\n\t\t\t\t{\r\n\t\t\t\t\ttype: \"VariableDeclaration\",\r\n\t\t\t\t\tkind: \"var\",\r\n\t\t\t\t\tdeclarations: [{\r\n\t\t\t\t\t\ttype: \"VariableDeclarator\",\r\n\t\t\t\t\t\tid: ident(listName),\r\n\t\t\t\t\t\tinit: transform(gen.iter, ctx)\r\n\t\t\t\t\t}]\r\n\t\t\t\t},\r\n\t\t\t\tcreateForLoop(ident(idxName), ident(iterName), ident(listName), gen.target, insideBody, ctx)\r\n\t\t\t];\r\n\t\t}\r\n\r\n\t\tbody.push.apply(body, insideBody);\r\n\t\tbody.push({\r\n\t\t\ttype: \"ReturnStatement\",\r\n\t\t\targument: ident(aggrigator)\r\n\t\t});\r\n\r\n\t\tvar expr = {\r\n\t\t\ttype: \"FunctionExpression\",\r\n\t\t\tparams: [],\r\n\t\t\tbody: {type: \"BlockStatement\", body: body}\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\ttype: \"CallExpression\",\r\n\t\t\tcallee: expr,\r\n\t\t\targuments: []\r\n\t\t};\r\n\t}\r\n\r\n\tfunction transformModule(node, ctx) {\r\n\t\treturn {\r\n\t\t\ttype: \"Program\",\r\n\t\t\tbody: ensureStatement(transform(node.body, ctx))\r\n\t\t};\r\n\t}\r\n\r\n\tfunction transformName(node, ctx) {\r\n\t\tif ( node.id.v === 'True' ) return {type: \"Literal\", value: true, raw: \"true\"};\r\n\t\tif ( node.id.v === 'False' ) return {type: \"Literal\", value: false, raw: \"false\"};\r\n\t\tif ( node.id.v === 'None' ) return {type: \"Literal\", value: null, raw: \"null\"};\r\n\r\n\t\tif ( node.id.v === 'random' ) return makeVariableName('__pythonRuntime.imports.random');\r\n\t\treturn ident(node.id);\r\n\t}\r\n\r\n\tfunction transformNum(node, ctx) {\r\n\t\treturn literal(node.n);\r\n\t}\r\n\r\n\tfunction transformPrint(node, ctx) {\r\n\t\treturn {\r\n\t\t\ttype: \"CallExpression\",\r\n\t\t\tcallee: makeVariableName(\"console.log\"),\r\n\t\t\targuments: transform(node.values, ctx)\r\n\t\t};\r\n\t}\r\n\r\n\tfunction transformReturn(node, ctx) {\r\n\t\treturn {\r\n\t\t\ttype: \"ReturnStatement\",\r\n\t\t\targument: node.value ? transform(node.value, ctx) : undefined\r\n\t\t};\r\n\t}\r\n\r\n\tfunction transformStr(node, ctx) {\r\n\t\treturn literal(node.s.valueOf());\r\n\t}\r\n\r\n\tfunction transformTuple(node, ctx) {\r\n\t\tvar call = {\r\n\t\t\ttype: \"CallExpression\",\r\n\t\t\tcallee: makeVariableName(\"__pythonRuntime.objects.tuple\"),\r\n\t\t\targuments: transform(node.elts, ctx)\r\n\t\t};\r\n\t\treturn call;\r\n\t}\r\n\r\n\tfunction transformSubscript(node, ctx) {\r\n\t\t//TODO: Do silly pythonic list offset logic\r\n\t\tvar val = transform(node.value, ctx);\r\n\t\tif ( node.slice.value ) {\r\n\t\t\tvar lu = transform(node.slice.value, ctx);\r\n\t\t\tlu = {\r\n\t\t\t\ttype: \"CallExpression\",\r\n\t\t\t\tcallee: makeVariableName(\"__pythonRuntime.ops.subscriptIndex\"),\r\n\t\t\t\targuments: [val, lu]\r\n\t\t\t};\r\n\t\t\treturn {\r\n\t\t\t\ttype: \"MemberExpression\",\r\n\t\t\t\tcomputed: true,\r\n\t\t\t\tobject: val,\r\n\t\t\t\tproperty: lu\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttype: \"CallExpression\",\r\n\t\t\tcallee: makeVariableName('__pythonRuntime.internal.slice'),\r\n\t\t\targuments:[\r\n\t\t\t\tval,\r\n\t\t\t\tnode.slice.lower ? transform(node.slice.lower, ctx) : ident('undefined'),\r\n\t\t\t\tnode.slice.upper ? transform(node.slice.upper, ctx) : ident('undefined'),\r\n\t\t\t\tnode.slice.step ? transform(node.slice.step, ctx) : ident('undefined'),\r\n\t\t\t]\r\n\t\t};\r\n\t}\r\n\r\n\tfunction transformPass(node, ctx) {\r\n\t\treturn {type: \"EmptyStatement\"};\r\n\t}\r\n\r\n\tfunction transformUnaryOp(node, ctx) {\r\n\t\tvar argument = transform(node.operand, ctx);\r\n\r\n\t\tvar fxOps = {\r\n\t\t\t\"Add\": \"add\",\r\n\t\t\t\"Mult\": \"multiply\",\r\n\t\t};\r\n\t\tvar opName = getOpName(node.op);\r\n\r\n\t\tif ( opName in fxOps  ) {\r\n\t\t\tvar call = {\r\n\t\t\t\ttype: \"CallExpression\",\r\n\t\t\t\tcallee: makeVariableName(\"__pythonRuntime.ops.\" + fxOps[opName]),\r\n\t\t\t\targuments: [argument]\r\n\t\t\t};\r\n\t\t\treturn call;\r\n\t\t}\r\n\r\n\t\tvar operators = {\r\n\t\t\t\"Not\": \"!\",\r\n\t\t\t\"USub\": \"-\",\r\n\t\t\t\"Invert\": \"~\"\r\n\t\t};\r\n\r\n\t\tif ( !(opName in operators) ) abort(\"Unknown unary operator: \" + opName);\r\n\r\n\t\treturn {\r\n\t\t\ttype: \"UnaryExpression\",\r\n\t\t\targument: argument,\r\n\t\t\toperator: operators[opName]\r\n\t\t};\r\n\t\t\r\n\t}\r\n\r\n\tfunction transformWhile(node, ctx) {\r\n\t\tif ( node.orelse && node.orelse.length > 0 ) abort(\"else: statement for while unsupported.\");\r\n\t\treturn {\r\n\t\t\ttype: \"WhileStatement\",\r\n\t\t\ttest: transform(node.test, ctx),\r\n\t\t\tbody: {type: \"BlockStatement\", body: ensureStatement(transform(node.body, ctx))}\r\n\t\t};\t\r\n\t}\r\n\r\n\tmodule.exports = transform;\r\n\r\n\r\n/***/ },\r\n/* 3 */\r\n/***/ function(module, exports, __webpack_require__) {\r\n\r\n\t'use strict';\r\n\r\n\tvar Sk = __webpack_require__(1);\r\n\r\n\tfunction splat(e) {\r\n\t\tconsole.log(\"GOT ERROR!\");\r\n\t\tconsole.log(e, e.extra);\r\n\t\tconsole.log(JSON.stringify(e.extra.node, function(k,  o) {\r\n\t\t\tif ( k == 'type' ) return Sk.nameForToken(o);\r\n\t\t\telse if ( k == 'children' ) return o;\r\n\t\t\telse if ( k ===  '' ) return o;\r\n\t\t\telse if ( !isNaN(parseInt(k)) ) return o;\r\n\t\t\telse return undefined;\r\n\t\t}, '  '));\r\n\t}\r\n\r\n\tfunction improveError(e, options, code) {\r\n\t\tvar r;\r\n\t\tif ( e.context && e.context.length >0 ) {\r\n\t\t\tr = e.context[0];\t\r\n\t\t}\r\n\r\n\t\tif ( e.extra && e.extra.node ) {\r\n\t\t\tif ( !r ) {\r\n\t\t\t\tr = [e.extra.node.loc.start.line,e.extra.node.loc.start.column];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( r ) {\r\n\t\t\tsetErrorPos(e, r[0], r[1]);\r\n\t\t}\r\n\r\n\t\tif ( options.friendlyErrors && e.extra ) {\r\n\t\t\te.message = makeErrorFriendly(e, code);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setErrorPos(e, line, col) {\r\n\t\te.loc = {line: line, column: col};\r\n\t\te.line = line;\r\n\t\te.column = col;\r\n\t}\r\n\r\n\tfunction friendlyString(s) {\r\n\t\tswitch (s) {\r\n\t\tcase 'if_stmt': return 'if statement';\r\n\t\tcase 'while_stmt': return 'while statement';\r\n\t\tcase 'funcdef': return 'function';\r\n\t\tdefault: return '?' + s + '?';\r\n\t\t} \r\n\t}\r\n\r\n\tfunction nodeToType(n) {\r\n\t\tvar type = Sk.nameForToken(n.type);\r\n\t\tif ( type === 'suite' ) return nodeToType(n.children[0]);\r\n\t\treturn friendlyString(type);\r\n\t}\r\n\r\n\tfunction makeErrorFriendly(e, code) {\r\n\t\t//console.log(\"EX\", e.message, e.extra);\r\n\t\tif ( e.extra.kind == \"DAG_MISS\" ) {\r\n\t\t\tif ( e.extra.expected.indexOf('T_COLON') !== -1 ) {\r\n\t\t\t\t//We might be missing a colon.\r\n\t\t\t\tvar after = (e.context && e.context[2] ? e.context[2] : e.extra.found_val).replace(/\\s+$/,'');\r\n\t\t\t\tvar lc = e.extra.node.children[e.extra.node.children.length-1];\r\n\t\t\t\tif ( lc.value === 'else' ) after = 'else';\r\n\r\n\t\t\t\tif ( e.extra.found == 'T_SEMI' ) {\r\n\t\t\t\t\treturn \"Replace the `;` at the end of `\" + after + \"` with a `:`\";\r\n\t\t\t\t} else if ( e.extra.found == 'T_NEWLINE' ) {\r\n\t\t\t\t\treturn \"Need a `:` on the end of the line following `\" + after + \"`.\";\r\n\t\t\t\t} else if ( e.extra.found == 'T_NAME' ) {\r\n\t\t\t\t\treturn \"Need a `:` after `\" + after + \"`.\";\r\n\t\t\t\t} else if ( e.extra.found == 'T_EQUAL' ) {\r\n\t\t\t\t\treturn \"Can't assign to a variable within the condition of an \" + friendlyString(e.extra.inside) + \".  Did you mean to use `==` instead of `=`?\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( e.extra.expected.indexOf('T_DEDENT') !== -1 ) {\r\n\t\t\t\tif ( e.extra.found_val.toLowerCase() === 'else' ) {\r\n\t\t\t\t\treturn \"`else` needs to line up with its `if`.\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn \"Indentation error.\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( e.extra.expected.indexOf('T_INDENT') !== -1 ) {\r\n\t\t\t\tvar lc = e.extra.parent || e.extra.node;\r\n\t\t\t\tvar name  = nodeToType(lc);\r\n\t\t\t\tif ( name === 'if statement' ) {\r\n\t\t\t\t\t//Scan for the most recent part of the ifstatement.\r\n\t\t\t\t\tfor ( var i = 0; i < lc.children.length; ++i ) {\r\n\t\t\t\t\t\tif ( [\"if\", \"elif\", \"else\"].indexOf(lc.children[i].value) !== -1 ) {\r\n\t\t\t\t\t\t\tname = lc.children[i].value + ' statement';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ( lc.value === 'else' ) name = 'else statement';\r\n\t\t\t\treturn 'Empty ' + name + '. Put 4 spaces in front of statements inside the ' + name + '.';\r\n\t\t\t}\r\n\r\n\t\t\tif ( e.extra.found === 'T_NAME' ) {\r\n\t\t\t\tswitch ( e.extra.found_val ) {\r\n\t\t\t\t\tcase 'else':\r\n\t\t\t\t\tcase 'elif':\r\n\t\t\t\t\t\treturn '`' + e.extra.found_val + '` must be paired with an `if`';\r\n\t\t\t\t\tcase 'elseif':\r\n\t\t\t\t\t\treturn '`elseif` should be shortened to `elif`';\r\n\t\t\t\t} \r\n\t\t\t}\r\n\r\n\t\t\tif ( e.extra.found === 'T_AMPER' && e.extra.inside == 'and_expr' ) {\r\n\t\t\t\treturn 'Python uses the word `and` instead of `&&` for boolean AND expressions.';\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( e.extra.inside === 'trailer' ) {\r\n\t\t\t\t//We are parsing either an arglist or a subscript.\r\n\t\t\t\tif ( e.extra.expected.indexOf('T_RPAR') === 0 ) {\r\n\t\t\t\t\t//Expected ), must be a arglsit;\r\n\t\t\t\t\tif ( e.line > e.extra.node.lineno ) {\r\n\t\t\t\t\t\t//Our arglist is incomplete, and we have made it to the next line,.\r\n\t\t\t\t\t\t//Likely they just forgot to close their ()'s\r\n\t\t\t\t\t\tsetErrorPos(e, e.extra.node.lineno, e.extra.node.col_offset);\r\n\t\t\t\t\t\tvar t = e.extra.node.loc;\r\n\t\t\t\t\t\te.context = [\r\n\t\t\t\t\t\t\t[t.start.line,t.start.column],\r\n\t\t\t\t\t\t\t[t.end.line,t.end.column]\r\n\t\t\t\t\t\t];\r\n\t\t\t\t\t\treturn 'Unclosed `(` in function arguments.' + e.extra.node.lineno;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn 'Function calls paramaters must be seperated by `,`s';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( e.extra.found === 'T_INDENT' ) {\r\n\t\t\t\tif ( e.extra.expected.indexOf('stmt') !== -1 ) {\r\n\t\t\t\t\treturn 'Too much indentation at the beginning of this line.';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( e.extra.expected.indexOf('subscriptlist') === 0 ) {\r\n\t\t\t\treturn \"Malformed subscript\";\r\n\t\t\t}\r\n\r\n\t\t\tif ( e.extra.expected.indexOf('T_NEWLINE') !== -1 ) {\r\n\t\t\t\tvar n = e.extra.node;\r\n\t\t\t\t\r\n\t\t\t\tif ( e.extra.node.children[0] ) {\r\n\t\t\t\t\tvar n = e.extra.node.children[0];\r\n\t\t\t\t\tvar previousType = Sk.nameForToken(n.type);\r\n\t\t\t\t\r\n\t\t\t\t\tif ( previousType == 'small_stmt' ) {\r\n\t\t\t\t\t\twhile ( n.children && n.children.length == 1 ) n = n.children[0];\r\n\t\t\t\t\t\tvar what = code.substring(n.range[0], n.range[1]);\r\n\t\t\t\t\t\treturn 'If you want to call `' + what +'` as function, you need `()`\\'s';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn 'Unexpected token: ' + e.message;\r\n\t\t} else if ( e.extra.kind == \"CLASSIFY\" ) {\r\n\t\t\tif ( e.extra.value === '\"' ) return 'Unterminated string. Add a matching `\"` at the end of your string.';\r\n\t\t\treturn 'Unterminated `' + e.extra.value + '`';\r\n\t\t} else if ( e.extra.kind == \"STRING_EOF\" ) {\r\n\t\t\treturn 'Unterminated muti-line string. Add a matching `\"\"\"` at the end of your string.';\r\n\t\t} else if ( e.extra.kind == \"STATEMENT_EOF\" ) {\r\n\t\t\tif ( e.extra.parenlev > 0 ) {\r\n\t\t\t\tvar top = e.extra.parenstack[e.extra.parenstack.length-1];\r\n\t\t\t\tvar kind = top[0];\r\n\t\t\t\tvar types = '([{';\r\n\t\t\t\tvar pair = ')]}';\r\n\t\t\t\tvar close = pair[types.indexOf(kind)];\r\n\t\t\t\tsetErrorPos(e, top[1], top[2]-1);\r\n\t\t\t\treturn 'Unmatched `' + kind + '`.  Every opening `' + kind + '` needs a closing `' + close + '` to match it.';\r\n\t\t\t}\r\n\t\t\treturn e.message;\r\n\t\t}\r\n\r\n\t\treturn e.message;\r\n\t\t\r\n\t\t\r\n\t}\r\n\r\n\tmodule.exports = improveError;\r\n\r\n\r\n/***/ },\r\n/* 4 */\r\n/***/ function(module, exports, __webpack_require__) {\r\n\r\n\t(function (root, factory) {\r\n\t  'use strict';\r\n\t  if(true)\r\n\t    module.exports = factory();\r\n\t  else if(typeof define === 'function' && define.amd)\r\n\t    define([], factory);\r\n\t  else if(typeof exports === 'object')\r\n\t    exports[\"__pythonRuntime\"] = factory();\r\n\t  else\r\n\t    root[\"__pythonRuntime\"] = factory();\r\n\t}(this, function() {\r\n\t  'use strict';\r\n\t  var pythonRuntime = {\r\n\t    internal: {\r\n\t      // Only used within runtime\r\n\t      isSeq: function (a) { return a && (a._type === \"list\" || a._type === \"tuple\"); },\r\n\t      slice: function (obj, start, end, step) {\r\n\t        var slice;\r\n\t        if ( typeof obj === 'string' ) slice = function(x,y) { return obj.substring(x,y); }\r\n\t        else slice = obj.slice.bind(obj);\r\n\r\n\t        if (step == null || step === 0) step = 1; // TODO: step === 0 is a runtime error\r\n\t        if (start == null) {\r\n\t          if (step < 0) start = obj.length - 1;\r\n\t          else start = 0;\r\n\t        } else if (start < 0) start += obj.length;\r\n\t        if (end == null) {\r\n\t          if (step < 0) end = -1;\r\n\t          else end = obj.length;\r\n\t        } else if (end < 0) end += obj.length;\r\n\r\n\t        var ret = new pythonRuntime.objects.list(), tmp, i;\r\n\t        if (step < 0) {\r\n\t          tmp = slice(end + 1, start + 1);\r\n\t          for (i = tmp.length - 1; i >= 0; i += step) ret.append(tmp[i]);\r\n\t        } else {\r\n\t          tmp = slice(start, end);\r\n\t          if (step === 1 && typeof tmp !== 'string') ret = pythonRuntime.utils.createList(tmp);\r\n\t          else for (i = 0; i < tmp.length; i += step) ret.append(tmp[i]);\r\n\t        }\r\n\t        if ( typeof obj === 'string' ) return ret.join('');\r\n\t        return ret;\r\n\t      },\r\n\t      isJSArray: Array.isArray || function(obj) {\r\n\t        return toString.call(obj) === '[object Array]';\r\n\t      }\r\n\t    },\r\n\r\n\t    utils: {\r\n\t      createDict: function () {\r\n\t        var ret = new pythonRuntime.objects.dict();\r\n\t        if (arguments.length === 1 && arguments[0] instanceof Object)\r\n\t          for (var k in arguments[0]) ret[k] = arguments[0][k];\r\n\t        else\r\n\t          throw TypeError(\"createDict expects a single JavaScript object\");\r\n\t        return ret;\r\n\t      },\r\n\t      createParamsObj: function () {\r\n\t        // In: expr, expr, ..., {id:expr, __kwp:true}, {id:expr, __kwp:true}, ...\r\n\t        // Out: {formals:[expr, expr, ...], keywords:{id:expr, id:expr, ...}}\r\n\t        var params = { formals: new pythonRuntime.objects.list(), keywords: new PythonDict() };\r\n\t        for (var i = 0; i < arguments.length; i++) {\r\n\t          if (arguments[i] && arguments[i].__kwp === true) {\r\n\t            for (var k in arguments[i])\r\n\t              if (k !== '__kwp') params.keywords[k] = arguments[i][k];\r\n\t          }\r\n\t          else params.formals.push(arguments[i]);\r\n\t        }\r\n\t        return params;\r\n\t      },\r\n\t      convertToList: function (list) {\r\n\t        Object.defineProperties(list, pythonRuntime.utils.listPropertyDescriptor);\r\n\t        return list;\r\n\t      },\r\n\t      convertToDict: function (dict) {\r\n\t        Object.defineProperties(dict, pythonRuntime.utils.dictPropertyDescriptor);\r\n\t        return dict;\r\n\t      }, \r\n\t      listPropertyDescriptor: {\r\n\t          \"_type\": {\r\n\t            get: function () { return 'list'; },\r\n\t            enumerable: false\r\n\t          },\r\n\t          \"_isPython\": {\r\n\t            get: function () { return true; },\r\n\t            enumerable: false\r\n\t          },\r\n\t          \"append\": {\r\n\t            value: function (x) {\r\n\t              this.push(x);\r\n\t            },\r\n\t            enumerable: false\r\n\t          },\r\n\t          \"clear\": {\r\n\t            value: function () {\r\n\t              this.splice(0, this.length);\r\n\t            },\r\n\t            enumerable: false\r\n\t          },\r\n\t          \"copy\": {\r\n\t            value: function () {\r\n\t              return this.slice(0);\r\n\t            },\r\n\t            enumerable: false\r\n\t          },\r\n\t          \"count\": {\r\n\t            value: function (x) {\r\n\t              var c = 0;\r\n\t              for (var i = 0; i < this.length; i++)\r\n\t                if (this[i] === x) c++;\r\n\t              return c;\r\n\t            },\r\n\t            enumerable: false\r\n\t          },\r\n\t          \"equals\": {\r\n\t            value: function (x) {\r\n\t              try {\r\n\t                if (this.length !== x.length) return false;\r\n\t                for (var i = 0; i < this.length; i++) {\r\n\t                  if (this[i].hasOwnProperty(\"equals\")) {\r\n\t                    if (!this[i].equals(x[i])) return false;\r\n\t                  } else if (this[i] !== x[i]) return false;\r\n\t                }\r\n\t                return true;\r\n\t              }\r\n\t              catch (e) { }\r\n\t              return false;\r\n\t            },\r\n\t            enumerable: false\r\n\t          },\r\n\t          \"extend\": {\r\n\t            value: function (L) {\r\n\t              for (var i = 0; i < L.length; i++) this.push(L[i]);\r\n\t            },\r\n\t            enumerable: false\r\n\t          },\r\n\t          \"index\": {\r\n\t            value: function (x) {\r\n\t              return this.indexOf(x);\r\n\t            },\r\n\t            enumerable: false\r\n\t          },\r\n\t          \"indexOf\": {\r\n\t            value: function (x, fromIndex) {\r\n\t              try {\r\n\t                for (var i = fromIndex ? fromIndex : 0; i < this.length; i++) {\r\n\t                  if (this[i].hasOwnProperty(\"equals\")) {\r\n\t                    if (this[i].equals(x)) return i;\r\n\t                  } else if (this[i] === x) return i;\r\n\t                }\r\n\t              }\r\n\t              catch (e) { }\r\n\t              return -1;\r\n\t            },\r\n\t            enumerable: false\r\n\t          },\r\n\t          \"insert\": {\r\n\t            value: function (i, x) {\r\n\t              this.splice(i, 0, x);\r\n\t            },\r\n\t            enumerable: false\r\n\t          },\r\n\t          \"pop\": {\r\n\t            value: function (i) {\r\n\t              if (arguments.length<1) i = this.length - 1;\r\n\t              var item = this[i];\r\n\t              this.splice(i, 1);\r\n\t              return item;\r\n\t            },\r\n\t            enumerable: false\r\n\t          },\r\n\t          \"_pySlice\": {\r\n\t            value: function (start, end, step) {\r\n\t              return pythonRuntime.internal.slice(this, start, end, step);\r\n\t            },\r\n\t            enumerable: false\r\n\t          },\r\n\t          \"remove\": {\r\n\t            value: function (x) {\r\n\t              this.splice(this.indexOf(x), 1);\r\n\t            },\r\n\t            enumerable: false\r\n\t          },\r\n\t          \"sort\": {\r\n\t            value: function(x, reverse) {\r\n\t              var list2 = this.slice(0);\r\n\t              var apply_key = function(a, numerical) {\r\n\t                var list3 = list2.map(x);\r\n\t                // construct a dict that maps the listay before and after the map\r\n\t                var mapping = {}\r\n\t                for(var i in list3) mapping[list3[i]] = list2[i];\r\n\t                if(numerical)\r\n\t                  list3.sort(function(a, b) { return a - b; });\r\n\t                else\r\n\t                  list3.sort()\r\n\t                for(var i in a) a[i] = mapping[list3[i]];\r\n\t              }\r\n\t              for(var i in this) {\r\n\t                if(typeof this[i] !== 'number' || !isFinite(this[i])) {\r\n\t                  if(typeof x != 'undefined') {\r\n\t                    apply_key(this, false);\r\n\t                  }\r\n\t                  else {\r\n\t                    list2.sort();\r\n\t                    for (var j in this) this[j] = list2[j];\r\n\t                  }\r\n\t                  if(reverse)\r\n\t                    this.reverse();\r\n\t                  return;\r\n\t                }\r\n\t              }\r\n\t              if(typeof x != 'undefined') {\r\n\t                apply_key(this, true);\r\n\t              }\r\n\t              else {\r\n\t                list2.sort(function(a, b) { return a - b; });\r\n\t                for(var i in this) this[i] = list2[i];\r\n\t              }\r\n\t              if(reverse)\r\n\t                this.reverse();\r\n\t            },\r\n\t            enumerable: false\r\n\t          },\r\n\t          \"toString\": {\r\n\t            value: function () {\r\n\t              return '[' + this.join(', ') + ']';\r\n\t            },\r\n\t            enumerable: false\r\n\t          }\r\n\t      },\r\n\t      createList: function () {\r\n\t        var ret = new pythonRuntime.objects.list();\r\n\t        if (arguments.length === 1 && arguments[0] instanceof Array)\r\n\t          for (var i in arguments[0]) ret.push(arguments[0][i]);\r\n\t        else\r\n\t          for (var i in arguments) ret.push(arguments[i]);\r\n\t        return ret;\r\n\t      },\r\n\t      dictPropertyDescriptor: {\r\n\t        \"_type\": {\r\n\t          get: function () { return 'dict';},\r\n\t          enumerable: false\r\n\t        },\r\n\t        \"_isPython\": {\r\n\t          get: function () { return true; },\r\n\t          enumerable: false\r\n\t        },\r\n\t        \"items\": {\r\n\t          value: function () {\r\n\t            var items = new pythonRuntime.objects.list();\r\n\t            for (var k in this) items.append(new pythonRuntime.objects.tuple(k, this[k]));\r\n\t            return items;\r\n\t          },\r\n\t          enumerable: false\r\n\t        },\r\n\t        \"length\": {\r\n\t          get: function () {\r\n\t            return Object.keys(this).length;\r\n\t          },\r\n\t          enumerable: false\r\n\t        },\r\n\t        \"clear\": {\r\n\t          value: function () {\r\n\t            for (var i in this) delete this[i];\r\n\t          },\r\n\t          enumerable: false\r\n\t        },\r\n\t        \"get\": {\r\n\t          value: function (key, def) {\r\n\t            if (key in this) return this[key];\r\n\t            else if (def !== undefined) return def;\r\n\t            return null;\r\n\t          },\r\n\t          enumerable: false\r\n\t        },\r\n\t        \"keys\": {\r\n\t          value: function () {\r\n\t            return Object.keys(this);\r\n\t          },\r\n\t          enumerable: false\r\n\t        },\r\n\t        \"pop\": {\r\n\t          value: function (key, def) {\r\n\t            var value;\r\n\t            if (key in this) {\r\n\t              value = this[key];\r\n\t              delete this[key];\r\n\t            } else if (def !== undefined) value = def;\r\n\t            else return new Error(\"KeyError\");\r\n\t            return value;\r\n\t          },\r\n\t          enumerable: false\r\n\t        }, \"values\": {\r\n\t          value: function () {\r\n\t            var values = new pythonRuntime.objects.list();\r\n\t            for (var key in this) values.append(this[key]);\r\n\t            return values;\r\n\t          },\r\n\t          enumerable: false\r\n\t        }\r\n\t      }\r\n\t    },\r\n\t    ops: {\r\n\t      add: function (a, b) {\r\n\t        if (typeof a === 'object' && pythonRuntime.internal.isSeq(a) && pythonRuntime.internal.isSeq(b)) {\r\n\t          if (a._type !== b._type)\r\n\t            throw TypeError(\"can only concatenate \" + a._type + \" (not '\" + b._type + \"') to \" + a._type);\r\n\t          var ret;\r\n\t          if (a._type === 'list') ret = new pythonRuntime.objects.list();\r\n\t          else if (a._type === 'tuple') ret = new pythonRuntime.objects.tuple();\r\n\t          if (ret) {\r\n\t            for (var i = 0; i < a.length; i++) ret.push(a[i]);\r\n\t            for (var i = 0; i < b.length; i++) ret.push(b[i]);\r\n\t            return ret;\r\n\t          }\r\n\t        }\r\n\t        return a + b;\r\n\t      },\r\n\t      in: function (a, b, n) {\r\n\t        var r = b.hasOwnProperty('indexOf') ? b.indexOf(a) >= 0 : a in b;\r\n\t        return n ? !r : r;\r\n\t      },\r\n\t      multiply: function (a, b) {\r\n\t        // TODO: non-sequence operand must be an integer\r\n\t        if ( typeof a === 'object' ) {\r\n\t          if (pythonRuntime.internal.isSeq(a) && !isNaN(parseInt(b))) {\r\n\t            var ret;\r\n\t            if (a._type === 'list') ret = new pythonRuntime.objects.list();\r\n\t            else if (a._type === 'tuple') ret = new pythonRuntime.objects.tuple();\r\n\t            if (ret) {\r\n\t              for (var i = 0; i < b; i++)\r\n\t                for (var j = 0; j < a.length; j++) ret.push(a[j]);\r\n\t              return ret;\r\n\t            }\r\n\t          } else if (pythonRuntime.internal.isSeq(b) && !isNaN(parseInt(a))) {\r\n\t            var ret;\r\n\t            if (b._type === 'list') ret = new pythonRuntime.objects.list();\r\n\t            else if (b._type === 'tuple') ret = new pythonRuntime.objects.tuple();\r\n\t            if (ret) {\r\n\t              for (var i = 0; i < a; i++)\r\n\t                for (var j = 0; j < b.length; j++) ret.push(b[j]);\r\n\t              return ret;\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t        return a * b;\r\n\t      },\r\n\t      subscriptIndex: function (o, i) {\r\n\t        if ( i >= 0 ) return i;\r\n\t        if ( pythonRuntime.internal.isSeq(o) ) return o.length + i;\r\n\t        if ( pythonRuntime.internal.isJSArray(o) ) return o.length + i;\r\n\t        if ( typeof o === \"string\" ) return o.length + i;\r\n\t        return i;\r\n\t      }\r\n\t    },\r\n\r\n\t    objects: {\r\n\t      dict: function () {\r\n\t        var obj = new PythonDict();\r\n\t        for (var i = 0; i < arguments.length; ++i ) obj[arguments[i][0]] = arguments[i][1];\r\n\t        return obj;\r\n\t      },\r\n\t      list: function () {\r\n\t        var arr = [];\r\n\t        arr.push.apply(arr, arguments);\r\n\t        pythonRuntime.utils.convertToList(arr);\r\n\t        return arr;\r\n\t      },\r\n\t      tuple: function () {\r\n\t        var arr = [];\r\n\t        arr.push.apply(arr, arguments);\r\n\t        Object.defineProperty(arr, \"_type\",\r\n\t        {\r\n\t          get: function () { return 'tuple'; },\r\n\t          enumerable: false\r\n\t        });\r\n\t        Object.defineProperty(arr, \"_isPython\",\r\n\t        {\r\n\t          get: function () { return true; },\r\n\t          enumerable: false\r\n\t        });\r\n\t        Object.defineProperty(arr, \"count\",\r\n\t        {\r\n\t          value: function (x) {\r\n\t            var c = 0;\r\n\t            for (var i = 0; i < this.length; i++)\r\n\t              if (this[i] === x) c++;\r\n\t            return c;\r\n\t          },\r\n\t          enumerable: false\r\n\t        });\r\n\t        Object.defineProperty(arr, \"equals\",\r\n\t        {\r\n\t          value: function (x) {\r\n\t            try {\r\n\t              if (this.length !== x.length) return false;\r\n\t              for (var i = 0; i < this.length; i++) {\r\n\t                if (this[i].hasOwnProperty(\"equals\")) {\r\n\t                  if (!this[i].equals(x[i])) return false;\r\n\t                } else if (this[i] !== x[i]) return false;\r\n\t              }\r\n\t              return true;\r\n\t            }\r\n\t            catch (e) { }\r\n\t            return false;\r\n\t          },\r\n\t          enumerable: false\r\n\t        });\r\n\t        Object.defineProperty(arr, \"index\",\r\n\t        {\r\n\t          value: function (x) {\r\n\t            return this.indexOf(x);\r\n\t          },\r\n\t          enumerable: false\r\n\t        });\r\n\t        Object.defineProperty(arr, \"indexOf\",\r\n\t        {\r\n\t          value: function (x, fromIndex) {\r\n\t            try {\r\n\t              for (var i = fromIndex ? fromIndex : 0; i < this.length; i++) {\r\n\t                if (this[i].hasOwnProperty(\"equals\")) {\r\n\t                  if (this[i].equals(x)) return i;\r\n\t                } else if (this[i] === x) return i;\r\n\t              }\r\n\t            }\r\n\t            catch (e) { }\r\n\t            return -1;\r\n\t          },\r\n\t          enumerable: false\r\n\t        });\r\n\t        Object.defineProperty(arr, \"_pySlice\",\r\n\t        {\r\n\t          value: function (start, end, step) { \r\n\t            return pythonRuntime.internal.slice(this, start, end, step);\r\n\t          },\r\n\t            enumerable: false\r\n\t        });\r\n\t        Object.defineProperty(arr, \"toString\",\r\n\t        {\r\n\t          value: function () {\r\n\t            var s = '(' + this.join(', ');\r\n\t            if (this.length === 1) s += ',';\r\n\t            s += ')';\r\n\t            return s;\r\n\t          },\r\n\t          enumerable: false\r\n\t        });\r\n\t        return arr;\r\n\t      }\r\n\t    },\r\n\r\n\t    // Python built-in functions\r\n\r\n\t    functions: {\r\n\t      abs: function(x) {\r\n\t        return Math.abs(x);\r\n\t      },\r\n\t      all: function(iterable) {\r\n\t        for (var i in iterable) if (pythonRuntime.functions.bool(iterable[i]) !== true) return false;\r\n\t        return true;\r\n\t      },\r\n\t      any: function(iterable) {\r\n\t        for (var i in iterable) if (pythonRuntime.functions.bool(iterable[i]) === true) return true;\r\n\t        return false;\r\n\t      },\r\n\t      ascii: function(obj) {\r\n\t        var s = pythonRuntime.functions.repr(obj),\r\n\t            asc = \"\",\r\n\t            code;\r\n\t        for (var i = 0; i < s.length; i++) {\r\n\t          code = s.charCodeAt(i);\r\n\t          if (code <= 127) asc += s[i];\r\n\t          else if (code <= 0xFF) asc += \"\\\\x\" + code.toString(16);\r\n\t          else if (0xD800 <= code && code <= 0xDBFF) { // UCS-2 for the astral chars\r\n\t            // if (i+1 >= s.length) throw \"High surrogate not followed by low surrogate\"; // Is this needed?\r\n\t            code = ((code-0xD800)*0x400)+(s.charCodeAt(++i)-0xDC00)+0x10000;\r\n\t            asc += \"\\\\U\" + (\"000\"+code.toString(16)).slice(-8);\r\n\t          } else if (code <= 0xFFFF) asc += \"\\\\u\" + (\"0\"+code.toString(16)).slice(-4);\r\n\t          else if (code <= 0x10FFFF) asc += \"\\\\U\" + (\"000\"+code.toString(16)).slice(-8);\r\n\t          else; // Invalid value, should probably throw something. It should never get here though as strings shouldn't contain them in the first place\r\n\t        }\r\n\t        return asc;\r\n\t      },\r\n\t      bool: function(x) {\r\n\t        return !(x === undefined || // No argument\r\n\t                 x === null || // None\r\n\t                 x === false || // False\r\n\t                 x === 0 || // Zero\r\n\t                 x.length === 0 || // Empty Sequence\r\n\t                 // TODO: Empty Mapping, needs more support for python mappings first\r\n\t                 (x.__bool__ !== undefined && x.__bool__() === false) || // If it has bool conversion defined\r\n\t                 (x.__len__ !== undefined && (x.__len__() === false || x.__len__() === 0))); // If it has length conversion defined\r\n\t      },\r\n\t      chr: function(i) {\r\n\t        return String.fromCharCode(i); // TODO: Error code for not 0 <= i <= 1114111\r\n\t      },\r\n\t      divmod: function(a, b) {\r\n\t        return pythonRuntime.objects.tuple(Math.floor(a/b), a%b);\r\n\t      },\r\n\t      enumerate: function(iterable, start) {\r\n\t        start = start || 0;\r\n\t        var ret = new pythonRuntime.objects.list();\r\n\t        for (var i in iterable) ret.push(new pythonRuntime.objects.tuple(start++, iterable[i]));\r\n\t        return ret;\r\n\t      },\r\n\t      filter: function(fn, iterable) {\r\n\t        fn = fn || function () { return true; };\r\n\t        var ret = new pythonRuntime.objects.list();\r\n\t        for (var i in iterable) if (fn(iterable[i])) ret.push(iterable[i]);\r\n\t        return ret;\r\n\t      },\r\n\t      float: function(x) {\r\n\t        if (x === undefined) return 0.0;\r\n\t        else if (typeof x == \"string\") { // TODO: Fix type check\r\n\t          x = x.trim().toLowerCase();\r\n\t          if ((/^[+-]?inf(inity)?$/i).exec(x) !== null) return Infinity*(x[0]===\"-\"?-1:1);\r\n\t          else if ((/^nan$/i).exec(x) !== null) return NaN;\r\n\t          else return parseFloat(x);\r\n\t        } else if (typeof x == \"number\") { // TODO: Fix type check\r\n\t          return x; // TODO: Get python types working right so we can return an actual float\r\n\t        } else {\r\n\t          if (x.__float__ !== undefined) return x.__float__();\r\n\t          else return null; // TODO: Throw TypeError: float() argument must be a string or a number, not '<type of x>'\r\n\t        }\r\n\t      },\r\n\t      hex: function(x) {\r\n\t        return x.toString(16);\r\n\t      },\r\n\t      int: function (s) {\r\n\t        return parseInt(s);\r\n\t      },\r\n\t      len: function (o) {\r\n\t        return o.length;\r\n\t      },\r\n\t      list: function (iterable) {\r\n\t        var ret = new pythonRuntime.objects.list();\r\n\t        if ( arguments.length == 0 ) return ret;\r\n\t        if ( arguments.length > 1 ) throw new TypeError('list() takes at most 1 argument (' + arguments.length + ' given)');\r\n\t        if (iterable instanceof Array) for (var i in iterable) ret.push(iterable[i]);\r\n\t        else for (var i in iterable) ret.push(i);\r\n\t        return ret;\r\n\t      },\r\n\t      map: function(fn, iterable) {\r\n\t        // TODO: support additional iterables passed\r\n\t        var ret = new pythonRuntime.objects.list();\r\n\t        for (var i in iterable) ret.push(fn(iterable[i]));\r\n\t        return ret;\r\n\t      },\r\n\t      max: function(arg1, arg2) {\r\n\t        // TODO: support optional keyword-only arguments\r\n\t        // TODO: empty iterable raises Python ValueError\r\n\t        if (!arg2) { // iterable\r\n\t          var max = null;\r\n\t          for (var i in arg1) if (max === null || arg1[i] > max) max = arg1[i];\r\n\t          return max;\r\n\t        } else return arg1 >= arg2 ? arg1 : arg2;\r\n\t      },\r\n\t      min: function(arg1, arg2) {\r\n\t        // TODO: support optional keyword-only arguments\r\n\t        // TODO: empty iterable raises Python ValueError\r\n\t        if (!arg2) { // iterable\r\n\t          var max = null;\r\n\t          for (var i in arg1) if (max === null || arg1[i] < max) max = arg1[i];\r\n\t          return max;\r\n\t        } else return arg1 <= arg2 ? arg1 : arg2;\r\n\t      },\r\n\t      oct: function(x) {\r\n\t        return x.toString(8);\r\n\t      },\r\n\t      ord: function(c) {\r\n\t        return c.charCodeAt(0);\r\n\t      },\r\n\t      pow: function(x, y, z) {\r\n\t        return z ? Math.pow(x, y) % z : Math.pow(x, y);\r\n\t      },\r\n\t      print: function () {\r\n\t        var s = \"\";\r\n\t        for (var i = 0; i < arguments.length; i++)\r\n\t          s += i === 0 ? arguments[i] : \" \" + arguments[i];\r\n\t        console.log(s);\r\n\t      },\r\n\t      range: function (start, stop, step) {\r\n\t        if (stop === undefined) {\r\n\t          stop = start;\r\n\t          start = 0;\r\n\t          step = 1;\r\n\t        }\r\n\t        else if (step === undefined) step = 1;\r\n\t        var len = ~~((stop - start) / step); //~~ is a fast floor\r\n\t        if ( len < 0 ) return pythonRuntime.utils.convertToList([]);\r\n\t        var r = new Array(len);\r\n\t        var element = 0;\r\n\r\n\t        var i = start;\r\n\t        while (i < stop && step > 0 || i > stop && step < 0) {\r\n\t          r[element++] = i;\r\n\t          i += step;\r\n\t        }\r\n\r\n\t        pythonRuntime.utils.convertToList(r);\r\n\t        return r;\r\n\t      },\r\n\t      repr: function (obj) {\r\n\t        if (typeof obj === 'string') return \"'\" + obj + \"'\"; // TODO: Patch until typesystem comes up.\r\n\t        if (obj.__repr__ !== undefined) return obj.__repr__();\r\n\t        else if (obj.__class__ !== undefined && obj.__class__.module !== undefined && obj.__class__.__name__) {\r\n\t          return '<'+obj.__class__.__module__+'.'+obj.__class__.__name__+' object>';\r\n\t        } else return obj.toString(); // Raise a please report warning here, we should never reach this piece of code\r\n\t      },\r\n\t      reversed: function (seq) {\r\n\t        var ret = new pythonRuntime.objects.list();\r\n\t        for (var i in seq) ret.push(seq[i]);\r\n\t        return ret.reverse();\r\n\t      },\r\n\t      round: function (num, ndigits) {\r\n\t        if (ndigits) {\r\n\t          var scale = Math.pow(10, ndigits);\r\n\t          return Math.round(num * scale) / scale;\r\n\t        }\r\n\t        return Math.round(num);\r\n\t      },\r\n\t      sorted: function (iterable, key, reverse) {\r\n\t        var ret = new pythonRuntime.objects.list();\r\n\t        for (var i in iterable) ret.push(iterable[i]);\r\n\t        if(key) ret.sort(key); else ret.sort();\r\n\t        if (reverse) ret.reverse();\r\n\t        return ret;\r\n\t      },\r\n\t      str: function (obj) {\r\n\t        return obj.toString();\r\n\t      },\r\n\t      sum: function (iterable, start) {\r\n\t        // TODO: start can't be a string\r\n\t        var ret = start || 0;\r\n\t        for (var i in iterable) ret += iterable[i];\r\n\t        return ret;\r\n\t      },\r\n\t      tuple: function (iterable) {\r\n\t        var ret = new pythonRuntime.objects.tuple();\r\n\t        for (var i in iterable) ret.push(iterable[i]);\r\n\t        return ret;\r\n\t      }\r\n\t    },\r\n\r\n\t    // Python imports\r\n\t    // TODO: from x import y, z\r\n\r\n\t    imports: {\r\n\t      random: {\r\n\t        random: function () { return Math.random(); }\r\n\t      }\r\n\t    }\r\n\t  };\r\n\r\n\t  function PythonDict() {\r\n\r\n\t  }\r\n\r\n\t  Object.defineProperties(PythonDict.prototype, pythonRuntime.utils.dictPropertyDescriptor);\r\n\t  return pythonRuntime;\r\n\t}));\r\n\r\n\r\n\r\n/***/ }\r\n/******/ ])\r\n});\r\n;\r\n},{}],2:[function(require,module,exports){\r\nwindow.aetherFilbert = require('skulpty');\r\nwindow.aetherFilbertLoose = require('skulpty');\r\n\r\n},{\"skulpty\":1}]},{},[2]);"]}