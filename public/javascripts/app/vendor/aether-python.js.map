{"version":3,"sources":["bower_components/aether/build/python.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"public/javascripts/app/vendor/aether-python.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"filbert\"] = factory();\n\telse\n\t\troot[\"filbert\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar Sk = __webpack_require__(1);\n\tvar transform = __webpack_require__(2);\n\tvar improveError = __webpack_require__(3);\n\n\tvar defaultOptions = {\n\t\tlocations: true,\n\t\tranges: true,\n\t\tsippets: true,\n\t\tfilename: 'file.py',\n\t\tuseLet: false,\n\t\tfriendlyErrors: true\n\t};\n\n\tfunction rangeToLoc(x, offsets) {\n\t\tvar best = -1;\n\t\tfor ( var i = 0; i < offsets.length; ++i ) {\n\t\t\tif ( offsets[i] > x ) break;\n\t\t\tbest = i;\n\t\t}\n\t\tvar off = best >= 0 ? offsets[best] : 0;\n\t\treturn {line: best+2, column: x - off, pos: x };\n\t}\n\n\tfunction locToRange(line, col, offsets) {\n\t\tvar loff = 0;\n\t\tif ( line > 2 && (line-2) < offsets.length ) loff = offsets[line-2];\n\t\treturn loff + col;\n\t}\n\n\tfunction decorate(n, code, offsets, options) {\n\t\tvar numrange = locToRange(n.lineno, n.col_offset, offsets);\n\n\t\tvar range = [\n\t\t\tnumrange === numrange ? numrange : Infinity,\n\t\t\tnumrange === numrange ? numrange : -Infinity\n\t\t];\n\t\t\n\t\tif ( n.value ) range[1] += (n.value.length);\n\n\t\tif ( n.children )\n\t\tfor ( var i = 0; i < n.children.length; ++i ) {\n\t\t\tvar r = decorate(n.children[i], code, offsets, options);\n\t\t\trange[0] = Math.min(range[0], r[0]);\n\t\t\trange[1] = Math.max(range[1], r[1]);\n\t\t}\n\n\t\tif ( options.ranges ) n.range = range;\n\t\tif ( options.locations ) {\n\t\t\tn.loc = {\n\t\t\t\tstart: rangeToLoc(range[0], offsets),\n\t\t\t\tend: rangeToLoc(range[1], offsets),\n\t\t\t};\n\t\t}\n\t\tif ( options.snippets ) n.str = code.substring(range[0], range[1]);\n\n\t\treturn range;\n\t}\n\n\tfunction parser(code, options) {\n\t\tvar lineOffsets = [];\n\t\tvar idx = -1;\n\t\tvar parse, ast;\n\t\toptions = options || {};\n\t\tfor ( var opt in defaultOptions ) {\n\t\t\tif ( !(opt in options) ) options[opt] = defaultOptions[opt];\n\t\t}\n\n\t\twhile ( true ) {\n\t\t\tidx = code.indexOf(\"\\n\", idx+1);\n\t\t\tif ( idx < 0 ) break;\n\t\t\tlineOffsets.push(idx+1);\n\t\t}\n\n\t\ttry {\n\t\t\tparse = Sk.parse(options.filename, code);\n\t\t\tdecorate(parse.cst, code, lineOffsets, options);\n\t\t\tparse.flags = parse.flags | Sk.Parser.CO_FUTURE_UNICODE_LITERALS; //Enable future unicode literals\n\t\t\tast = Sk.astFromParse(parse.cst, options.filename, parse.flags);\n\t\t} catch ( e ) {\n\t\t\tif ( e.extra && e.extra.node ) decorate(e.extra.node, code, lineOffsets, options);\n\t\t\timproveError(e, options, code);\n\t\t\tif ( e.loc ) {\n\t\t\t\te.pos = locToRange(e.loc.line, e.loc.column, lineOffsets);\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\n\t\t//console.log(JSON.stringify(ast, null, \"  \"));\n\t\tvar ctx = {varType: (options.useLet ? 'let' : 'var')};\n\t\tvar js = transform(ast, ctx);\n\t\treturn js;\n\t}\n\n\tmodule.exports = {\n\t\tparse: parser,\n\t\tpythonRuntime: __webpack_require__(4),\n\t\tdefaultOptions: {runtimeParamName: '__pythonRuntime'}\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\n\t/* ---- /Users/rob/skulpty/lib/preamble.js ---- */ \n\n\tvar goog = {\n\t\tglobal: global\n\t};\n\n\tvar COMPILED = false;\n\n\tgoog.exportSymbol = function() {};\n\tgoog.require = function() {};\n\n\tgoog.inherits = function(childCtor, parentCtor) {\n\t  if ( !parentCtor ) throw new Error(\"Cant inherit from undefined?\");\n\t  /** @constructor */\n\t  function tempCtor() {};\n\t  tempCtor.prototype = parentCtor.prototype;\n\t  childCtor.superClass_ = parentCtor.prototype;\n\t  childCtor.prototype = new tempCtor();\n\t  /** @override */\n\t  childCtor.prototype.constructor = childCtor;\n\t};\n\n\tgoog.asserts = {\n\t\tassert: function(what, why) {\n\t        if ( !what ) throw new Error(\"AssertionFailed:\" + why);\n\t    }\n\t};\n\n\tvar Sk = Sk || {};\n\n\tSk.builtin = Sk.builtin  ||  {};\n\n\tSk.builtin.bool = Boolean;\n\tSk.builtin.int_ = function Int(x) {\n\t  this.v = x;\n\t};\n\n\tSk.builtin.int_.prototype.threshold$ = Infinity;\n\tSk.builtin.int_.prototype.valueOf = function() { return this.v.valueOf(); };\n\n\tSk.builtin.tuple = function(x) {\n\t  this.v = Array.prototype.slice.call(x, 0);\n\t};\n\tSk.builtin.tuple.prototype.sq$length = function() { return this.length; };\n\n\tSk.builtin.float_ = Number;\n\tSk.builtin.long = Number;\n\tSk.builtin.func = function(fx) { return fx; };\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/type.js ---- */ \n\n\tif(Sk.builtin === undefined) {\n\t    Sk.builtin = {};\n\t}\n\n\t/**\n\t * Maps Python dunder names to the Skulpt Javascript function names that\n\t * implement them.\n\t *\n\t * Note: __add__, __mul__, and __rmul__ can be used for either numeric or\n\t * sequence types. Here, they default to the numeric versions (i.e. nb$add,\n\t * nb$multiply, and nb$reflected_multiply). This works because Sk.abstr.binary_op_\n\t * checks for the numeric shortcuts and not the sequence shortcuts when computing\n\t * a binary operation.\n\t *\n\t * Because many of these functions are used in contexts in which Skulpt does not\n\t * [yet] handle suspensions, the assumption is that they must not suspend. However,\n\t * some of these built-in functions are acquiring 'canSuspend' arguments to signal\n\t * where this is not the case. These need to be spliced out of the argument list before\n\t * it is passed to python. Array values in this map contain [dunderName, argumentIdx],\n\t * where argumentIdx specifies the index of the 'canSuspend' boolean argument.\n\t *\n\t * @type {Object}\n\t */\n\tSk.dunderToSkulpt = {\n\t    \"__eq__\": \"ob$eq\",\n\t    \"__ne__\": \"ob$ne\",\n\t    \"__lt__\": \"ob$lt\",\n\t    \"__le__\": \"ob$le\",\n\t    \"__gt__\": \"ob$gt\",\n\t    \"__ge__\": \"ob$ge\",\n\t    \"__hash__\": \"tp$hash\",\n\t    \"__abs__\": \"nb$abs\",\n\t    \"__neg__\": \"nb$negative\",\n\t    \"__pos__\": \"nb$positive\",\n\t    \"__int__\": \"nb$int_\",\n\t    \"__long__\": \"nb$lng\",\n\t    \"__float__\": \"nb$float_\",\n\t    \"__add__\": \"nb$add\",\n\t    \"__radd__\": \"nb$reflected_add\",\n\t    \"__sub__\": \"nb$subtract\",\n\t    \"__rsub__\": \"nb$reflected_subtract\",\n\t    \"__mul__\": \"nb$multiply\",\n\t    \"__rmul__\": \"nb$reflected_multiply\",\n\t    \"__div__\": \"nb$divide\",\n\t    \"__rdiv__\": \"nb$reflected_divide\",\n\t    \"__floordiv__\": \"nb$floor_divide\",\n\t    \"__rfloordiv__\": \"nb$reflected_floor_divide\",\n\t    \"__mod__\": \"nb$remainder\",\n\t    \"__rmod__\": \"nb$reflected_remainder\",\n\t    \"__divmod__\": \"nb$divmod\",\n\t    \"__rdivmod__\": \"nb$reflected_divmod\",\n\t    \"__pow__\": \"nb$power\",\n\t    \"__rpow__\": \"nb$reflected_power\",\n\t    \"__contains__\": \"sq$contains\",\n\t    \"__len__\": [\"sq$length\", 0]\n\t};\n\n\t/**\n\t *\n\t * @constructor\n\t *\n\t * @param {*} name name or object to get type of, if only one arg\n\t *\n\t * @param {Sk.builtin.tuple=} bases\n\t *\n\t * @param {Object=} dict\n\t *\n\t *\n\t * This type represents the type of `type'. *Calling* an instance of\n\t * this builtin type named \"type\" creates class objects. The resulting\n\t * class objects will have various tp$xyz attributes on them that allow\n\t * for the various operations on that object.\n\t *\n\t * calling the type or calling an instance of the type? or both?\n\t */\n\tSk.builtin.type = function (name, bases, dict) {\n\t    var mro;\n\t    var obj;\n\t    var klass;\n\t    var v;\n\t    if (bases === undefined && dict === undefined) {\n\t        // 1 arg version of type()\n\t        // the argument is an object, not a name and returns a type object\n\t        obj = name;\n\t        return obj.ob$type;\n\t    } else {\n\n\t        // argument dict must be of type dict\n\t        if(dict.tp$name !== \"dict\") {\n\t            throw new Sk.builtin.TypeError(\"type() argument 3 must be dict, not \" + Sk.abstr.typeName(dict));\n\t        }\n\n\t        // checks if name must be string\n\t        if(!Sk.builtin.checkString(name)) {\n\t            throw new Sk.builtin.TypeError(\"type() argument 1 must be str, not \" + Sk.abstr.typeName(name));\n\t        }\n\n\t        // argument bases must be of type tuple\n\t        if(bases.tp$name !== \"tuple\") {\n\t            throw new Sk.builtin.TypeError(\"type() argument 2 must be tuple, not \" + Sk.abstr.typeName(bases));\n\t        }\n\n\t        // type building version of type\n\n\t        // dict is the result of running the classes code object\n\t        // (basically the dict of functions). those become the prototype\n\t        // object of the class).\n\t        /**\n\t        * @constructor\n\t        */\n\t        klass = function (kwdict, varargseq, kws, args, canSuspend) {\n\t            var init;\n\t            var self = this;\n\t            var s;\n\t            var args_copy;\n\t            if (!(this instanceof klass)) {\n\t                return new klass(kwdict, varargseq, kws, args, canSuspend);\n\t            }\n\n\t            args = args || [];\n\t            self[\"$d\"] = new Sk.builtin.dict([]);\n\t            self[\"$d\"].mp$ass_subscript(new Sk.builtin.str(\"__dict__\"), self[\"$d\"]);\n\n\t            if (klass.prototype.tp$base !== undefined) {\n\t                if (klass.prototype.tp$base.sk$klass) {\n\t                    klass.prototype.tp$base.call(this, kwdict, varargseq, kws, args.slice(), canSuspend);\n\t                } else {\n\t                    // Call super constructor if subclass of a builtin\n\t                    args_copy = args.slice();\n\t                    args_copy.unshift(klass, this);\n\t                    Sk.abstr.superConstructor.apply(undefined, args_copy);\n\t                }\n\t            }\n\n\t            init = Sk.builtin.type.typeLookup(self.ob$type, \"__init__\");\n\t            if (init !== undefined) {\n\t                // return should be None or throw a TypeError otherwise\n\t                args.unshift(self);\n\t                s = Sk.misceval.applyOrSuspend(init, kwdict, varargseq, kws, args);\n\n\t                return (function doSusp(s) {\n\t                    if (s instanceof Sk.misceval.Suspension) {\n\t                        // TODO I (Meredydd) don't know whether we are ever called\n\t                        // from anywhere except Sk.misceval.applyOrSuspend().\n\t                        // If we're not, we don't need a canSuspend parameter at all.\n\t                        if (canSuspend) {\n\t                            return new Sk.misceval.Suspension(doSusp, s);\n\t                        } else {\n\t                            return Sk.misceval.retryOptionalSuspensionOrThrow(s);\n\t                        }\n\t                    } else {\n\t                        return self;\n\t                    }\n\t                })(s);\n\t            }\n\n\t            return self;\n\t        };\n\n\t        var _name = Sk.ffi.remapToJs(name); // unwrap name string to js for latter use\n\n\t        var inheritsFromObject = false, inheritsBuiltin = false;\n\n\t        if (bases.v.length === 0 && Sk.python3) {\n\t            // new style class, inherits from object by default\n\t            inheritsFromObject = true;\n\t            Sk.abstr.setUpInheritance(_name, klass, Sk.builtin.object);\n\t        }\n\n\t        var parent, it, firstAncestor, builtin_bases = [];\n\t        // Set up inheritance from any builtins\n\t        for (it = bases.tp$iter(), parent = it.tp$iternext(); parent !== undefined; parent = it.tp$iternext()) {\n\t            if (firstAncestor === undefined) {\n\t                firstAncestor = parent;\n\t            }\n\t            if (parent.prototype instanceof Sk.builtin.object || parent === Sk.builtin.object) {\n\n\t                while (parent.sk$klass && parent.prototype.tp$base) {\n\t                    parent = parent.prototype.tp$base;\n\t                }\n\n\t                if (!parent.sk$klass && builtin_bases.indexOf(parent) < 0) {\n\t                    builtin_bases.push(parent);\n\t                }\n\n\t                // This class inherits from Sk.builtin.object at some level\n\t                inheritsFromObject = true;\n\t            }\n\t        }\n\n\t        if (builtin_bases.length > 1) {\n\t            throw new Sk.builtin.TypeError(\"Multiple inheritance with more than one builtin type is unsupported\");\n\t        }\n\n\t        // Javascript does not support multiple inheritance, so only the first\n\t        // base (if any) will directly inherit in Javascript\n\t        if (firstAncestor !== undefined) {\n\t            goog.inherits(klass, firstAncestor);\n\n\t            if (firstAncestor.prototype instanceof Sk.builtin.object || firstAncestor === Sk.builtin.object) {\n\t                klass.prototype.tp$base = firstAncestor;\n\t            }\n\t        }\n\n\t        klass.prototype.tp$name = _name;\n\t        klass.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(_name, klass);\n\n\t        if (!inheritsFromObject) {\n\t            // old style class, does not inherit from object\n\t            klass.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\t            klass.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\n\t        }\n\n\t        // set __module__ if not present (required by direct type(name, bases, dict) calls)\n\t        var module_lk = new Sk.builtin.str(\"__module__\");\n\t        if(dict.mp$lookup(module_lk) === undefined) {\n\t            dict.mp$ass_subscript(module_lk, Sk.globals[\"__name__\"]);\n\t        }\n\n\t        // copy properties into our klass object\n\t        // uses python iter methods\n\t        var k;\n\t        for (it = dict.tp$iter(), k = it.tp$iternext(); k !== undefined; k = it.tp$iternext()) {\n\t            v = dict.mp$subscript(k);\n\t            if (v === undefined) {\n\t                v = null;\n\t            }\n\t            klass.prototype[k.v] = v;\n\t            klass[k.v] = v;\n\t        }\n\n\t        klass[\"__class__\"] = klass;\n\t        klass[\"__name__\"] = name;\n\t        klass.sk$klass = true;\n\t        klass.prototype.tp$descr_get = function () {\n\t            goog.asserts.fail(\"in type tp$descr_get\");\n\t        };\n\t        klass.prototype[\"$r\"] = function () {\n\t            var cname;\n\t            var mod;\n\t            // TODO use Sk.abstr.gattr() here so __repr__ can be dynamically provided (eg by __getattr__())\n\t            var reprf = this.tp$getattr(\"__repr__\");\n\t            if (reprf !== undefined && reprf.im_func !== Sk.builtin.object.prototype[\"__repr__\"]) {\n\t                return Sk.misceval.apply(reprf, undefined, undefined, undefined, []);\n\t            }\n\n\t            if ((klass.prototype.tp$base !== undefined) &&\n\t                (klass.prototype.tp$base !== Sk.builtin.object) &&\n\t                (klass.prototype.tp$base.prototype[\"$r\"] !== undefined)) {\n\t                // If subclass of a builtin which is not object, use that class' repr\n\t                return klass.prototype.tp$base.prototype[\"$r\"].call(this);\n\t            } else {\n\t                // Else, use default repr for a user-defined class instance\n\t                mod = dict.mp$subscript(module_lk); // lookup __module__\n\t                cname = \"\";\n\t                if (mod) {\n\t                    cname = mod.v + \".\";\n\t                }\n\t                return new Sk.builtin.str(\"<\" + cname + _name + \" object>\");\n\t            }\n\t        };\n\t        klass.prototype.tp$str = function () {\n\t            // TODO use Sk.abstr.gattr() here so __str__ can be dynamically provided (eg by __getattr__())\n\t            var strf = this.tp$getattr(\"__str__\");\n\t            if (strf !== undefined && strf.im_func !== Sk.builtin.object.prototype[\"__str__\"]) {\n\t                return Sk.misceval.apply(strf, undefined, undefined, undefined, []);\n\t            }\n\t            if ((klass.prototype.tp$base !== undefined) &&\n\t                (klass.prototype.tp$base !== Sk.builtin.object) &&\n\t                (klass.prototype.tp$base.prototype.tp$str !== undefined)) {\n\t                // If subclass of a builtin which is not object, use that class' repr\n\t                return klass.prototype.tp$base.prototype.tp$str.call(this);\n\t            }\n\t            return this[\"$r\"]();\n\t        };\n\t        klass.prototype.tp$length = function (canSuspend) {\n\t            var r = Sk.misceval.chain(Sk.abstr.gattr(this, \"__len__\", canSuspend), function(lenf) {\n\t                return Sk.misceval.applyOrSuspend(lenf, undefined, undefined, undefined, []);\n\t            });\n\t            return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n\t        };\n\t        klass.prototype.tp$call = function (args, kw) {\n\t            return Sk.misceval.chain(Sk.abstr.gattr(this, \"__call__\", true), function(callf) {\n\t                return Sk.misceval.applyOrSuspend(callf, undefined, undefined, kw, args);\n\t            });\n\t        };\n\t        klass.prototype.tp$iter = function () {\n\t            var iterf = Sk.abstr.gattr(this, \"__iter__\", false);\n\t            return Sk.misceval.callsim(iterf);\n\t        };\n\t        klass.prototype.tp$iternext = function (canSuspend) {\n\t            var self = this;\n\t            var r = Sk.misceval.chain(\n\t                Sk.misceval.tryCatch(function() {\n\t                    return Sk.abstr.gattr(self, \"next\", canSuspend);\n\t                }, function(e) {\n\t                    if (e instanceof Sk.builtin.AttributeError) {\n\t                        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(self) + \"' object is not iterable\");\n\t                    } else {\n\t                        throw e;\n\t                    }\n\t                }),\n\t            function(/** {Object} */ iternextf) {\n\t                return Sk.misceval.tryCatch(function() {\n\t                    return Sk.misceval.callsimOrSuspend(iternextf);\n\t                }, function(e) {\n\t                    if (e instanceof Sk.builtin.StopIteration) {\n\t                        return undefined;\n\t                    } else {\n\t                        throw e;\n\t                    }\n\t                });\n\t            });\n\n\t            return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n\t        };\n\n\t        klass.prototype.tp$getitem = function (key, canSuspend) {\n\t            var getf = Sk.abstr.gattr(this, \"__getitem__\", canSuspend), r;\n\t            if (getf !== undefined) {\n\t                r = Sk.misceval.applyOrSuspend(getf, undefined, undefined, undefined, [key]);\n\t                return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n\t            }\n\t            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(this) + \"' object does not support indexing\");\n\t        };\n\t        klass.prototype.tp$setitem = function (key, value, canSuspend) {\n\t            var setf = Sk.abstr.gattr(this, \"__setitem__\", canSuspend), r;\n\t            if (setf !== undefined) {\n\t                r = Sk.misceval.applyOrSuspend(setf, undefined, undefined, undefined, [key, value]);\n\t                return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n\t            }\n\t            throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(this) + \"' object does not support item assignment\");\n\t        };\n\n\t        if (bases) {\n\t            //print(\"building mro for\", name);\n\t            //for (var i = 0; i < bases.length; ++i)\n\t            //print(\"base[\" + i + \"]=\" + bases[i].tp$name);\n\t            klass[\"$d\"] = new Sk.builtin.dict([]);\n\t            klass[\"$d\"].mp$ass_subscript(Sk.builtin.type.basesStr_, bases);\n\t            mro = Sk.builtin.type.buildMRO(klass);\n\t            klass[\"$d\"].mp$ass_subscript(Sk.builtin.type.mroStr_, mro);\n\t            klass.tp$mro = mro;\n\t            //print(\"mro result\", Sk.builtin.repr(mro).v);\n\t        }\n\n\t        // fix for class attributes\n\t        klass.tp$setattr = Sk.builtin.type.prototype.tp$setattr;\n\n\t        var shortcutDunder = function (skulpt_name, magic_name, magic_func, canSuspendIdx) {\n\t            klass.prototype[skulpt_name] = function () {\n\t                var args = Array.prototype.slice.call(arguments), canSuspend;\n\t                args.unshift(magic_func, this);\n\n\t                if (canSuspendIdx) {\n\t                    canSuspend = args[canSuspendIdx+1];\n\t                    args.splice(canSuspendIdx+1, 1);\n\t                    if (canSuspend) {\n\t                        return Sk.misceval.callsimOrSuspend.apply(undefined, args);\n\t                    }\n\t                }\n\t                return Sk.misceval.callsim.apply(undefined, args);\n\t            };\n\t        };\n\n\t        // Register skulpt shortcuts to magic methods defined by this class.\n\t        // TODO: This is somewhat problematic, as it means that dynamically defined\n\t        // methods (eg those returned by __getattr__()) cannot be used by these magic\n\t        // functions.\n\t        var dunder, skulpt_name, canSuspendIdx;\n\t        for (dunder in Sk.dunderToSkulpt) {\n\t            skulpt_name = Sk.dunderToSkulpt[dunder];\n\t            if (typeof(skulpt_name) === \"string\") {\n\t                canSuspendIdx = null;\n\t            } else {\n\t                canSuspendIdx = skulpt_name[1];\n\t                skulpt_name = skulpt_name[0];\n\t            }\n\n\t            if (klass[dunder]) {\n\t                // scope workaround\n\t                shortcutDunder(skulpt_name, dunder, klass[dunder], canSuspendIdx);\n\t            }\n\t        }\n\n\t        return klass;\n\t    }\n\n\t};\n\n\t/**\n\t *\n\t */\n\tSk.builtin.type.makeTypeObj = function (name, newedInstanceOfType) {\n\t    Sk.builtin.type.makeIntoTypeObj(name, newedInstanceOfType);\n\t    return newedInstanceOfType;\n\t};\n\n\tSk.builtin.type.makeIntoTypeObj = function (name, t) {\n\t    goog.asserts.assert(name !== undefined);\n\t    goog.asserts.assert(t !== undefined);\n\t    t.ob$type = Sk.builtin.type;\n\t    t.tp$name = name;\n\t    t[\"$r\"] = function () {\n\t        var ctype;\n\t        var mod = t.__module__;\n\t        var cname = \"\";\n\t        if (mod) {\n\t            cname = mod.v + \".\";\n\t        }\n\t        ctype = \"class\";\n\t        if (!mod && !t.sk$klass && !Sk.python3) {\n\t            ctype = \"type\";\n\t        }\n\t        return new Sk.builtin.str(\"<\" + ctype + \" '\" + cname + t.tp$name + \"'>\");\n\t    };\n\t    t.tp$str = undefined;\n\t    t.tp$getattr = Sk.builtin.type.prototype.tp$getattr;\n\t    t.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\n\t    t.tp$richcompare = Sk.builtin.type.prototype.tp$richcompare;\n\t    t.sk$type = true;\n\n\t    return t;\n\t};\n\n\tSk.builtin.type.ob$type = Sk.builtin.type;\n\tSk.builtin.type.tp$name = \"type\";\n\tSk.builtin.type[\"$r\"] = function () {\n\t    if(Sk.python3) {\n\t        return new Sk.builtin.str(\"<class 'type'>\");\n\t    } else {\n\t        return new Sk.builtin.str(\"<type 'type'>\");\n\t    }\n\t};\n\n\t//Sk.builtin.type.prototype.tp$descr_get = function() { print(\"in type descr_get\"); };\n\n\t//Sk.builtin.type.prototype.tp$name = \"type\";\n\n\t// basically the same as GenericGetAttr except looks in the proto instead\n\tSk.builtin.type.prototype.tp$getattr = function (name) {\n\t    var res;\n\t    var tp = this;\n\t    var descr;\n\t    var f;\n\n\t    if (this[\"$d\"]) {\n\t        res = this[\"$d\"].mp$lookup(new Sk.builtin.str(name));\n\t        if (res !== undefined) {\n\t            return res;\n\t        }\n\t    }\n\n\t    descr = Sk.builtin.type.typeLookup(tp, name);\n\n\t    //print(\"type.tpgetattr descr\", descr, descr.tp$name, descr.func_code, name);\n\t    if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {\n\t        f = descr.ob$type.tp$descr_get;\n\t        // todo;if (f && descr.tp$descr_set) // is a data descriptor if it has a set\n\t        // return f.call(descr, this, this.ob$type);\n\t    }\n\n\t    if (f) {\n\t        // non-data descriptor\n\t        return f.call(descr, null, tp);\n\t    }\n\n\t    if (descr !== undefined) {\n\t        return descr;\n\t    }\n\n\t    return undefined;\n\t};\n\n\tSk.builtin.type.prototype.tp$setattr = function (name, value) {\n\t    // class attributes are direct properties of the object\n\t    this[name] = value;\n\t};\n\n\tSk.builtin.type.typeLookup = function (type, name) {\n\t    var mro = type.tp$mro;\n\t    var pyname = new Sk.builtin.str(name);\n\t    var base;\n\t    var res;\n\t    var i;\n\n\t    // todo; probably should fix this, used for builtin types to get stuff\n\t    // from prototype\n\t    if (!mro) {\n\t        if (type.prototype) {\n\t            return type.prototype[name];\n\t        }\n\t        return undefined;\n\t    }\n\n\t    for (i = 0; i < mro.v.length; ++i) {\n\t        base = mro.v[i];\n\t        if (base.hasOwnProperty(name)) {\n\t            return base[name];\n\t        }\n\t        res = base[\"$d\"].mp$lookup(pyname);\n\t        if (res !== undefined) {\n\t            return res;\n\t        }\n\t        if (base.prototype && base.prototype[name] !== undefined) {\n\t            return base.prototype[name];\n\t        }\n\t    }\n\n\t    return undefined;\n\t};\n\n\tSk.builtin.type.mroMerge_ = function (seqs) {\n\t    /*\n\t     var tmp = [];\n\t     for (var i = 0; i < seqs.length; ++i)\n\t     {\n\t     tmp.push(new Sk.builtin.list(seqs[i]));\n\t     }\n\t     print(Sk.builtin.repr(new Sk.builtin.list(tmp)).v);\n\t     */\n\t    var seq;\n\t    var i;\n\t    var next;\n\t    var k;\n\t    var sseq;\n\t    var j;\n\t    var cand;\n\t    var cands;\n\t    var res = [];\n\t    for (; ;) {\n\t        for (i = 0; i < seqs.length; ++i) {\n\t            seq = seqs[i];\n\t            if (seq.length !== 0) {\n\t                break;\n\t            }\n\t        }\n\t        if (i === seqs.length) { // all empty\n\t            return res;\n\t        }\n\t        cands = [];\n\t        for (i = 0; i < seqs.length; ++i) {\n\t            seq = seqs[i];\n\t            //print(\"XXX\", Sk.builtin.repr(new Sk.builtin.list(seq)).v);\n\t            if (seq.length !== 0) {\n\t                cand = seq[0];\n\t                //print(\"CAND\", Sk.builtin.repr(cand).v);\n\t                OUTER:\n\t                    for (j = 0; j < seqs.length; ++j) {\n\t                        sseq = seqs[j];\n\t                        for (k = 1; k < sseq.length; ++k) {\n\t                            if (sseq[k] === cand) {\n\t                                break OUTER;\n\t                            }\n\t                        }\n\t                    }\n\n\t                // cand is not in any sequences' tail -> constraint-free\n\t                if (j === seqs.length) {\n\t                    cands.push(cand);\n\t                }\n\t            }\n\t        }\n\n\t        if (cands.length === 0) {\n\t            throw new Sk.builtin.TypeError(\"Inconsistent precedences in type hierarchy\");\n\t        }\n\n\t        next = cands[0];\n\t        // append next to result and remove from sequences\n\t        res.push(next);\n\t        for (i = 0; i < seqs.length; ++i) {\n\t            seq = seqs[i];\n\t            if (seq.length > 0 && seq[0] === next) {\n\t                seq.splice(0, 1);\n\t            }\n\t        }\n\t    }\n\t};\n\n\tSk.builtin.type.buildMRO_ = function (klass) {\n\t    // MERGE(klass + mro(bases) + bases)\n\t    var i;\n\t    var bases;\n\t    var all = [\n\t        [klass]\n\t    ];\n\n\t    //Sk.debugout(\"buildMRO for\", klass.tp$name);\n\n\t    var kbases = klass[\"$d\"].mp$subscript(Sk.builtin.type.basesStr_);\n\t    for (i = 0; i < kbases.v.length; ++i) {\n\t        all.push(Sk.builtin.type.buildMRO_(kbases.v[i]));\n\t    }\n\n\t    bases = [];\n\t    for (i = 0; i < kbases.v.length; ++i) {\n\t        bases.push(kbases.v[i]);\n\t    }\n\t    all.push(bases);\n\n\t    return Sk.builtin.type.mroMerge_(all);\n\t};\n\n\t/*\n\t * C3 MRO (aka CPL) linearization. Figures out which order to search through\n\t * base classes to determine what should override what. C3 does the \"right\n\t * thing\", and it's what Python has used since 2.3.\n\t *\n\t * Kind of complicated to explain, but not really that complicated in\n\t * implementation. Explanations:\n\t *\n\t * http://people.csail.mit.edu/jrb/goo/manual.43/goomanual_55.html\n\t * http://www.python.org/download/releases/2.3/mro/\n\t * http://192.220.96.201/dylan/linearization-oopsla96.html\n\t *\n\t * This implementation is based on a post by Samuele Pedroni on python-dev\n\t * (http://mail.python.org/pipermail/python-dev/2002-October/029176.html) when\n\t * discussing its addition to Python.\n\t */\n\tSk.builtin.type.buildMRO = function (klass) {\n\t    return new Sk.builtin.tuple(Sk.builtin.type.buildMRO_(klass));\n\t};\n\n\tSk.builtin.type.prototype.tp$richcompare = function (other, op) {\n\t    var r2;\n\t    var r1;\n\t    if (other.ob$type != Sk.builtin.type) {\n\t        return undefined;\n\t    }\n\t    if (!this[\"$r\"] || !other[\"$r\"]) {\n\t        return undefined;\n\t    }\n\t    r1 = new Sk.builtin.str(this[\"$r\"]().v.slice(1,6));\n\t    r2 = new Sk.builtin.str(other[\"$r\"]().v.slice(1,6));\n\t    if (this[\"$r\"]().v.slice(1,6) !== \"class\") {\n\t        r1 = this[\"$r\"]();\n\t        r2 = other[\"$r\"]();\n\t    }\n\t    return r1.tp$richcompare(r2, op);\n\t};\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/abstract.js ---- */ \n\n\t/**\n\t * @namespace Sk.abstr\n\t *\n\t */\n\tSk.abstr = {};\n\n\t//\n\t// Number\n\t//\n\n\tSk.abstr.typeName = function (v) {\n\t    var vtypename;\n\t    if (v.tp$name !== undefined) {\n\t        vtypename = v.tp$name;\n\t    } else {\n\t        vtypename = \"<invalid type>\";\n\t    }\n\t    return vtypename;\n\t};\n\n\tSk.abstr.binop_type_error = function (v, w, name) {\n\t    var vtypename = Sk.abstr.typeName(v),\n\t        wtypename = Sk.abstr.typeName(w);\n\n\t    throw new Sk.builtin.TypeError(\"unsupported operand type(s) for \" + name + \": '\" + vtypename + \"' and '\" + wtypename + \"'\");\n\t};\n\n\tSk.abstr.unop_type_error = function (v, name) {\n\t    var vtypename = Sk.abstr.typeName(v),\n\t        uop = {\n\t            \"UAdd\"  : \"+\",\n\t            \"USub\"  : \"-\",\n\t            \"Invert\": \"~\"\n\t        }[name];\n\n\t    throw new Sk.builtin.TypeError(\"bad operand type for unary \" + uop + \": '\" + vtypename + \"'\");\n\t};\n\n\t/**\n\t * lookup and return the LHS object slot function method.  This coudl be either a builtin slot function or a dunder method defined by the user.\n\t * @param obj\n\t * @param name\n\t * @returns {Object|null|undefined}\n\t * @private\n\t */\n\tSk.abstr.boNameToSlotFuncLhs_ = function (obj, name) {\n\t    if (obj === null) {\n\t        return undefined;\n\t    }\n\n\t    switch (name) {\n\t    case \"Add\":\n\t        return obj.nb$add ? obj.nb$add : obj[\"__add__\"];\n\t    case \"Sub\":\n\t        return obj.nb$subtract ? obj.nb$subtract : obj[\"__sub__\"];\n\t    case \"Mult\":\n\t        return obj.nb$multiply ? obj.nb$multiply : obj[\"__mul__\"];\n\t    case \"Div\":\n\t        return obj.nb$divide ? obj.nb$divide : obj[\"__div__\"];\n\t    case \"FloorDiv\":\n\t        return obj.nb$floor_divide ? obj.nb$floor_divide : obj[\"__floordiv__\"];\n\t    case \"Mod\":\n\t        return obj.nb$remainder ? obj.nb$remainder : obj[\"__mod__\"];\n\t    case \"DivMod\":\n\t        return obj.nb$divmod ? obj.nb$divmod : obj[\"__divmod__\"];\n\t    case \"Pow\":\n\t        return obj.nb$power ? obj.nb$power : obj[\"__pow__\"];\n\t    case \"LShift\":\n\t        return obj.nb$lshift ? obj.nb$lshift : obj[\"__lshift__\"];\n\t    case \"RShift\":\n\t        return obj.nb$rshift ? obj.nb$rshift : obj[\"__rshift__\"];\n\t    case \"BitAnd\":\n\t        return obj.nb$and ? obj.nb$and : obj[\"__and__\"];\n\t    case \"BitXor\":\n\t        return obj.nb$xor ? obj.nb$xor : obj[\"__xor__\"];\n\t    case \"BitOr\":\n\t        return obj.nb$or ? obj.nb$or : obj[\"__or__\"];\n\t    }\n\t};\n\n\tSk.abstr.boNameToSlotFuncRhs_ = function (obj, name) {\n\t    if (obj === null) {\n\t        return undefined;\n\t    }\n\n\t    switch (name) {\n\t    case \"Add\":\n\t        return obj.nb$reflected_add ? obj.nb$reflected_add : obj[\"__radd__\"];\n\t    case \"Sub\":\n\t        return obj.nb$reflected_subtract ? obj.nb$reflected_subtract : obj[\"__rsub__\"];\n\t    case \"Mult\":\n\t        return obj.nb$reflected_multiply ? obj.nb$reflected_multiply : obj[\"__rmul__\"];\n\t    case \"Div\":\n\t        return obj.nb$reflected_divide ? obj.nb$reflected_divide : obj[\"__rdiv__\"];\n\t    case \"FloorDiv\":\n\t        return obj.nb$reflected_floor_divide ? obj.nb$reflected_floor_divide : obj[\"__rfloordiv__\"];\n\t    case \"Mod\":\n\t        return obj.nb$reflected_remainder ? obj.nb$reflected_remainder : obj[\"__rmod__\"];\n\t    case \"DivMod\":\n\t        return obj.nb$reflected_divmod ? obj.nb$reflected_divmod : obj[\"__rdivmod__\"];\n\t    case \"Pow\":\n\t        return obj.nb$reflected_power ? obj.nb$reflected_power : obj[\"__rpow__\"];\n\t    case \"LShift\":\n\t        return obj.nb$reflected_lshift ? obj.nb$reflected_lshift : obj[\"__rlshift__\"];\n\t    case \"RShift\":\n\t        return obj.nb$reflected_rshift ? obj.nb$reflected_rshift : obj[\"__rrshift__\"];\n\t    case \"BitAnd\":\n\t        return obj.nb$reflected_and ? obj.nb$reflected_and : obj[\"__rand__\"];\n\t    case \"BitXor\":\n\t        return obj.nb$reflected_xor ? obj.nb$reflected_xor : obj[\"__rxor__\"];\n\t    case \"BitOr\":\n\t        return obj.nb$reflected_or ? obj.nb$reflected_or : obj[\"__ror__\"];\n\t    }\n\t};\n\n\tSk.abstr.iboNameToSlotFunc_ = function (obj, name) {\n\t    switch (name) {\n\t    case \"Add\":\n\t        return obj.nb$inplace_add ? obj.nb$inplace_add : obj[\"__iadd__\"];\n\t    case \"Sub\":\n\t        return obj.nb$inplace_subtract ? obj.nb$inplace_subtract : obj[\"__isub__\"];\n\t    case \"Mult\":\n\t        return obj.nb$inplace_multiply ? obj.nb$inplace_multiply : obj[\"__imul__\"];\n\t    case \"Div\":\n\t        return obj.nb$inplace_divide ? obj.nb$inplace_divide : obj[\"__idiv__\"];\n\t    case \"FloorDiv\":\n\t        return obj.nb$inplace_floor_divide ? obj.nb$inplace_floor_divide : obj[\"__ifloordiv__\"];\n\t    case \"Mod\":\n\t        return obj.nb$inplace_remainder;\n\t    case \"Pow\":\n\t        return obj.nb$inplace_power;\n\t    case \"LShift\":\n\t        return obj.nb$inplace_lshift ? obj.nb$inplace_lshift : obj[\"__ilshift__\"];\n\t    case \"RShift\":\n\t        return obj.nb$inplace_rshift ? obj.nb$inplace_rshift : obj[\"__irshift__\"];\n\t    case \"BitAnd\":\n\t        return obj.nb$inplace_and;\n\t    case \"BitOr\":\n\t        return obj.nb$inplace_or;\n\t    case \"BitXor\":\n\t        return obj.nb$inplace_xor ? obj.nb$inplace_xor : obj[\"__ixor__\"];\n\t    }\n\t};\n\tSk.abstr.uoNameToSlotFunc_ = function (obj, name) {\n\t    if (obj === null) {\n\t        return undefined;\n\t    }\n\t    switch (name) {\n\t    case \"USub\":\n\t        return obj.nb$negative ? obj.nb$negative : obj[\"__neg__\"];\n\t    case \"UAdd\":\n\t        return obj.nb$positive ? obj.nb$positive : obj[\"__pos__\"];\n\t    case \"Invert\":\n\t        return obj.nb$invert ? obj.nb$invert : obj[\"__invert__\"];\n\t    }\n\t};\n\n\tSk.abstr.binary_op_ = function (v, w, opname) {\n\t    var wop;\n\t    var ret;\n\t    var vop;\n\n\t    // All Python inheritance is now enforced with Javascript inheritance\n\t    // (see Sk.abstr.setUpInheritance). This checks if w's type is a strict\n\t    // subclass of v's type\n\t    var w_is_subclass = w.constructor.prototype instanceof v.constructor;\n\n\t    // From the Python 2.7 docs:\n\t    //\n\t    // \"If the right operands type is a subclass of the left operands type and\n\t    // that subclass provides the reflected method for the operation, this\n\t    // method will be called before the left operands non-reflected method.\n\t    // This behavior allows subclasses to override their ancestors operations.\"\n\t    //\n\t    // -- https://docs.python.org/2/reference/datamodel.html#index-92\n\n\t    if (w_is_subclass) {\n\t        wop = Sk.abstr.boNameToSlotFuncRhs_(w, opname);\n\t        if (wop !== undefined) {\n\t            if (wop.call) {\n\t                ret = wop.call(w, v);\n\t            } else {\n\t                ret = Sk.misceval.callsim(wop, w, v);\n\t            }\n\t            if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n\t                return ret;\n\t            }\n\t        }\n\t    }\n\n\t    vop = Sk.abstr.boNameToSlotFuncLhs_(v, opname);\n\t    if (vop !== undefined) {\n\t        if (vop.call) {\n\t            ret = vop.call(v, w);\n\t        } else {\n\t            ret = Sk.misceval.callsim(vop, v, w);\n\t        }\n\t        if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n\t            return ret;\n\t        }\n\t    }\n\t    // Don't retry RHS if failed above\n\t    if (!w_is_subclass) {\n\t        wop = Sk.abstr.boNameToSlotFuncRhs_(w, opname);\n\t        if (wop !== undefined) {\n\t            if (wop.call) {\n\t                ret = wop.call(w, v);\n\t            } else {\n\t                ret = Sk.misceval.callsim(wop, w, v);\n\t            }\n\t            if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n\t                return ret;\n\t            }\n\t        }\n\t    }\n\t    Sk.abstr.binop_type_error(v, w, opname);\n\t};\n\n\tSk.abstr.binary_iop_ = function (v, w, opname) {\n\t    var wop;\n\t    var ret;\n\t    var vop = Sk.abstr.iboNameToSlotFunc_(v, opname);\n\t    if (vop !== undefined) {\n\t        if (vop.call) {\n\t            ret = vop.call(v, w);\n\t        } else {  // assume that vop is an __xxx__ type method\n\t            ret = Sk.misceval.callsim(vop, v, w); //  added to be like not-in-place... is this okay?\n\t        }\n\t        if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n\t            return ret;\n\t        }\n\t    }\n\t    wop = Sk.abstr.iboNameToSlotFunc_(w, opname);\n\t    if (wop !== undefined) {\n\t        if (wop.call) {\n\t            ret = wop.call(w, v);\n\t        } else { // assume that wop is an __xxx__ type method\n\t            ret = Sk.misceval.callsim(wop, w, v); //  added to be like not-in-place... is this okay?\n\t        }\n\t        if (ret !== undefined && ret !== Sk.builtin.NotImplemented.NotImplemented$) {\n\t            return ret;\n\t        }\n\t    }\n\t    Sk.abstr.binop_type_error(v, w, opname);\n\t};\n\tSk.abstr.unary_op_ = function (v, opname) {\n\t    var ret;\n\t    var vop = Sk.abstr.uoNameToSlotFunc_(v, opname);\n\t    if (vop !== undefined) {\n\t        if (vop.call) {\n\t            ret = vop.call(v);\n\t        } else {  // assume that vop is an __xxx__ type method\n\t            ret = Sk.misceval.callsim(vop, v); //  added to be like not-in-place... is this okay?\n\t        }\n\t        if (ret !== undefined) {\n\t            return ret;\n\t        }\n\t    }\n\t    Sk.abstr.unop_type_error(v, opname);\n\t};\n\n\t//\n\t// handle upconverting a/b from number to long if op causes too big/small a\n\t// result, or if either of the ops are already longs\n\tSk.abstr.numOpAndPromote = function (a, b, opfn) {\n\t    var tmp;\n\t    var ans;\n\t    if (a === null || b === null) {\n\t        return undefined;\n\t    }\n\n\t    if (typeof a === \"number\" && typeof b === \"number\") {\n\t        ans = opfn(a, b);\n\t        // todo; handle float   Removed RNL (bugs in lng, and it should be a question of precision, not magnitude -- this was just wrong)\n\t        if ((ans > Sk.builtin.int_.threshold$ || ans < -Sk.builtin.int_.threshold$) && Math.floor(ans) === ans) {\n\t            return [Sk.builtin.lng.fromInt$(a), Sk.builtin.lng.fromInt$(b)];\n\t        } else {\n\t            return ans;\n\t        }\n\t    } else if (a === undefined || b === undefined) {\n\t        throw new Sk.builtin.NameError(\"Undefined variable in expression\");\n\t    }\n\n\t    if (a.constructor === Sk.builtin.lng) {\n\t        return [a, b];\n\t    } else if ((a.constructor === Sk.builtin.int_ ||\n\t                a.constructor === Sk.builtin.float_) &&\n\t                b.constructor === Sk.builtin.complex) {\n\t        // special case of upconverting nmber and complex\n\t        // can we use here the Sk.builtin.checkComplex() method?\n\t        tmp = new Sk.builtin.complex(a);\n\t        return [tmp, b];\n\t    } else if (a.constructor === Sk.builtin.int_ ||\n\t               a.constructor === Sk.builtin.float_) {\n\t        return [a, b];\n\t    } else if (typeof a === \"number\") {\n\t        tmp = Sk.builtin.assk$(a);\n\t        return [tmp, b];\n\t    } else {\n\t        return undefined;\n\t    }\n\t};\n\n\tSk.abstr.boNumPromote_ = {\n\t    \"Add\"     : function (a, b) {\n\t        return a + b;\n\t    },\n\t    \"Sub\"     : function (a, b) {\n\t        return a - b;\n\t    },\n\t    \"Mult\"    : function (a, b) {\n\t        return a * b;\n\t    },\n\t    \"Mod\"     : function (a, b) {\n\t        var m;\n\t        if (b === 0) {\n\t            throw new Sk.builtin.ZeroDivisionError(\"division or modulo by zero\");\n\t        }\n\t        m = a % b;\n\t        return ((m * b) < 0 ? (m + b) : m);\n\t    },\n\t    \"Div\"     : function (a, b) {\n\t        if (b === 0) {\n\t            throw new Sk.builtin.ZeroDivisionError(\"division or modulo by zero\");\n\t        } else {\n\t            return a / b;\n\t        }\n\t    },\n\t    \"FloorDiv\": function (a, b) {\n\t        if (b === 0) {\n\t            throw new Sk.builtin.ZeroDivisionError(\"division or modulo by zero\");\n\t        } else {\n\t            return Math.floor(a / b);\n\t        } // todo; wrong? neg?\n\t    },\n\t    \"Pow\"     : Math.pow,\n\t    \"BitAnd\"  : function (a, b) {\n\t        var m = a & b;\n\t        if (m < 0) {\n\t            m = m + 4294967296; // convert back to unsigned\n\t        }\n\t        return m;\n\t    },\n\t    \"BitOr\"   : function (a, b) {\n\t        var m = a | b;\n\t        if (m < 0) {\n\t            m = m + 4294967296; // convert back to unsigned\n\t        }\n\t        return m;\n\t    },\n\t    \"BitXor\"  : function (a, b) {\n\t        var m = a ^ b;\n\t        if (m < 0) {\n\t            m = m + 4294967296; // convert back to unsigned\n\t        }\n\t        return m;\n\t    },\n\t    \"LShift\"  : function (a, b) {\n\t        var m;\n\t        if (b < 0) {\n\t            throw new Sk.builtin.ValueError(\"negative shift count\");\n\t        }\n\t        m = a << b;\n\t        if (m > a) {\n\t            return m;\n\t        } else {\n\t            // Fail, this will get recomputed with longs\n\t            return a * Math.pow(2, b);\n\t        }\n\t    },\n\t    \"RShift\"  : function (a, b) {\n\t        var m;\n\t        if (b < 0) {\n\t            throw new Sk.builtin.ValueError(\"negative shift count\");\n\t        }\n\t        m = a >> b;\n\t        if ((a > 0) && (m < 0)) {\n\t            // fix incorrect sign extension\n\t            m = m & (Math.pow(2, 32 - b) - 1);\n\t        }\n\t        return m;\n\t    }\n\t};\n\n\tSk.abstr.numberBinOp = function (v, w, op) {\n\t    var tmp;\n\t    var numPromoteFunc = Sk.abstr.boNumPromote_[op];\n\t    if (numPromoteFunc !== undefined) {\n\t        tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);\n\t        if (typeof tmp === \"number\") {\n\t            return tmp;\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.int_) {\n\t            return tmp;\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.float_) {\n\t            return tmp;\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {\n\t            return tmp;\n\t        } else if (tmp !== undefined) {\n\t            v = tmp[0];\n\t            w = tmp[1];\n\t        }\n\t    }\n\n\t    return Sk.abstr.binary_op_(v, w, op);\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.numberBinOp\", Sk.abstr.numberBinOp);\n\n\tSk.abstr.numberInplaceBinOp = function (v, w, op) {\n\t    var tmp;\n\t    var numPromoteFunc = Sk.abstr.boNumPromote_[op];\n\t    if (numPromoteFunc !== undefined) {\n\t        tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);\n\t        if (typeof tmp === \"number\") {\n\t            return tmp;\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.int_) {\n\t            return tmp;\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.float_) {\n\t            return tmp;\n\t        } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {\n\t            return tmp;\n\t        } else if (tmp !== undefined) {\n\t            v = tmp[0];\n\t            w = tmp[1];\n\t        }\n\t    }\n\n\t    return Sk.abstr.binary_iop_(v, w, op);\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.numberInplaceBinOp\", Sk.abstr.numberInplaceBinOp);\n\n\tSk.abstr.numberUnaryOp = function (v, op) {\n\t    var value;\n\t    if (op === \"Not\") {\n\t        return Sk.misceval.isTrue(v) ? Sk.builtin.bool.false$ : Sk.builtin.bool.true$;\n\t    } else if (v instanceof Sk.builtin.bool) {\n\t        value = Sk.builtin.asnum$(v);\n\t        if (op === \"USub\") {\n\t            return new Sk.builtin.int_(-value);\n\t        }\n\t        if (op === \"UAdd\") {\n\t            return new Sk.builtin.int_(value);\n\t        }\n\t        if (op === \"Invert\") {\n\t            return new Sk.builtin.int_(~value);\n\t        }\n\t    } else {\n\t        if (op === \"USub\" && v.nb$negative) {\n\t            return v.nb$negative();\n\t        }\n\t        if (op === \"UAdd\" && v.nb$positive) {\n\t            return v.nb$positive();\n\t        }\n\t        if (op === \"Invert\" && v.nb$invert) {\n\t            return v.nb$invert();\n\t        }\n\t    }\n\n\t    return Sk.abstr.unary_op_(v, op);\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.numberUnaryOp\", Sk.abstr.numberUnaryOp);\n\n\t//\n\t// Sequence\n\t//\n\n\tSk.abstr.fixSeqIndex_ = function (seq, i) {\n\t    i = Sk.builtin.asnum$(i);\n\t    if (i < 0 && seq.sq$length) {\n\t        i += seq.sq$length();\n\t    }\n\t    return i;\n\t};\n\n\t/**\n\t * @param {*} seq\n\t * @param {*} ob\n\t * @param {boolean=} canSuspend\n\t */\n\tSk.abstr.sequenceContains = function (seq, ob, canSuspend) {\n\t    var seqtypename;\n\t    var special;\n\t    var r;\n\n\t    if (seq.sq$contains) {\n\t        return seq.sq$contains(ob);\n\t    }\n\n\t    /**\n\t     *  Look for special method and call it, we have to distinguish between built-ins and\n\t     *  python objects\n\t     */\n\t    special = Sk.abstr.lookupSpecial(seq, \"__contains__\");\n\t    if (special != null) {\n\t        // method on builtin, provide this arg\n\t        return Sk.misceval.isTrue(Sk.misceval.callsim(special, seq, ob));\n\t    }\n\n\t    if (!Sk.builtin.checkIterable(seq)) {\n\t        seqtypename = Sk.abstr.typeName(seq);\n\t        throw new Sk.builtin.TypeError(\"argument of type '\" + seqtypename + \"' is not iterable\");\n\t    }\n\n\t    r = Sk.misceval.iterFor(Sk.abstr.iter(seq), function(i) {\n\t        if (Sk.misceval.richCompareBool(i, ob, \"Eq\")) {\n\t            return new Sk.misceval.Break(true);\n\t        } else {\n\t            return false;\n\t        }\n\t    }, false);\n\n\t    return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n\t};\n\n\tSk.abstr.sequenceConcat = function (seq1, seq2) {\n\t    var seq1typename;\n\t    if (seq1.sq$concat) {\n\t        return seq1.sq$concat(seq2);\n\t    }\n\t    seq1typename = Sk.abstr.typeName(seq1);\n\t    throw new Sk.builtin.TypeError(\"'\" + seq1typename + \"' object can't be concatenated\");\n\t};\n\n\tSk.abstr.sequenceGetIndexOf = function (seq, ob) {\n\t    var seqtypename;\n\t    var i, it;\n\t    var index;\n\t    if (seq.index) {\n\t        return Sk.misceval.callsim(seq.index, seq, ob);\n\t    }\n\t    if (Sk.builtin.checkIterable(seq)) {\n\t        index = 0;\n\t        for (it = Sk.abstr.iter(seq), i = it.tp$iternext();\n\t             i !== undefined; i = it.tp$iternext()) {\n\t            if (Sk.misceval.richCompareBool(ob, i, \"Eq\")) {\n\t                return new Sk.builtin.int_(index);\n\t            }\n\t            index += 1;\n\t        }\n\t        throw new Sk.builtin.ValueError(\"sequence.index(x): x not in sequence\");\n\t    }\n\n\t    seqtypename = Sk.abstr.typeName(seq);\n\t    throw new Sk.builtin.TypeError(\"argument of type '\" + seqtypename + \"' is not iterable\");\n\t};\n\n\tSk.abstr.sequenceGetCountOf = function (seq, ob) {\n\t    var seqtypename;\n\t    var i, it;\n\t    var count;\n\t    if (seq.count) {\n\t        return Sk.misceval.callsim(seq.count, seq, ob);\n\t    }\n\t    if (Sk.builtin.checkIterable(seq)) {\n\t        count = 0;\n\t        for (it = Sk.abstr.iter(seq), i = it.tp$iternext();\n\t             i !== undefined; i = it.tp$iternext()) {\n\t            if (Sk.misceval.richCompareBool(ob, i, \"Eq\")) {\n\t                count += 1;\n\t            }\n\t        }\n\t        return new Sk.builtin.int_(count);\n\t    }\n\n\t    seqtypename = Sk.abstr.typeName(seq);\n\t    throw new Sk.builtin.TypeError(\"argument of type '\" + seqtypename + \"' is not iterable\");\n\t};\n\n\tSk.abstr.sequenceGetItem = function (seq, i, canSuspend) {\n\t    var seqtypename;\n\t    if (seq.mp$subscript) {\n\t        return seq.mp$subscript(i);\n\t    }\n\n\t    seqtypename = Sk.abstr.typeName(seq);\n\t    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object is unsubscriptable\");\n\t};\n\n\tSk.abstr.sequenceSetItem = function (seq, i, x, canSuspend) {\n\t    var seqtypename;\n\t    if (seq.mp$ass_subscript) {\n\t        return seq.mp$ass_subscript(i, x);\n\t    }\n\n\t    seqtypename = Sk.abstr.typeName(seq);\n\t    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object does not support item assignment\");\n\t};\n\n\tSk.abstr.sequenceDelItem = function (seq, i) {\n\t    var seqtypename;\n\t    if (seq.sq$del_item) {\n\t        i = Sk.abstr.fixSeqIndex_(seq, i);\n\t        seq.sq$del_item(i);\n\t        return;\n\t    }\n\n\t    seqtypename = Sk.abstr.typeName(seq);\n\t    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object does not support item deletion\");\n\t};\n\n\tSk.abstr.sequenceRepeat = function (f, seq, n) {\n\t    var ntypename;\n\t    var count;\n\t    n = Sk.builtin.asnum$(n);\n\t    count = Sk.misceval.asIndex(n);\n\t    if (count === undefined) {\n\t        ntypename = Sk.abstr.typeName(n);\n\t        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + ntypename + \"'\");\n\t    }\n\t    return f.call(seq, n);\n\t};\n\n\tSk.abstr.sequenceGetSlice = function (seq, i1, i2) {\n\t    var seqtypename;\n\t    if (seq.sq$slice) {\n\t        i1 = Sk.abstr.fixSeqIndex_(seq, i1);\n\t        i2 = Sk.abstr.fixSeqIndex_(seq, i2);\n\t        return seq.sq$slice(i1, i2);\n\t    } else if (seq.mp$subscript) {\n\t        return seq.mp$subscript(new Sk.builtin.slice(i1, i2));\n\t    }\n\n\t    seqtypename = Sk.abstr.typeName(seq);\n\t    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object is unsliceable\");\n\t};\n\n\tSk.abstr.sequenceDelSlice = function (seq, i1, i2) {\n\t    var seqtypename;\n\t    if (seq.sq$del_slice) {\n\t        i1 = Sk.abstr.fixSeqIndex_(seq, i1);\n\t        i2 = Sk.abstr.fixSeqIndex_(seq, i2);\n\t        seq.sq$del_slice(i1, i2);\n\t        return;\n\t    }\n\n\t    seqtypename = Sk.abstr.typeName(seq);\n\t    throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' doesn't support slice deletion\");\n\t};\n\n\tSk.abstr.sequenceSetSlice = function (seq, i1, i2, x) {\n\t    var seqtypename;\n\t    if (seq.sq$ass_slice) {\n\t        i1 = Sk.abstr.fixSeqIndex_(seq, i1);\n\t        i2 = Sk.abstr.fixSeqIndex_(seq, i2);\n\t        seq.sq$ass_slice(i1, i2, x);\n\t    } else if (seq.mp$ass_subscript) {\n\t        seq.mp$ass_subscript(new Sk.builtin.slice(i1, i2), x);\n\t    } else {\n\t        seqtypename = Sk.abstr.typeName(seq);\n\t        throw new Sk.builtin.TypeError(\"'\" + seqtypename + \"' object doesn't support slice assignment\");\n\t    }\n\t};\n\n\t// seq - Python object to unpack\n\t// n   - JavaScript number of items to unpack\n\tSk.abstr.sequenceUnpack = function (seq, n) {\n\t    var res = [];\n\t    var it, i;\n\n\t    if (!Sk.builtin.checkIterable(seq)) {\n\t        throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(seq) + \"' object is not iterable\");\n\t    }\n\n\t    for (it = Sk.abstr.iter(seq), i = it.tp$iternext();\n\t         (i !== undefined) && (res.length < n);\n\t         i = it.tp$iternext()) {\n\t        res.push(i);\n\t    }\n\n\t    if (res.length < n) {\n\t        throw new Sk.builtin.ValueError(\"need more than \" + res.length + \" values to unpack\");\n\t    }\n\t    if (i !== undefined) {\n\t        throw new Sk.builtin.ValueError(\"too many values to unpack\");\n\t    }\n\n\t    // Return Javascript array of items\n\t    return res;\n\t};\n\n\t//\n\t// Object\n\t//\n\n\tSk.abstr.objectFormat = function (obj, format_spec) {\n\t    var meth; // PyObject\n\t    var result; // PyObject\n\n\t    // If no format_spec is provided, use an empty string\n\t    if(format_spec == null) {\n\t        format_spec = \"\";\n\t    }\n\n\t    // Find the (unbound!) __format__ method (a borrowed reference)\n\t    meth = Sk.abstr.lookupSpecial(obj, \"__format__\");\n\t    if (meth == null) {\n\t        throw new Sk.builtin.TypeError(\"Type \" + Sk.abstr.typeName(obj) + \"doesn't define __format__\");\n\t    }\n\n\t    // And call it\n\t    result = Sk.misceval.callsim(meth, obj, format_spec);\n\t    if (!Sk.builtin.checkString(result)) {\n\t        throw new Sk.builtin.TypeError(\"__format__ must return a str, not \" + Sk.abstr.typeName(result));\n\t    }\n\n\t    return result;\n\t};\n\n\tSk.abstr.objectAdd = function (a, b) {\n\t    var btypename;\n\t    var atypename;\n\t    if (a.nb$add) {\n\t        return a.nb$add(b);\n\t    }\n\n\t    atypename = Sk.abstr.typeName(a);\n\t    btypename = Sk.abstr.typeName(b);\n\t    throw new Sk.builtin.TypeError(\"unsupported operand type(s) for +: '\" + atypename + \"' and '\" + btypename + \"'\");\n\t};\n\n\t// in Python 2.6, this behaviour seems to be defined for numbers and bools (converts bool to int)\n\tSk.abstr.objectNegative = function (obj) {\n\t    var objtypename;\n\t    var obj_asnum = Sk.builtin.asnum$(obj); // this will also convert bool type to int\n\n\t    if (obj instanceof Sk.builtin.bool) {\n\t        obj = new Sk.builtin.int_(obj_asnum);\n\t    }\n\n\t    if (obj.nb$negative) {\n\t        return obj.nb$negative();\n\t    }\n\n\t    objtypename = Sk.abstr.typeName(obj);\n\t    throw new Sk.builtin.TypeError(\"bad operand type for unary -: '\" + objtypename + \"'\");\n\t};\n\n\t// in Python 2.6, this behaviour seems to be defined for numbers and bools (converts bool to int)\n\tSk.abstr.objectPositive = function (obj) {\n\t    var objtypename = Sk.abstr.typeName(obj);\n\t    var obj_asnum = Sk.builtin.asnum$(obj); // this will also convert bool type to int\n\n\t    if (obj instanceof Sk.builtin.bool) {\n\t        obj = new Sk.builtin.int_(obj_asnum);\n\t    }\n\n\t    if (obj.nb$negative) {\n\t        return obj.nb$positive();\n\t    }\n\n\t    throw new Sk.builtin.TypeError(\"bad operand type for unary +: '\" + objtypename + \"'\");\n\t};\n\n\tSk.abstr.objectDelItem = function (o, key) {\n\t    var otypename;\n\t    var keytypename;\n\t    var keyValue;\n\t    if (o !== null) {\n\t        if (o.mp$del_subscript) {\n\t            o.mp$del_subscript(key);\n\t            return;\n\t        }\n\t        if (o.sq$ass_item) {\n\t            keyValue = Sk.misceval.asIndex(key);\n\t            if (keyValue === undefined) {\n\t                keytypename = Sk.abstr.typeName(key);\n\t                throw new Sk.builtin.TypeError(\"sequence index must be integer, not '\" + keytypename + \"'\");\n\t            }\n\t            Sk.abstr.sequenceDelItem(o, keyValue);\n\t            return;\n\t        }\n\t        // if o is a slice do something else...\n\t    }\n\n\t    otypename = Sk.abstr.typeName(o);\n\t    throw new Sk.builtin.TypeError(\"'\" + otypename + \"' object does not support item deletion\");\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.objectDelItem\", Sk.abstr.objectDelItem);\n\n\tSk.abstr.objectGetItem = function (o, key, canSuspend) {\n\t    var otypename;\n\t    if (o !== null) {\n\t        if (o.tp$getitem) {\n\t            return o.tp$getitem(key, canSuspend);\n\t        } else if (o.mp$subscript) {\n\t            return o.mp$subscript(key, canSuspend);\n\t        } else if (Sk.misceval.isIndex(key) && o.sq$item) {\n\t            return Sk.abstr.sequenceGetItem(o, Sk.misceval.asIndex(key), canSuspend);\n\t        }\n\t    }\n\n\t    otypename = Sk.abstr.typeName(o);\n\t    throw new Sk.builtin.TypeError(\"'\" + otypename + \"' does not support indexing\");\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.objectGetItem\", Sk.abstr.objectGetItem);\n\n\tSk.abstr.objectSetItem = function (o, key, v, canSuspend) {\n\t    var otypename;\n\t    if (o !== null) {\n\t        if (o.tp$setitem) {\n\t            return o.tp$setitem(key, v, canSuspend);\n\t        } else if (o.mp$ass_subscript) {\n\t            return o.mp$ass_subscript(key, v, canSuspend);\n\t        } else if (Sk.misceval.isIndex(key) && o.sq$ass_item) {\n\t            return Sk.abstr.sequenceSetItem(o, Sk.misceval.asIndex(key), v, canSuspend);\n\t        }\n\t    }\n\n\t    otypename = Sk.abstr.typeName(o);\n\t    throw new Sk.builtin.TypeError(\"'\" + otypename + \"' does not support item assignment\");\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.objectSetItem\", Sk.abstr.objectSetItem);\n\n\n\tSk.abstr.gattr = function (obj, nameJS, canSuspend) {\n\t    var ret, f;\n\t    var objname = Sk.abstr.typeName(obj);\n\n\t    if (obj === null) {\n\t        throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + nameJS + \"'\");\n\t    }\n\n\n\t    if (obj.tp$getattr !== undefined) {\n\t        f = obj.tp$getattr(\"__getattribute__\");\n\t    }\n\n\t    if (f !== undefined) {\n\t        ret = Sk.misceval.callsimOrSuspend(f, new Sk.builtin.str(nameJS));\n\t    }\n\n\t    ret = Sk.misceval.chain(ret, function(ret) {\n\t        var f;\n\n\t        if (ret === undefined && obj.tp$getattr !== undefined) {\n\t            ret = obj.tp$getattr(nameJS);\n\n\t            if (ret === undefined) {\n\t                f = obj.tp$getattr(\"__getattr__\");\n\n\t                if (f !== undefined) {\n\t                    ret = Sk.misceval.callsimOrSuspend(f, new Sk.builtin.str(nameJS));\n\t                }\n\t            }\n\t        }\n\t        return ret;\n\t    }, function(r) {\n\t        if (r === undefined) {\n\t            throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + nameJS + \"'\");\n\t        }\n\t        return r;\n\t    });\n\n\t    return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.gattr\", Sk.abstr.gattr);\n\n\tSk.abstr.sattr = function (obj, nameJS, data, canSuspend) {\n\t    var objname = Sk.abstr.typeName(obj), r, setf;\n\n\t    if (obj === null) {\n\t        throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + nameJS + \"'\");\n\t    }\n\n\t    if (obj.tp$getattr !== undefined) {\n\t        setf = obj.tp$getattr(\"__setattr__\");\n\t        if (setf !== undefined) {\n\t            r = Sk.misceval.callsimOrSuspend(setf, new Sk.builtin.str(nameJS), data);\n\t            return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);\n\t        }\n\t    }\n\n\t    if (obj.tp$setattr !== undefined) {\n\t        obj.tp$setattr(nameJS, data);\n\t    } else {\n\t        throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + nameJS + \"'\");\n\t    }\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.sattr\", Sk.abstr.sattr);\n\n\n\tSk.abstr.iternext = function (it, canSuspend) {\n\t    return it.tp$iternext(canSuspend);\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.iternext\", Sk.abstr.iternext);\n\n\n\t/**\n\t * Get the iterator for a Python object  This iterator could be one of the following.\n\t * This is the preferred mechanism for consistently getting the correct iterator.  You should\n\t * not just use tp$iter because that could lead to incorrect behavior of a user created class.\n\t *\n\t * - tp$iter\n\t * - A user defined `__iter__` method\n\t * - A user defined `__getitem__` method\n\t *\n\t * @param obj\n\t *\n\t * @throws {Sk.builtin.TypeError}\n\t * @returns {Object}\n\t */\n\n\tSk.abstr.iter = function(obj) {\n\t    var iter;\n\t    var getit;\n\t    var ret;\n\n\t    /**\n\t     * Builds an iterator around classes that have a __getitem__ method.\n\t     *\n\t     * @constructor\n\t     */\n\t    var seqIter = function (obj) {\n\t        this.idx = 0;\n\t        this.myobj = obj;\n\t        this.getitem = Sk.abstr.lookupSpecial(obj, \"__getitem__\");\n\t        this.tp$iternext = function () {\n\t            var ret;\n\t            try {\n\t                ret = Sk.misceval.callsim(this.getitem, this.myobj, Sk.ffi.remapToPy(this.idx));\n\t            } catch (e) {\n\t                if (e instanceof Sk.builtin.IndexError || e instanceof Sk.builtin.StopIteration) {\n\t                    return undefined;\n\t                } else {\n\t                    throw e;\n\t                }\n\t            }\n\t            this.idx++;\n\t            return ret;\n\t        };\n\t    };\n\n\t    if (obj.tp$getattr) {\n\t        iter =  Sk.abstr.lookupSpecial(obj,\"__iter__\");\n\t        if (iter) {\n\t            ret = Sk.misceval.callsim(iter, obj);\n\t            if (ret.tp$iternext) {\n\t                return ret;\n\t            }\n\t        }\n\t    }\n\t    if (obj.tp$iter) {\n\t        try {  // catch and ignore not iterable error here.\n\t            ret = obj.tp$iter();\n\t            if (ret.tp$iternext) {\n\t                return ret;\n\t            }\n\t        } catch (e) { }\n\t    }\n\t    getit = Sk.abstr.lookupSpecial(obj, \"__getitem__\");\n\t    if (getit) {\n\t        // create internal iterobject if __getitem__\n\t        return new seqIter(obj);\n\t    }\n\t    throw new Sk.builtin.TypeError(\"'\" + Sk.abstr.typeName(obj) + \"' object is not iterable\");\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.iter\", Sk.abstr.iter);\n\n\t/**\n\t * Special method look up. First try getting the method via\n\t * internal dict and getattr. If getattr is not present (builtins)\n\t * try if method is defined on the object itself\n\t *\n\t * @returns {null|Object} Return null if not found or the function\n\t */\n\tSk.abstr.lookupSpecial = function(op, str) {\n\t    var res;\n\t    var obtp;\n\t    if (op.ob$type) {\n\t        obtp = op.ob$type;\n\t    } else {\n\t        return null;\n\t    }\n\n\t    return Sk.builtin.type.typeLookup(obtp, str);\n\t};\n\tgoog.exportSymbol(\"Sk.abstr.lookupSpecial\", Sk.abstr.lookupSpecial);\n\n\t/**\n\t * Mark a class as unhashable and prevent its `__hash__` function from being called.\n\t * @param  {function(...[?])} thisClass The class to mark as unhashable.\n\t * @return {undefined}\n\t */\n\tSk.abstr.markUnhashable = function (thisClass) {\n\t    var proto = thisClass.prototype;\n\t    proto.__hash__ = Sk.builtin.none.none$;\n\t    proto.tp$hash = Sk.builtin.none.none$;\n\t};\n\n\t/**\n\t * Set up inheritance between two Python classes. This allows only for single\n\t * inheritance -- multiple inheritance is not supported by Javascript.\n\t *\n\t * Javascript's inheritance is prototypal. This means that properties must\n\t * be defined on the superclass' prototype in order for subclasses to inherit\n\t * them.\n\t *\n\t * ```\n\t * Sk.superclass.myProperty                 # will NOT be inherited\n\t * Sk.superclass.prototype.myProperty       # will be inherited\n\t * ```\n\t *\n\t * In order for a class to be subclassable, it must (directly or indirectly)\n\t * inherit from Sk.builtin.object so that it will be properly initialized in\n\t * {@link Sk.doOneTimeInitialization} (in src/import.js). Further, all Python\n\t * builtins should inherit from Sk.builtin.object.\n\t *\n\t * @param {string} childName The Python name of the child (subclass).\n\t * @param {function(...[?])} child     The subclass.\n\t * @param {function(...[?])} parent    The superclass.\n\t * @return {undefined}\n\t */\n\tSk.abstr.setUpInheritance = function (childName, child, parent) {\n\t    goog.inherits(child, parent);\n\t    child.prototype.tp$base = parent;\n\t    child.prototype.tp$name = childName;\n\t    child.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(childName, child);\n\t};\n\n\t/**\n\t * Call the super constructor of the provided class, with the object `self` as\n\t * the `this` value of that constructor. Any arguments passed to this function\n\t * after `self` will be passed as-is to the constructor.\n\t *\n\t * @param  {function(...[?])} thisClass The subclass.\n\t * @param  {Object} self      The instance of the subclas.\n\t * @param  {...?} args Arguments to pass to the constructor.\n\t * @return {undefined}\n\t */\n\tSk.abstr.superConstructor = function (thisClass, self, args) {\n\t    var argumentsForConstructor = Array.prototype.slice.call(arguments, 2);\n\t    thisClass.prototype.tp$base.apply(self, argumentsForConstructor);\n\t};\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/object.js ---- */ \n\n\t/**\n\t * @constructor\n\t * Sk.builtin.object\n\t *\n\t * @description\n\t * Constructor for Python object. All Python classes (builtin and user-defined)\n\t * should inherit from this class.\n\t *\n\t * @return {Sk.builtin.object} Python object\n\t */\n\tSk.builtin.object = function () {\n\t    if (!(this instanceof Sk.builtin.object)) {\n\t        return new Sk.builtin.object();\n\t    }\n\n\t    return this;\n\t};\n\n\n\n\tvar _tryGetSubscript = function(dict, pyName) {\n\t    try {\n\t        return dict.mp$subscript(pyName);\n\t    } catch (x) {\n\t        return undefined;\n\t    }\n\t};\n\n\t/**\n\t * @return {undefined}\n\t */\n\tSk.builtin.object.prototype.GenericGetAttr = function (name) {\n\t    var res;\n\t    var f;\n\t    var descr;\n\t    var tp;\n\t    var dict;\n\t    var pyName = new Sk.builtin.str(name);\n\t    goog.asserts.assert(typeof name === \"string\");\n\n\t    tp = this.ob$type;\n\t    goog.asserts.assert(tp !== undefined, \"object has no ob$type!\");\n\n\t    dict = this[\"$d\"] || this.constructor[\"$d\"];\n\n\t    // todo; assert? force?\n\t    if (dict) {\n\t        if (dict.mp$lookup) {\n\t            res = dict.mp$lookup(pyName);\n\t        } else if (dict.mp$subscript) {\n\t            res = _tryGetSubscript(dict, pyName);\n\t        } else if (typeof dict === \"object\") {\n\t            // todo; definitely the wrong place for this. other custom tp$getattr won't work on object -- bnm -- implemented custom __getattr__ in abstract.js\n\t            res = dict[name];\n\t        }\n\t        if (res !== undefined) {\n\t            return res;\n\t        }\n\t    }\n\n\t    descr = Sk.builtin.type.typeLookup(tp, name);\n\n\t    // otherwise, look in the type for a descr\n\t    if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {\n\t        f = descr.ob$type.tp$descr_get;\n\t        if (!(f) && descr[\"__get__\"]) {\n\t            f = descr[\"__get__\"];\n\t            return Sk.misceval.callsimOrSuspend(f, descr, this, Sk.builtin.none.none$);\n\t        }\n\t        // todo;\n\t        // if (f && descr.tp$descr_set) // is a data descriptor if it has a set\n\t        // return f.call(descr, this, this.ob$type);\n\n\t        if (f) {\n\t            // non-data descriptor\n\t            return f.call(descr, this, this.ob$type);\n\t        }\n\t    }\n\n\t    if (descr !== undefined) {\n\t        return descr;\n\t    }\n\n\t    return undefined;\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.object.prototype.GenericGetAttr\", Sk.builtin.object.prototype.GenericGetAttr);\n\n\tSk.builtin.object.prototype.GenericPythonGetAttr = function(self, name) {\n\t    return Sk.builtin.object.prototype.GenericGetAttr.call(self, name.v);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.object.prototype.GenericPythonGetAttr\", Sk.builtin.object.prototype.GenericPythonGetAttr);\n\n\tSk.builtin.object.prototype.GenericSetAttr = function (name, value) {\n\t    var objname = Sk.abstr.typeName(this);\n\t    var pyname;\n\t    var dict;\n\t    var tp = this.ob$type;\n\t    var descr;\n\t    var f;\n\n\t    goog.asserts.assert(typeof name === \"string\");\n\t    goog.asserts.assert(tp !== undefined, \"object has no ob$type!\");\n\n\t    dict = this[\"$d\"] || this.constructor[\"$d\"];\n\n\t    descr = Sk.builtin.type.typeLookup(tp, name);\n\n\t    // otherwise, look in the type for a descr\n\t    if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {\n\t        //f = descr.ob$type.tp$descr_set;\n\t        if (descr[\"__set__\"]) {\n\t            f = descr[\"__set__\"];\n\t            Sk.misceval.callsimOrSuspend(f, descr, this, value);\n\t            return;\n\t        }\n\t        // todo;\n\t        //if (f && descr.tp$descr_set) // is a data descriptor if it has a set\n\t        //return f.call(descr, this, this.ob$type);\n\t    }\n\n\t    if (dict.mp$ass_subscript) {\n\t        pyname = new Sk.builtin.str(name);\n\n\t        if (this instanceof Sk.builtin.object && !(this.ob$type.sk$klass) &&\n\t            dict.mp$lookup(pyname) === undefined) {\n\t            // Cannot add new attributes to a builtin object\n\t            throw new Sk.builtin.AttributeError(\"'\" + objname + \"' object has no attribute '\" + name + \"'\");\n\t        }\n\t        dict.mp$ass_subscript(new Sk.builtin.str(name), value);\n\t    } else if (typeof dict === \"object\") {\n\t        dict[name] = value;\n\t    }\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.object.prototype.GenericSetAttr\", Sk.builtin.object.prototype.GenericSetAttr);\n\n\tSk.builtin.object.prototype.GenericPythonSetAttr = function(self, name, value) {\n\t    return Sk.builtin.object.prototype.GenericSetAttr.call(self, name.v, value);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.object.prototype.GenericPythonSetAttr\", Sk.builtin.object.prototype.GenericPythonSetAttr);\n\n\tSk.builtin.object.prototype.HashNotImplemented = function () {\n\t    throw new Sk.builtin.TypeError(\"unhashable type: '\" + Sk.abstr.typeName(this) + \"'\");\n\t};\n\n\tSk.builtin.object.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\tSk.builtin.object.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;\n\n\t// Although actual attribute-getting happens in pure Javascript via tp$getattr, classes\n\t// overriding __getattr__ etc need to be able to call object.__getattr__ etc from Python\n\tSk.builtin.object.prototype[\"__getattr__\"] = Sk.builtin.object.prototype.GenericPythonGetAttr;\n\tSk.builtin.object.prototype[\"__setattr__\"] = Sk.builtin.object.prototype.GenericPythonSetAttr;\n\n\t/**\n\t * The name of this class.\n\t * @type {string}\n\t */\n\tSk.builtin.object.prototype.tp$name = \"object\";\n\n\t/**\n\t * The type object of this class.\n\t * @type {Sk.builtin.type}\n\t */\n\tSk.builtin.object.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj(\"object\", Sk.builtin.object);\n\tSk.builtin.object.prototype.ob$type.sk$klass = undefined;   // Nonsense for closure compiler\n\n\t/** Default implementations of dunder methods found in all Python objects */\n\n\t/**\n\t * Python wrapper for `__repr__` method.\n\t * @name  __repr__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__repr__\"] = function (self) {\n\t    Sk.builtin.pyCheckArgs(\"__repr__\", arguments, 0, 0, false, true);\n\n\t    return self[\"$r\"]();\n\t};\n\n\t/**\n\t * Python wrapper for `__str__` method.\n\t * @name  __str__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__str__\"] = function (self) {\n\t    Sk.builtin.pyCheckArgs(\"__str__\", arguments, 0, 0, false, true);\n\n\t    return self[\"$r\"]();\n\t};\n\n\t/**\n\t * Python wrapper for `__hash__` method.\n\t * @name  __hash__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__hash__\"] = function (self) {\n\t    Sk.builtin.pyCheckArgs(\"__hash__\", arguments, 0, 0, false, true);\n\n\t    return self.tp$hash();\n\t};\n\n\t/**\n\t * Python wrapper for `__eq__` method.\n\t * @name  __eq__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__eq__\"] = function (self, other) {\n\t    Sk.builtin.pyCheckArgs(\"__eq__\", arguments, 1, 1, false, true);\n\n\t    return self.ob$eq(other);\n\t};\n\n\t/**\n\t * Python wrapper for `__ne__` method.\n\t * @name  __ne__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__ne__\"] = function (self, other) {\n\t    Sk.builtin.pyCheckArgs(\"__ne__\", arguments, 1, 1, false, true);\n\n\t    return self.ob$ne(other);\n\t};\n\n\t/**\n\t * Python wrapper for `__lt__` method.\n\t * @name  __lt__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__lt__\"] = function (self, other) {\n\t    Sk.builtin.pyCheckArgs(\"__lt__\", arguments, 1, 1, false, true);\n\n\t    return self.ob$lt(other);\n\t};\n\n\t/**\n\t * Python wrapper for `__le__` method.\n\t * @name  __le__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__le__\"] = function (self, other) {\n\t    Sk.builtin.pyCheckArgs(\"__le__\", arguments, 1, 1, false, true);\n\n\t    return self.ob$le(other);\n\t};\n\n\t/**\n\t * Python wrapper for `__gt__` method.\n\t * @name  __gt__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__gt__\"] = function (self, other) {\n\t    Sk.builtin.pyCheckArgs(\"__gt__\", arguments, 1, 1, false, true);\n\n\t    return self.ob$gt(other);\n\t};\n\n\t/**\n\t * Python wrapper for `__ge__` method.\n\t * @name  __ge__\n\t * @memberOf Sk.builtin.object.prototype\n\t * @instance\n\t */\n\tSk.builtin.object.prototype[\"__ge__\"] = function (self, other) {\n\t    Sk.builtin.pyCheckArgs(\"__ge__\", arguments, 1, 1, false, true);\n\n\t    return self.ob$ge(other);\n\t};\n\n\t/** Default implementations of Javascript functions used in dunder methods */\n\n\t/**\n\t * Return the string representation of this instance.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @name  $r\n\t * @memberOf Sk.builtin.object.prototype\n\t * @return {Sk.builtin.str} The Python string representation of this instance.\n\t */\n\tSk.builtin.object.prototype[\"$r\"] = function () {\n\t    return new Sk.builtin.str(\"<object>\");\n\t};\n\n\tSk.builtin.hashCount = 1;\n\tSk.builtin.idCount = 1;\n\n\t/**\n\t * Return the hash value of this instance.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @return {Sk.builtin.int_} The hash value\n\t */\n\tSk.builtin.object.prototype.tp$hash = function () {\n\t    if (!this.$savedHash_) {\n\t        this.$savedHash_ = new Sk.builtin.int_(Sk.builtin.hashCount++);\n\t    }\n\n\t    return this.$savedHash_;\n\t};\n\n\t/**\n\t * Perform equality check between this instance and a Python object (i.e. this == other).\n\t *\n\t * Implements `__eq__` dunder method.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @param  {Object} other The Python object to check for equality.\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if equal, false otherwise\n\t */\n\tSk.builtin.object.prototype.ob$eq = function (other) {\n\t    if (this === other) {\n\t        return Sk.builtin.bool.true$;\n\t    }\n\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\n\t};\n\n\t/**\n\t * Perform non-equality check between this instance and a Python object (i.e. this != other).\n\t *\n\t * Implements `__ne__` dunder method.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @param  {Object} other The Python object to check for non-equality.\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if not equal, false otherwise\n\t */\n\tSk.builtin.object.prototype.ob$ne = function (other) {\n\t    if (this === other) {\n\t        return Sk.builtin.bool.false$;\n\t    }\n\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\n\t};\n\n\t/**\n\t * Determine if this instance is less than a Python object (i.e. this < other).\n\t *\n\t * Implements `__lt__` dunder method.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @param  {Object} other The Python object to compare.\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this < other, false otherwise\n\t */\n\tSk.builtin.object.prototype.ob$lt = function (other) {\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\n\t};\n\n\t/**\n\t * Determine if this instance is less than or equal to a Python object (i.e. this <= other).\n\t *\n\t * Implements `__le__` dunder method.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @param  {Object} other The Python object to compare.\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this <= other, false otherwise\n\t */\n\tSk.builtin.object.prototype.ob$le = function (other) {\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\n\t};\n\n\t/**\n\t * Determine if this instance is greater than a Python object (i.e. this > other).\n\t *\n\t * Implements `__gt__` dunder method.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @param  {Object} other The Python object to compare.\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this > other, false otherwise\n\t */\n\tSk.builtin.object.prototype.ob$gt = function (other) {\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\n\t};\n\n\t/**\n\t * Determine if this instance is greater than or equal to a Python object (i.e. this >= other).\n\t *\n\t * Implements `__ge__` dunder method.\n\t *\n\t * Javascript function, returns Python object.\n\t *\n\t * @param  {Object} other The Python object to compare.\n\t * @return {(Sk.builtin.bool|Sk.builtin.NotImplemented)} true if this >= other, false otherwise\n\t */\n\tSk.builtin.object.prototype.ob$ge = function (other) {\n\t    return Sk.builtin.NotImplemented.NotImplemented$;\n\t};\n\n\t// Wrap the following functions in Sk.builtin.func once that class is initialized\n\t/**\n\t * Array of all the Python functions which are methods of this class.\n\t * @type {Array}\n\t */\n\tSk.builtin.object.pythonFunctions = [\"__repr__\", \"__str__\", \"__hash__\",\n\t\"__eq__\", \"__ne__\", \"__lt__\", \"__le__\", \"__gt__\", \"__ge__\", \"__getattr__\", \"__setattr__\"];\n\n\t/**\n\t * @constructor\n\t * Sk.builtin.none\n\t *\n\t * @extends {Sk.builtin.object}\n\t */\n\tSk.builtin.none = function () {\n\t    this.v = null;\n\t};\n\tSk.abstr.setUpInheritance(\"NoneType\", Sk.builtin.none, Sk.builtin.object);\n\n\t/** @override */\n\tSk.builtin.none.prototype[\"$r\"] = function () { return new Sk.builtin.str(\"None\"); };\n\n\t/** @override */\n\tSk.builtin.none.prototype.tp$hash = function () {\n\t    return new Sk.builtin.int_(0);\n\t};\n\n\t/**\n\t * Python None constant.\n\t * @type {Sk.builtin.none}\n\t */\n\tSk.builtin.none.none$ = new Sk.builtin.none();\n\n\t/**\n\t * @constructor\n\t * Sk.builtin.NotImplemented\n\t *\n\t * @extends {Sk.builtin.object}\n\t */\n\tSk.builtin.NotImplemented = function() { };\n\tSk.abstr.setUpInheritance(\"NotImplementedType\", Sk.builtin.NotImplemented, Sk.builtin.object);\n\n\t/** @override */\n\tSk.builtin.NotImplemented.prototype[\"$r\"] = function () { return new Sk.builtin.str(\"NotImplemented\"); };\n\n\t/**\n\t * Python NotImplemented constant.\n\t * @type {Sk.builtin.NotImplemented}\n\t */\n\tSk.builtin.NotImplemented.NotImplemented$ = new Sk.builtin.NotImplemented();\n\n\tgoog.exportSymbol(\"Sk.builtin.none\", Sk.builtin.none);\n\tgoog.exportSymbol(\"Sk.builtin.NotImplemented\", Sk.builtin.NotImplemented);\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/function.js ---- */ \n\n\t/**\n\t * @namespace Sk.builtin\n\t */\n\n\n\t/**\n\t * Check arguments to Python functions to ensure the correct number of\n\t * arguments are passed.\n\t *\n\t * @param {string} name the name of the function\n\t * @param {Object} args the args passed to the function\n\t * @param {number} minargs the minimum number of allowable arguments\n\t * @param {number=} maxargs optional maximum number of allowable\n\t * arguments (default: Infinity)\n\t * @param {boolean=} kwargs optional true if kwargs, false otherwise\n\t * (default: false)\n\t * @param {boolean=} free optional true if free vars, false otherwise\n\t * (default: false)\n\t */\n\tSk.builtin.pyCheckArgs = function (name, args, minargs, maxargs, kwargs, free) {\n\t    var nargs = args.length;\n\t    var msg = \"\";\n\n\t    if (maxargs === undefined) {\n\t        maxargs = Infinity;\n\t    }\n\t    if (kwargs) {\n\t        nargs -= 1;\n\t    }\n\t    if (free) {\n\t        nargs -= 1;\n\t    }\n\t    if ((nargs < minargs) || (nargs > maxargs)) {\n\t        if (minargs === maxargs) {\n\t            msg = name + \"() takes exactly \" + minargs + \" arguments\";\n\t        } else if (nargs < minargs) {\n\t            msg = name + \"() takes at least \" + minargs + \" arguments\";\n\t        } else {\n\t            msg = name + \"() takes at most \" + maxargs + \" arguments\";\n\t        }\n\t        msg += \" (\" + nargs + \" given)\";\n\t        throw new Sk.builtin.TypeError(msg);\n\t    }\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.pyCheckArgs\", Sk.builtin.pyCheckArgs);\n\n\t/**\n\t * Check type of argument to Python functions.\n\t *\n\t * @param {string} name the name of the argument\n\t * @param {string} exptype string of the expected type name\n\t * @param {boolean} check truthy if type check passes, falsy otherwise\n\t */\n\tSk.builtin.pyCheckType = function (name, exptype, check) {\n\t    if (!check) {\n\t        throw new Sk.builtin.TypeError(name + \" must be a \" + exptype);\n\t    }\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.pyCheckType\", Sk.builtin.pyCheckType);\n\n\tSk.builtin.checkSequence = function (arg) {\n\t    return (arg !== null && arg.mp$subscript !== undefined);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkSequence\", Sk.builtin.checkSequence);\n\n\t/**\n\t * Use this to test whether or not a Python object is iterable.  You should **not** rely\n\t * on the presence of tp$iter on the object as a good test, as it could be a user defined\n\t * class with `__iter__` defined or ``__getitem__``  This tests for all of those cases\n\t *\n\t * @param arg {Object}   A Python object\n\t * @returns {boolean} true if the object is iterable\n\t */\n\tSk.builtin.checkIterable = function (arg) {\n\t    var ret = false;\n\t    if (arg !== null ) {\n\t        try {\n\t            ret = Sk.abstr.iter(arg);\n\t            if (ret) {\n\t                return true;\n\t            } else {\n\t                return false;\n\t            }\n\t        } catch (e) {\n\t            if (e instanceof Sk.builtin.TypeError) {\n\t                return false;\n\t            } else {\n\t                throw e;\n\t            }\n\t        }\n\t    }\n\t    return ret;\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkIterable\", Sk.builtin.checkIterable);\n\n\tSk.builtin.checkCallable = function (obj) {\n\t    // takes care of builtin functions and methods, builtins\n\t    if (typeof obj === \"function\") {\n\t        return true;\n\t    }\n\t    // takes care of python function, methods and lambdas\n\t    if (obj instanceof Sk.builtin.func) {\n\t        return true;\n\t    }\n\t    // takes care of instances of methods\n\t    if (obj instanceof Sk.builtin.method) {\n\t        return true;\n\t    }\n\t    // go up the prototype chain to see if the class has a __call__ method\n\t    if (Sk.abstr.lookupSpecial(obj, \"__call__\") !== undefined) {\n\t        return true;\n\t    } \n\t    return false;\n\t};\n\n\tSk.builtin.checkNumber = function (arg) {\n\t    return (arg !== null && (typeof arg === \"number\" ||\n\t        arg instanceof Sk.builtin.int_ ||\n\t        arg instanceof Sk.builtin.float_ ||\n\t        arg instanceof Sk.builtin.lng));\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkNumber\", Sk.builtin.checkNumber);\n\n\t/**\n\t * Checks for complex type, delegates to internal method\n\t * Most skulpt users would search here!\n\t */\n\tSk.builtin.checkComplex = function (arg) {\n\t    return Sk.builtin.complex._complex_check(arg);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkComplex\", Sk.builtin.checkComplex);\n\n\tSk.builtin.checkInt = function (arg) {\n\t    return (arg !== null) && ((typeof arg === \"number\" && arg === (arg | 0)) ||\n\t        arg instanceof Sk.builtin.int_ ||\n\t        arg instanceof Sk.builtin.lng);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkInt\", Sk.builtin.checkInt);\n\n\tSk.builtin.checkFloat = function (arg) {\n\t    return (arg !== null) && (arg instanceof Sk.builtin.float_);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkFloat\", Sk.builtin.checkFloat);\n\n\tSk.builtin.checkString = function (arg) {\n\t    return (arg !== null && arg.__class__ == Sk.builtin.str);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkString\", Sk.builtin.checkString);\n\n\tSk.builtin.checkClass = function (arg) {\n\t    return (arg !== null && arg.sk$type);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkClass\", Sk.builtin.checkClass);\n\n\tSk.builtin.checkBool = function (arg) {\n\t    return (arg instanceof Sk.builtin.bool);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkBool\", Sk.builtin.checkBool);\n\n\tSk.builtin.checkNone = function (arg) {\n\t    return (arg instanceof Sk.builtin.none);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkNone\", Sk.builtin.checkNone);\n\n\tSk.builtin.checkFunction = function (arg) {\n\t    return (arg !== null && arg.tp$call !== undefined);\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.checkFunction\", Sk.builtin.checkFunction);\n\n\t/**\n\t * @constructor\n\t * Sk.builtin.func\n\t *\n\t * @description\n\t * This function converts a Javascript function into a Python object that is callable.  Or just\n\t * think of it as a Python function rather than a Javascript function now.  This is an important\n\t * distinction in skulpt because once you have Python function you cannot just call it.\n\t * You must now use Sk.misceval.callsim to call the Python function.\n\t *\n\t * @param {Function} code the javascript implementation of this function\n\t * @param {Object=} globals the globals where this function was defined.\n\t * Can be undefined (which will be stored as null) for builtins. (is\n\t * that ok?)\n\t * @param {Object=} closure dict of free variables\n\t * @param {Object=} closure2 another dict of free variables that will be\n\t * merged into 'closure'. there's 2 to simplify generated code (one is $free,\n\t * the other is $cell)\n\t *\n\t * closure is the cell variables from the parent scope that we need to close\n\t * over. closure2 is the free variables in the parent scope that we also might\n\t * need to access.\n\t *\n\t * NOTE: co_varnames and co_name are defined by compiled code only, so we have\n\t * to access them via dict-style lookup for closure.\n\t *\n\t */\n\tSk.builtin.func = function (code, globals, closure, closure2) {\n\t    var k;\n\t    this.func_code = code;\n\t    this.func_globals = globals || null;\n\t    if (closure2 !== undefined) {\n\t        // todo; confirm that modification here can't cause problems\n\t        for (k in closure2) {\n\t            closure[k] = closure2[k];\n\t        }\n\t    }\n\t    this.func_closure = closure;\n\t    return this;\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.func\", Sk.builtin.func);\n\n\n\tSk.builtin.func.prototype.tp$name = \"function\";\n\tSk.builtin.func.prototype.tp$descr_get = function (obj, objtype) {\n\t    goog.asserts.assert(obj !== undefined && objtype !== undefined);\n\t    if (obj == null) {\n\t        return this;\n\t    }\n\t    return new Sk.builtin.method(this, obj, objtype);\n\t};\n\tSk.builtin.func.prototype.tp$call = function (args, kw) {\n\t    var j;\n\t    var i;\n\t    var numvarnames;\n\t    var varnames;\n\t    var kwlen;\n\t    var kwargsarr;\n\t    var expectskw;\n\t    var name;\n\t    var numargs;\n\n\t    // note: functions expect 'this' to be globals to avoid having to\n\t    // slice/unshift onto the main args\n\t    if (this.func_closure) {\n\t        // todo; OK to modify?\n\t        if (this.func_code[\"$defaults\"] && this.func_code[\"co_varnames\"]) {\n\t            // Make sure all default arguments are in args before adding closure\n\t            numargs = args.length;\n\t            numvarnames = this.func_code[\"co_varnames\"].length;\n\t            for (i = numargs; i < numvarnames; i++) {\n\t                args.push(undefined);\n\t            }\n\t        }\n\t        args.push(this.func_closure);\n\t    }\n\n\t    expectskw = this.func_code[\"co_kwargs\"];\n\t    kwargsarr = [];\n\n\t    if (this.func_code[\"no_kw\"] && kw) {\n\t        name = (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || \"<native JS>\";\n\t        throw new Sk.builtin.TypeError(name + \"() takes no keyword arguments\");\n\t    }\n\n\t    if (kw) {\n\t        // bind the kw args\n\t        kwlen = kw.length;\n\t        varnames = this.func_code[\"co_varnames\"];\n\t        numvarnames = varnames && varnames.length;\n\t        for (i = 0; i < kwlen; i += 2) {\n\t            // todo; make this a dict mapping name to offset\n\t            for (j = 0; j < numvarnames; ++j) {\n\t                if (kw[i] === varnames[j]) {\n\t                    break;\n\t                }\n\t            }\n\t            if (varnames && j !== numvarnames) {\n\t                if (j in args) {\n\t                    name = (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || \"<native JS>\";\n\t                    throw new Sk.builtin.TypeError(name + \"() got multiple values for keyword argument '\" + kw[i] + \"'\");\n\t                }\n\t                args[j] = kw[i + 1];\n\t            } else if (expectskw) {\n\t                // build kwargs dict\n\t                kwargsarr.push(new Sk.builtin.str(kw[i]));\n\t                kwargsarr.push(kw[i + 1]);\n\t            } else {\n\t                name = (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || \"<native JS>\";\n\t                throw new Sk.builtin.TypeError(name + \"() got an unexpected keyword argument '\" + kw[i] + \"'\");\n\t            }\n\t        }\n\t    }\n\t    if (expectskw) {\n\t        args.unshift(kwargsarr);\n\t    }\n\n\t    //print(JSON.stringify(args, null, 2));\n\n\t    return this.func_code.apply(this.func_globals, args);\n\t};\n\n\tSk.builtin.func.prototype.tp$getattr = function (key) {\n\t    return this[key];\n\t};\n\tSk.builtin.func.prototype.tp$setattr = function (key, value) {\n\t    this[key] = value;\n\t};\n\n\t//todo; investigate why the other doesn't work\n\t//Sk.builtin.type.makeIntoTypeObj('function', Sk.builtin.func);\n\tSk.builtin.func.prototype.ob$type = Sk.builtin.type.makeTypeObj(\"function\", new Sk.builtin.func(null, null));\n\n\tSk.builtin.func.prototype[\"$r\"] = function () {\n\t    var name = (this.func_code && this.func_code[\"co_name\"] && this.func_code[\"co_name\"].v) || \"<native JS>\";\n\t    return new Sk.builtin.str(\"<function \" + name + \">\");\n\t};\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/seqtype.js ---- */ \n\n\t/**\n\t * @constructor\n\t * Sk.builtin.seqtype\n\t *\n\t * @description\n\t * Abstract class for Python sequence types.\n\t *\n\t * @extends {Sk.builtin.object}\n\t *\n\t * @return {undefined} Cannot instantiate a Sk.builtin.seqtype object\n\t */\n\tSk.builtin.seqtype = function () {\n\n\t    throw new Sk.builtin.ExternalError(\"Cannot instantiate abstract Sk.builtin.seqtype class\");\n\n\t};\n\n\tSk.abstr.setUpInheritance(\"SequenceType\", Sk.builtin.seqtype, Sk.builtin.object);\n\n\tSk.builtin.seqtype.sk$abstract = true;\n\n\t/**\n\t * Python wrapper of `__len__` method.\n\t *\n\t * @name  __len__\n\t * @instance\n\t * @memberOf Sk.builtin.seqtype.prototype\n\t */\n\tSk.builtin.seqtype.prototype[\"__len__\"] = new Sk.builtin.func(function (self) {\n\n\t    Sk.builtin.pyCheckArgs(\"__len__\", arguments, 0, 0, false, true);\n\n\t    return new Sk.builtin.int_(self.sq$length());    \n\n\t});\n\n\t/**\n\t * Python wrapper of `__iter__` method.\n\t *\n\t * @name  __iter__\n\t * @instance\n\t * @memberOf Sk.builtin.seqtype.prototype\n\t */\n\tSk.builtin.seqtype.prototype[\"__iter__\"] = new Sk.builtin.func(function (self) {\n\n\t    Sk.builtin.pyCheckArgs(\"__iter__\", arguments, 0, 0, false, true);\n\n\t    return self.tp$iter();\n\n\t});\n\n\t/**\n\t * Python wrapper of `__contains__` method.\n\t *\n\t * @name  __contains__\n\t * @instance\n\t * @memberOf Sk.builtin.seqtype.prototype\n\t */\n\tSk.builtin.seqtype.prototype[\"__contains__\"] = new Sk.builtin.func(function (self, item) {\n\n\t    Sk.builtin.pyCheckArgs(\"__contains__\", arguments, 1, 1, false, true);\n\n\t    if (self.sq$contains(item)) {\n\t        return Sk.builtin.bool.true$;\n\t    } else {\n\t        return Sk.builtin.bool.false$;\n\t    }\n\n\t});\n\n\t/**\n\t * Python wrapper of `__getitem__` method.\n\t *\n\t * @name  __getitem__\n\t * @instance\n\t * @memberOf Sk.builtin.seqtype.prototype\n\t */\n\tSk.builtin.seqtype.prototype[\"__getitem__\"] = new Sk.builtin.func(function (self, key) {\n\n\t    Sk.builtin.pyCheckArgs(\"__getitem__\", arguments, 1, 1, false, true);\n\n\t    return self.mp$subscript(key);\n\n\t});\n\n\t/**\n\t * Python wrapper of `__add__` method.\n\t *\n\t * @name  __add__\n\t * @instance\n\t * @memberOf Sk.builtin.seqtype.prototype\n\t */\n\tSk.builtin.seqtype.prototype[\"__add__\"] = new Sk.builtin.func(function (self, other) {\n\n\t    Sk.builtin.pyCheckArgs(\"__add__\", arguments, 1, 1, false, true);\n\n\t    return self.sq$concat(other);\n\n\t});\n\n\t/**\n\t * Python wrapper of `__mul__` method.\n\t *\n\t * @name  __mul__\n\t * @instance\n\t * @memberOf Sk.builtin.seqtype.prototype\n\t */\n\tSk.builtin.seqtype.prototype[\"__mul__\"] = new Sk.builtin.func(function (self, n) {\n\n\t    Sk.builtin.pyCheckArgs(\"__mul__\", arguments, 1, 1, false, true);\n\n\t    if (!Sk.misceval.isIndex(n)) {\n\t        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + Sk.abstr.typeName(n) + \"'\");\n\t    }\n\n\t    return self.sq$repeat(n);\n\n\t});\n\n\t/**\n\t * Python wrapper of `__rmul__` method.\n\t *\n\t * @name  __rmul__\n\t * @instance\n\t * @memberOf Sk.builtin.seqtype.prototype\n\t */\n\tSk.builtin.seqtype.prototype[\"__rmul__\"] = new Sk.builtin.func(function (self, n) {\n\n\t    Sk.builtin.pyCheckArgs(\"__rmul__\", arguments, 1, 1, false, true);\n\n\t    return self.sq$repeat(n);    \n\n\t});\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/str.js ---- */ \n\n\tSk.builtin.interned = {};\n\n\t/**\n\t * @constructor\n\t * @param {*} x\n\t * @extends Sk.builtin.object\n\t */\n\tSk.builtin.str = function (x) {\n\t    var ret;\n\t    if (x === undefined) {\n\t        x = \"\";\n\t    }\n\t    if (x instanceof Sk.builtin.str) {\n\t        return x;\n\t    }\n\t    if (!(this instanceof Sk.builtin.str)) {\n\t        return new Sk.builtin.str(x);\n\t    }\n\n\n\t    // convert to js string\n\t    if (x === true) {\n\t        ret = \"True\";\n\t    } else if (x === false) {\n\t        ret = \"False\";\n\t    } else if ((x === null) || (x instanceof Sk.builtin.none)) {\n\t        ret = \"None\";\n\t    } else if (x instanceof Sk.builtin.bool) {\n\t        if (x.v) {\n\t            ret = \"True\";\n\t        } else {\n\t            ret = \"False\";\n\t        }\n\t    } else if (typeof x === \"number\") {\n\t        ret = x.toString();\n\t        if (ret === \"Infinity\") {\n\t            ret = \"inf\";\n\t        } else if (ret === \"-Infinity\") {\n\t            ret = \"-inf\";\n\t        }\n\t    } else if (typeof x === \"string\") {\n\t        ret = x;\n\t    } else if (x.tp$str !== undefined) {\n\t        ret = x.tp$str();\n\t        if (!(ret instanceof Sk.builtin.str)) {\n\t            throw new Sk.builtin.ValueError(\"__str__ didn't return a str\");\n\t        }\n\t        return ret;\n\t    } else {\n\t        return Sk.misceval.objectRepr(x);\n\t    }\n\n\t    // interning required for strings in py\n\t    if (Sk.builtin.interned[\"1\" + ret]) {\n\t        return Sk.builtin.interned[\"1\" + ret];\n\t    }\n\n\t    this.__class__ = Sk.builtin.str;\n\t    this.v = ret;\n\t    this[\"v\"] = this.v;\n\t    Sk.builtin.interned[\"1\" + ret] = this;\n\t    return this;\n\n\t};\n\tgoog.exportSymbol(\"Sk.builtin.str\", Sk.builtin.str);\n\n\tSk.abstr.setUpInheritance(\"str\", Sk.builtin.str, Sk.builtin.seqtype);\n\n\tSk.builtin.str.prototype.mp$subscript = function (index) {\n\t    var ret;\n\t    if (Sk.misceval.isIndex(index)) {\n\t        index = Sk.misceval.asIndex(index);\n\t        if (index < 0) {\n\t            index = this.v.length + index;\n\t        }\n\t        if (index < 0 || index >= this.v.length) {\n\t            throw new Sk.builtin.IndexError(\"string index out of range\");\n\t        }\n\t        return new Sk.builtin.str(this.v.charAt(index));\n\t    } else if (index instanceof Sk.builtin.slice) {\n\t        ret = \"\";\n\t        index.sssiter$(this, function (i, wrt) {\n\t            if (i >= 0 && i < wrt.v.length) {\n\t                ret += wrt.v.charAt(i);\n\t            }\n\t        });\n\t        return new Sk.builtin.str(ret);\n\t    } else {\n\t        throw new Sk.builtin.TypeError(\"string indices must be integers, not \" + Sk.abstr.typeName(index));\n\t    }\n\t};\n\n\tSk.builtin.str.prototype.sq$length = function () {\n\t    return this.v.length;\n\t};\n\tSk.builtin.str.prototype.sq$concat = function (other) {\n\t    var otypename;\n\t    if (!other || !Sk.builtin.checkString(other)) {\n\t        otypename = Sk.abstr.typeName(other);\n\t        throw new Sk.builtin.TypeError(\"cannot concatenate 'str' and '\" + otypename + \"' objects\");\n\t    }\n\t    return new Sk.builtin.str(this.v + other.v);\n\t};\n\tSk.builtin.str.prototype.nb$add = Sk.builtin.str.prototype.sq$concat;\n\tSk.builtin.str.prototype.nb$inplace_add = Sk.builtin.str.prototype.sq$concat;\n\tSk.builtin.str.prototype.sq$repeat = function (n) {\n\t    var i;\n\t    var ret;\n\n\t    if (!Sk.misceval.isIndex(n)) {\n\t        throw new Sk.builtin.TypeError(\"can't multiply sequence by non-int of type '\" + Sk.abstr.typeName(n) + \"'\");\n\t    }\n\n\t    n = Sk.misceval.asIndex(n);\n\t    ret = \"\";\n\t    for (i = 0; i < n; ++i) {\n\t        ret += this.v;\n\t    }\n\t    return new Sk.builtin.str(ret);\n\t};\n\tSk.builtin.str.prototype.nb$multiply = Sk.builtin.str.prototype.sq$repeat;\n\tSk.builtin.str.prototype.nb$inplace_multiply = Sk.builtin.str.prototype.sq$repeat;\n\tSk.builtin.str.prototype.sq$item = function () {\n\t    goog.asserts.fail();\n\t};\n\tSk.builtin.str.prototype.sq$slice = function (i1, i2) {\n\t    i1 = Sk.builtin.asnum$(i1);\n\t    i2 = Sk.builtin.asnum$(i2);\n\t    if (i1 < 0) {\n\t        i1 = 0;\n\t    }\n\t    return new Sk.builtin.str(this.v.substr(i1, i2 - i1));\n\t};\n\n\tSk.builtin.str.prototype.sq$contains = function (ob) {\n\t    if (!(ob instanceof Sk.builtin.str)) {\n\t        throw new Sk.builtin.TypeError(\"TypeError: 'In <string> requires string as left operand\");\n\t    }\n\t    return this.v.indexOf(ob.v) != -1;\n\t};\n\n\tSk.builtin.str.prototype.__iter__ = new Sk.builtin.func(function (self) {\n\t    return new Sk.builtin.str_iter_(self);\n\t});\n\n\tSk.builtin.str.prototype.tp$iter = function () {\n\t    return new Sk.builtin.str_iter_(this);\n\t};\n\n\tSk.builtin.str.prototype.tp$richcompare = function (other, op) {\n\t    if (!(other instanceof Sk.builtin.str)) {\n\t        return undefined;\n\t    }\n\n\t    switch (op) {\n\t        case \"Lt\":\n\t            return this.v < other.v;\n\t        case \"LtE\":\n\t            return this.v <= other.v;\n\t        case \"Eq\":\n\t            return this.v === other.v;\n\t        case \"NotEq\":\n\t            return this.v !== other.v;\n\t        case \"Gt\":\n\t            return this.v > other.v;\n\t        case \"GtE\":\n\t            return this.v >= other.v;\n\t        default:\n\t            goog.asserts.fail();\n\t    }\n\t};\n\n\tSk.builtin.str.prototype[\"$r\"] = function () {\n\t    // single is preferred\n\t    var ashex;\n\t    var c;\n\t    var i;\n\t    var ret;\n\t    var len;\n\t    var quote = \"'\";\n\t    //jshint ignore:start\n\t    if (this.v.indexOf(\"'\") !== -1 && this.v.indexOf('\"') === -1) {\n\t        quote = '\"';\n\t    }\n\t    //jshint ignore:end\n\t    len = this.v.length;\n\t    ret = quote;\n\t    for (i = 0; i < len; ++i) {\n\t        c = this.v.charAt(i);\n\t        if (c === quote || c === \"\\\\\") {\n\t            ret += \"\\\\\" + c;\n\t        } else if (c === \"\\t\") {\n\t            ret += \"\\\\t\";\n\t        } else if (c === \"\\n\") {\n\t            ret += \"\\\\n\";\n\t        } else if (c === \"\\r\") {\n\t            ret += \"\\\\r\";\n\t        } else if (c < \" \" || c >= 0x7f) {\n\t            ashex = c.charCodeAt(0).toString(16);\n\t            if (ashex.length < 2) {\n\t                ashex = \"0\" + ashex;\n\t            }\n\t            ret += \"\\\\x\" + ashex;\n\t        } else {\n\t            ret += c;\n\t        }\n\t    }\n\t    ret += quote;\n\t    return new Sk.builtin.str(ret);\n\t};\n\n\n\tSk.builtin.str.re_escape_ = function (s) {\n\t    var c;\n\t    var i;\n\t    var ret = [];\n\t    var re = /^[A-Za-z0-9]+$/;\n\t    for (i = 0; i < s.length; ++i) {\n\t        c = s.charAt(i);\n\n\t        if (re.test(c)) {\n\t            ret.push(c);\n\t        } else {\n\t            if (c === \"\\\\000\") {\n\t                ret.push(\"\\\\000\");\n\t            } else {\n\t                ret.push(\"\\\\\" + c);\n\t            }\n\t        }\n\t    }\n\t    return ret.join(\"\");\n\t};\n\n\tSk.builtin.str.prototype[\"lower\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"lower\", arguments, 1, 1);\n\t    return new Sk.builtin.str(self.v.toLowerCase());\n\t});\n\n\tSk.builtin.str.prototype[\"upper\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"upper\", arguments, 1, 1);\n\t    return new Sk.builtin.str(self.v.toUpperCase());\n\t});\n\n\tSk.builtin.str.prototype[\"capitalize\"] = new Sk.builtin.func(function (self) {\n\t    var i;\n\t    var cap;\n\t    var orig;\n\t    Sk.builtin.pyCheckArgs(\"capitalize\", arguments, 1, 1);\n\t    orig = self.v;\n\n\t    if (orig.length === 0) {\n\t        return new Sk.builtin.str(\"\");\n\t    }\n\t    cap = orig.charAt(0).toUpperCase();\n\n\t    for (i = 1; i < orig.length; i++) {\n\t        cap += orig.charAt(i).toLowerCase();\n\t    }\n\t    return new Sk.builtin.str(cap);\n\t});\n\n\tSk.builtin.str.prototype[\"join\"] = new Sk.builtin.func(function (self, seq) {\n\t    var it, i;\n\t    var arrOfStrs;\n\t    Sk.builtin.pyCheckArgs(\"join\", arguments, 2, 2);\n\t    Sk.builtin.pyCheckType(\"seq\", \"iterable\", Sk.builtin.checkIterable(seq));\n\t    arrOfStrs = [];\n\t    for (it = seq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {\n\t        if (i.constructor !== Sk.builtin.str) {\n\t            throw new Sk.builtin.TypeError(\"TypeError: sequence item \" + arrOfStrs.length + \": expected string, \" + typeof i + \" found\");\n\t        }\n\t        arrOfStrs.push(i.v);\n\t    }\n\t    return new Sk.builtin.str(arrOfStrs.join(self.v));\n\t});\n\n\tSk.builtin.str.prototype[\"split\"] = new Sk.builtin.func(function (self, on, howmany) {\n\t    var splits;\n\t    var index;\n\t    var match;\n\t    var result;\n\t    var s;\n\t    var str;\n\t    var regex;\n\t    Sk.builtin.pyCheckArgs(\"split\", arguments, 1, 3);\n\t    if ((on === undefined) || (on instanceof Sk.builtin.none)) {\n\t        on = null;\n\t    }\n\t    if ((on !== null) && !Sk.builtin.checkString(on)) {\n\t        throw new Sk.builtin.TypeError(\"expected a string\");\n\t    }\n\t    if ((on !== null) && on.v === \"\") {\n\t        throw new Sk.builtin.ValueError(\"empty separator\");\n\t    }\n\t    if ((howmany !== undefined) && !Sk.builtin.checkInt(howmany)) {\n\t        throw new Sk.builtin.TypeError(\"an integer is required\");\n\t    }\n\n\t    howmany = Sk.builtin.asnum$(howmany);\n\t    regex = /[\\s]+/g;\n\t    str = self.v;\n\t    if (on === null) {\n\t        str = goog.string.trimLeft(str);\n\t    } else {\n\t        // Escape special characters in \"on\" so we can use a regexp\n\t        s = on.v.replace(/([.*+?=|\\\\\\/()\\[\\]\\{\\}^$])/g, \"\\\\$1\");\n\t        regex = new RegExp(s, \"g\");\n\t    }\n\n\t    // This is almost identical to re.split,\n\t    // except how the regexp is constructed\n\n\t    result = [];\n\t    index = 0;\n\t    splits = 0;\n\t    while ((match = regex.exec(str)) != null) {\n\t        if (match.index === regex.lastIndex) {\n\t            // empty match\n\t            break;\n\t        }\n\t        result.push(new Sk.builtin.str(str.substring(index, match.index)));\n\t        index = regex.lastIndex;\n\t        splits += 1;\n\t        if (howmany && (splits >= howmany)) {\n\t            break;\n\t        }\n\t    }\n\t    str = str.substring(index);\n\t    if (on !== null || (str.length > 0)) {\n\t        result.push(new Sk.builtin.str(str));\n\t    }\n\n\t    return new Sk.builtin.list(result);\n\t});\n\n\tSk.builtin.str.prototype[\"strip\"] = new Sk.builtin.func(function (self, chars) {\n\t    var regex;\n\t    var pattern;\n\t    Sk.builtin.pyCheckArgs(\"strip\", arguments, 1, 2);\n\t    if ((chars !== undefined) && !Sk.builtin.checkString(chars)) {\n\t        throw new Sk.builtin.TypeError(\"strip arg must be None or str\");\n\t    }\n\t    if (chars === undefined) {\n\t        pattern = /^\\s+|\\s+$/g;\n\t    } else {\n\t        regex = Sk.builtin.str.re_escape_(chars.v);\n\t        pattern = new RegExp(\"^[\" + regex + \"]+|[\" + regex + \"]+$\", \"g\");\n\t    }\n\t    return new Sk.builtin.str(self.v.replace(pattern, \"\"));\n\t});\n\n\tSk.builtin.str.prototype[\"lstrip\"] = new Sk.builtin.func(function (self, chars) {\n\t    var regex;\n\t    var pattern;\n\t    Sk.builtin.pyCheckArgs(\"lstrip\", arguments, 1, 2);\n\t    if ((chars !== undefined) && !Sk.builtin.checkString(chars)) {\n\t        throw new Sk.builtin.TypeError(\"lstrip arg must be None or str\");\n\t    }\n\t    if (chars === undefined) {\n\t        pattern = /^\\s+/g;\n\t    } else {\n\t        regex = Sk.builtin.str.re_escape_(chars.v);\n\t        pattern = new RegExp(\"^[\" + regex + \"]+\", \"g\");\n\t    }\n\t    return new Sk.builtin.str(self.v.replace(pattern, \"\"));\n\t});\n\n\tSk.builtin.str.prototype[\"rstrip\"] = new Sk.builtin.func(function (self, chars) {\n\t    var regex;\n\t    var pattern;\n\t    Sk.builtin.pyCheckArgs(\"rstrip\", arguments, 1, 2);\n\t    if ((chars !== undefined) && !Sk.builtin.checkString(chars)) {\n\t        throw new Sk.builtin.TypeError(\"rstrip arg must be None or str\");\n\t    }\n\t    if (chars === undefined) {\n\t        pattern = /\\s+$/g;\n\t    } else {\n\t        regex = Sk.builtin.str.re_escape_(chars.v);\n\t        pattern = new RegExp(\"[\" + regex + \"]+$\", \"g\");\n\t    }\n\t    return new Sk.builtin.str(self.v.replace(pattern, \"\"));\n\t});\n\n\tSk.builtin.str.prototype[\"partition\"] = new Sk.builtin.func(function (self, sep) {\n\t    var pos;\n\t    var sepStr;\n\t    Sk.builtin.pyCheckArgs(\"partition\", arguments, 2, 2);\n\t    Sk.builtin.pyCheckType(\"sep\", \"string\", Sk.builtin.checkString(sep));\n\t    sepStr = new Sk.builtin.str(sep);\n\t    pos = self.v.indexOf(sepStr.v);\n\t    if (pos < 0) {\n\t        return new Sk.builtin.tuple([self, Sk.builtin.str.$emptystr, Sk.builtin.str.$emptystr]);\n\t    }\n\n\t    return new Sk.builtin.tuple([\n\t        new Sk.builtin.str(self.v.substring(0, pos)),\n\t        sepStr,\n\t        new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))]);\n\t});\n\n\tSk.builtin.str.prototype[\"rpartition\"] = new Sk.builtin.func(function (self, sep) {\n\t    var pos;\n\t    var sepStr;\n\t    Sk.builtin.pyCheckArgs(\"rpartition\", arguments, 2, 2);\n\t    Sk.builtin.pyCheckType(\"sep\", \"string\", Sk.builtin.checkString(sep));\n\t    sepStr = new Sk.builtin.str(sep);\n\t    pos = self.v.lastIndexOf(sepStr.v);\n\t    if (pos < 0) {\n\t        return new Sk.builtin.tuple([Sk.builtin.str.$emptystr, Sk.builtin.str.$emptystr, self]);\n\t    }\n\n\t    return new Sk.builtin.tuple([\n\t        new Sk.builtin.str(self.v.substring(0, pos)),\n\t        sepStr,\n\t        new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))]);\n\t});\n\n\tSk.builtin.str.prototype[\"count\"] = new Sk.builtin.func(function (self, pat, start, end) {\n\t    var normaltext;\n\t    var ctl;\n\t    var slice;\n\t    var m;\n\t    Sk.builtin.pyCheckArgs(\"count\", arguments, 2, 4);\n\t    if (!Sk.builtin.checkString(pat)) {\n\t        throw new Sk.builtin.TypeError(\"expected a character buffer object\");\n\t    }\n\t    if ((start !== undefined) && !Sk.builtin.checkInt(start)) {\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n\t    }\n\t    if ((end !== undefined) && !Sk.builtin.checkInt(end)) {\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n\t    }\n\n\t    if (start === undefined) {\n\t        start = 0;\n\t    } else {\n\t        start = Sk.builtin.asnum$(start);\n\t        start = start >= 0 ? start : self.v.length + start;\n\t    }\n\n\t    if (end === undefined) {\n\t        end = self.v.length;\n\t    } else {\n\t        end = Sk.builtin.asnum$(end);\n\t        end = end >= 0 ? end : self.v.length + end;\n\t    }\n\n\t    normaltext = pat.v.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n\t    m = new RegExp(normaltext, \"g\");\n\t    slice = self.v.slice(start, end);\n\t    ctl = slice.match(m);\n\t    if (!ctl) {\n\t        return  new Sk.builtin.int_(0);\n\t    } else {\n\t        return new Sk.builtin.int_(ctl.length);\n\t    }\n\n\t});\n\n\tSk.builtin.str.prototype[\"ljust\"] = new Sk.builtin.func(function (self, len, fillchar) {\n\t    var newstr;\n\t    Sk.builtin.pyCheckArgs(\"ljust\", arguments, 2, 3);\n\t    if (!Sk.builtin.checkInt(len)) {\n\t        throw new Sk.builtin.TypeError(\"integer argument exepcted, got \" + Sk.abstr.typeName(len));\n\t    }\n\t    if ((fillchar !== undefined) && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {\n\t        throw new Sk.builtin.TypeError(\"must be char, not \" + Sk.abstr.typeName(fillchar));\n\t    }\n\t    if (fillchar === undefined) {\n\t        fillchar = \" \";\n\t    } else {\n\t        fillchar = fillchar.v;\n\t    }\n\t    len = Sk.builtin.asnum$(len);\n\t    if (self.v.length >= len) {\n\t        return self;\n\t    } else {\n\t        newstr = Array.prototype.join.call({length: Math.floor(len - self.v.length) + 1}, fillchar);\n\t        return new Sk.builtin.str(self.v + newstr);\n\t    }\n\t});\n\n\tSk.builtin.str.prototype[\"rjust\"] = new Sk.builtin.func(function (self, len, fillchar) {\n\t    var newstr;\n\t    Sk.builtin.pyCheckArgs(\"rjust\", arguments, 2, 3);\n\t    if (!Sk.builtin.checkInt(len)) {\n\t        throw new Sk.builtin.TypeError(\"integer argument exepcted, got \" + Sk.abstr.typeName(len));\n\t    }\n\t    if ((fillchar !== undefined) && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {\n\t        throw new Sk.builtin.TypeError(\"must be char, not \" + Sk.abstr.typeName(fillchar));\n\t    }\n\t    if (fillchar === undefined) {\n\t        fillchar = \" \";\n\t    } else {\n\t        fillchar = fillchar.v;\n\t    }\n\t    len = Sk.builtin.asnum$(len);\n\t    if (self.v.length >= len) {\n\t        return self;\n\t    } else {\n\t        newstr = Array.prototype.join.call({length: Math.floor(len - self.v.length) + 1}, fillchar);\n\t        return new Sk.builtin.str(newstr + self.v);\n\t    }\n\n\t});\n\n\tSk.builtin.str.prototype[\"center\"] = new Sk.builtin.func(function (self, len, fillchar) {\n\t    var newstr;\n\t    var newstr1;\n\t    Sk.builtin.pyCheckArgs(\"center\", arguments, 2, 3);\n\t    if (!Sk.builtin.checkInt(len)) {\n\t        throw new Sk.builtin.TypeError(\"integer argument exepcted, got \" + Sk.abstr.typeName(len));\n\t    }\n\t    if ((fillchar !== undefined) && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {\n\t        throw new Sk.builtin.TypeError(\"must be char, not \" + Sk.abstr.typeName(fillchar));\n\t    }\n\t    if (fillchar === undefined) {\n\t        fillchar = \" \";\n\t    } else {\n\t        fillchar = fillchar.v;\n\t    }\n\t    len = Sk.builtin.asnum$(len);\n\t    if (self.v.length >= len) {\n\t        return self;\n\t    } else {\n\t        newstr1 = Array.prototype.join.call({length: Math.floor((len - self.v.length) / 2) + 1}, fillchar);\n\t        newstr = newstr1 + self.v + newstr1;\n\t        if (newstr.length < len) {\n\t            newstr = newstr + fillchar;\n\t        }\n\t        return new Sk.builtin.str(newstr);\n\t    }\n\n\t});\n\n\tSk.builtin.str.prototype[\"find\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n\t    var idx;\n\t    Sk.builtin.pyCheckArgs(\"find\", arguments, 2, 4);\n\t    if (!Sk.builtin.checkString(tgt)) {\n\t        throw new Sk.builtin.TypeError(\"expected a character buffer object\");\n\t    }\n\t    if ((start !== undefined) && !Sk.builtin.checkInt(start)) {\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n\t    }\n\t    if ((end !== undefined) && !Sk.builtin.checkInt(end)) {\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n\t    }\n\n\t    if (start === undefined) {\n\t        start = 0;\n\t    } else {\n\t        start = Sk.builtin.asnum$(start);\n\t        start = start >= 0 ? start : self.v.length + start;\n\t    }\n\n\t    if (end === undefined) {\n\t        end = self.v.length;\n\t    } else {\n\t        end = Sk.builtin.asnum$(end);\n\t        end = end >= 0 ? end : self.v.length + end;\n\t    }\n\n\t    idx = self.v.indexOf(tgt.v, start);\n\t    idx = ((idx >= start) && (idx < end)) ? idx : -1;\n\n\t    return new Sk.builtin.int_(idx);\n\t});\n\n\tSk.builtin.str.prototype[\"index\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n\t    var idx;\n\t    Sk.builtin.pyCheckArgs(\"index\", arguments, 2, 4);\n\t    idx = Sk.misceval.callsim(self[\"find\"], self, tgt, start, end);\n\t    if (Sk.builtin.asnum$(idx) === -1) {\n\t        throw new Sk.builtin.ValueError(\"substring not found\");\n\t    }\n\t    return idx;\n\t});\n\n\tSk.builtin.str.prototype[\"rfind\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n\t    var idx;\n\t    Sk.builtin.pyCheckArgs(\"rfind\", arguments, 2, 4);\n\t    if (!Sk.builtin.checkString(tgt)) {\n\t        throw new Sk.builtin.TypeError(\"expected a character buffer object\");\n\t    }\n\t    if ((start !== undefined) && !Sk.builtin.checkInt(start)) {\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n\t    }\n\t    if ((end !== undefined) && !Sk.builtin.checkInt(end)) {\n\t        throw new Sk.builtin.TypeError(\"slice indices must be integers or None or have an __index__ method\");\n\t    }\n\n\t    if (start === undefined) {\n\t        start = 0;\n\t    } else {\n\t        start = Sk.builtin.asnum$(start);\n\t        start = start >= 0 ? start : self.v.length + start;\n\t    }\n\n\t    if (end === undefined) {\n\t        end = self.v.length;\n\t    } else {\n\t        end = Sk.builtin.asnum$(end);\n\t        end = end >= 0 ? end : self.v.length + end;\n\t    }\n\n\t    idx = self.v.lastIndexOf(tgt.v, end);\n\t    idx = (idx !== end) ? idx : self.v.lastIndexOf(tgt.v, end - 1);\n\t    idx = ((idx >= start) && (idx < end)) ? idx : -1;\n\n\t    return new Sk.builtin.int_(idx);\n\t});\n\n\tSk.builtin.str.prototype[\"rindex\"] = new Sk.builtin.func(function (self, tgt, start, end) {\n\t    var idx;\n\t    Sk.builtin.pyCheckArgs(\"rindex\", arguments, 2, 4);\n\t    idx = Sk.misceval.callsim(self[\"rfind\"], self, tgt, start, end);\n\t    if (Sk.builtin.asnum$(idx) === -1) {\n\t        throw new Sk.builtin.ValueError(\"substring not found\");\n\t    }\n\t    return idx;\n\t});\n\n\tSk.builtin.str.prototype[\"startswith\"] = new Sk.builtin.func(function (self, tgt) {\n\t    Sk.builtin.pyCheckArgs(\"startswith\", arguments, 2, 2);\n\t    Sk.builtin.pyCheckType(\"tgt\", \"string\", Sk.builtin.checkString(tgt));\n\t    return new Sk.builtin.bool( self.v.indexOf(tgt.v) === 0);\n\t});\n\n\t// http://stackoverflow.com/questions/280634/endswith-in-javascript\n\tSk.builtin.str.prototype[\"endswith\"] = new Sk.builtin.func(function (self, tgt) {\n\t    Sk.builtin.pyCheckArgs(\"endswith\", arguments, 2, 2);\n\t    Sk.builtin.pyCheckType(\"tgt\", \"string\", Sk.builtin.checkString(tgt));\n\t    return new Sk.builtin.bool( self.v.indexOf(tgt.v, self.v.length - tgt.v.length) !== -1);\n\t});\n\n\tSk.builtin.str.prototype[\"replace\"] = new Sk.builtin.func(function (self, oldS, newS, count) {\n\t    var c;\n\t    var patt;\n\t    Sk.builtin.pyCheckArgs(\"replace\", arguments, 3, 4);\n\t    Sk.builtin.pyCheckType(\"oldS\", \"string\", Sk.builtin.checkString(oldS));\n\t    Sk.builtin.pyCheckType(\"newS\", \"string\", Sk.builtin.checkString(newS));\n\t    if ((count !== undefined) && !Sk.builtin.checkInt(count)) {\n\t        throw new Sk.builtin.TypeError(\"integer argument expected, got \" +\n\t            Sk.abstr.typeName(count));\n\t    }\n\t    count = Sk.builtin.asnum$(count);\n\t    patt = new RegExp(Sk.builtin.str.re_escape_(oldS.v), \"g\");\n\n\t    if ((count === undefined) || (count < 0)) {\n\t        return new Sk.builtin.str(self.v.replace(patt, newS.v));\n\t    }\n\n\t    c = 0;\n\n\t    function replacer (match) {\n\t        c++;\n\t        if (c <= count) {\n\t            return newS.v;\n\t        }\n\t        return match;\n\t    }\n\n\t    return new Sk.builtin.str(self.v.replace(patt, replacer));\n\t});\n\n\tSk.builtin.str.prototype[\"zfill\"] = new Sk.builtin.func(function (self, len) {\n\t    var str = self.v;\n\t    var ret;\n\t    var zeroes;\n\t    var offset;\n\t    var pad = \"\";\n\n\t    Sk.builtin.pyCheckArgs(\"zfill\", arguments, 2, 2);\n\t    if (! Sk.builtin.checkInt(len)) {\n\t        throw new Sk.builtin.TypeError(\"integer argument exepected, got \" + Sk.abstr.typeName(len));\n\t    }\n\n\t    // figure out how many zeroes are needed to make the proper length\n\t    zeroes = len.v - str.length;\n\t    // offset by 1 if there is a +/- at the beginning of the string\n\t    offset = (str[0] === \"+\" || str[0] === \"-\") ? 1 : 0;\n\t    for(var i = 0; i < zeroes; i++){\n\t        pad += \"0\";\n\t    }\n\t    // combine the string and the zeroes\n\t    ret = str.substr(0, offset) + pad + str.substr(offset);\n\t    return new Sk.builtin.str(ret);\n\n\n\t});\n\n\tSk.builtin.str.prototype[\"isdigit\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"isdigit\", arguments, 1, 1);\n\t    return new Sk.builtin.bool( /^\\d+$/.test(self.v));\n\t});\n\n\tSk.builtin.str.prototype[\"isspace\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"isspace\", arguments, 1, 1);\n\t    return new Sk.builtin.bool( /^\\s+$/.test(self.v));\n\t});\n\n\n\tSk.builtin.str.prototype[\"expandtabs\"] = new Sk.builtin.func(function (self, tabsize) {\n\t    // var input = self.v;\n\t    // var expanded = \"\";\n\t    // var split;\n\t    // var spacestr = \"\";\n\t    // var spacerem;\n\n\n\t    var spaces;\n\t    var expanded;\n\n\t    Sk.builtin.pyCheckArgs(\"expandtabs\", arguments, 1, 2);\n\n\n\t    if ((tabsize !== undefined) && ! Sk.builtin.checkInt(tabsize)) {\n\t        throw new Sk.builtin.TypeError(\"integer argument exepected, got \" + Sk.abstr.typeName(tabsize));\n\t    }\n\t    if (tabsize === undefined) {\n\t        tabsize = 8;\n\t    } else {\n\t        tabsize = Sk.builtin.asnum$(tabsize);\n\t    }\n\n\t    spaces = (new Array(tabsize + 1)).join(\" \");\n\t    expanded = self.v.replace(/([^\\r\\n\\t]*)\\t/g, function(a, b) {\n\t        return b + spaces.slice(b.length % tabsize);\n\t    });\n\t    return new Sk.builtin.str(expanded);\n\t});\n\n\tSk.builtin.str.prototype[\"swapcase\"] = new Sk.builtin.func(function (self) {\n\t    var ret;\n\t    Sk.builtin.pyCheckArgs(\"swapcase\", arguments, 1, 1);\n\n\n\t    ret = self.v.replace(/[a-z]/gi, function(c) {\n\t        var lc = c.toLowerCase();\n\t        return lc === c ? c.toUpperCase() : lc;\n\t    });\n\n\t    return new Sk.builtin.str(ret);\n\t});\n\n\tSk.builtin.str.prototype[\"splitlines\"] = new Sk.builtin.func(function (self, keepends) {\n\t    var data = self.v;\n\t    var i = 0;\n\t    var j = i;\n\t    var selflen = self.v.length;\n\t    var strs_w = [];\n\t    var ch;\n\t    var eol;\n\t    var sol = 0;\n\t    var slice;\n\t    Sk.builtin.pyCheckArgs(\"splitlines\", arguments, 1, 2);\n\t    if ((keepends !== undefined) && ! Sk.builtin.checkBool(keepends)) {\n\t        throw new Sk.builtin.TypeError(\"boolean argument expected, got \" + Sk.abstr.typeName(keepends));\n\t    }\n\t    if (keepends === undefined) {\n\t        keepends = false;\n\t    } else {\n\t        keepends = keepends.v;\n\t    }\n\n\n\t    for (i = 0; i < selflen; i ++) {\n\t        ch = data.charAt(i);\n\t        if (data.charAt(i + 1) === \"\\n\" && ch === \"\\r\") {\n\t            eol = i + 2;\n\t            slice = data.slice(sol, eol);\n\t            if (! keepends) {\n\t                slice = slice.replace(/(\\r|\\n)/g, \"\");\n\t            }\n\t            strs_w.push(new Sk.builtin.str(slice));\n\t            sol = eol;\n\t        } else if ((ch === \"\\n\" && data.charAt(i - 1) !== \"\\r\") || ch === \"\\r\") {\n\t            eol = i + 1;\n\t            slice = data.slice(sol, eol);\n\t            if (! keepends) {\n\t                slice = slice.replace(/(\\r|\\n)/g, \"\");\n\t            }\n\t            strs_w.push(new Sk.builtin.str(slice));\n\t            sol = eol;\n\t        }\n\n\t    }\n\t    if (sol < selflen) {\n\t        eol = selflen;\n\t        slice = data.slice(sol, eol);\n\t        if (! keepends) {\n\t            slice = slice.replace(/(\\r|\\n)/g, \"\");\n\t        }\n\t        strs_w.push(new Sk.builtin.str(slice));\n\t    }\n\t    return new Sk.builtin.list(strs_w);\n\t});\n\n\tSk.builtin.str.prototype[\"title\"] = new Sk.builtin.func(function (self) {\n\t    var ret;\n\n\t    Sk.builtin.pyCheckArgs(\"title\", arguments, 1, 1);\n\n\t    ret = self.v.replace(/[a-z][a-z]*/gi, function(str) {\n\t        return str[0].toUpperCase() + str.substr(1).toLowerCase();\n\t    });\n\n\t    return new Sk.builtin.str(ret);\n\t});\n\n\tSk.builtin.str.prototype[\"isalpha\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"isalpha\", arguments, 1, 1);\n\t    return new Sk.builtin.bool( self.v.length && goog.string.isAlpha(self.v));\n\t});\n\n\tSk.builtin.str.prototype[\"isalnum\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"isalnum\", arguments, 1, 1);\n\t    return new Sk.builtin.bool( self.v.length && goog.string.isAlphaNumeric(self.v));\n\t});\n\n\t// does not account for unicode numeric values\n\tSk.builtin.str.prototype[\"isnumeric\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"isnumeric\", arguments, 1, 1);\n\t    return new Sk.builtin.bool( self.v.length && goog.string.isNumeric(self.v));\n\t});\n\n\tSk.builtin.str.prototype[\"islower\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"islower\", arguments, 1, 1);\n\t    return new Sk.builtin.bool( self.v.length && /[a-z]/.test(self.v) && !/[A-Z]/.test(self.v));\n\t});\n\n\tSk.builtin.str.prototype[\"isupper\"] = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"isupper\", arguments, 1, 1);\n\t    return new Sk.builtin.bool( self.v.length && !/[a-z]/.test(self.v) && /[A-Z]/.test(self.v));\n\t});\n\n\tSk.builtin.str.prototype[\"istitle\"] = new Sk.builtin.func(function (self) {\n\t    // Comparing to str.title() seems the most intuitive thing, but it fails on \"\",\n\t    // Other empty-ish strings with no change.\n\t    var input = self.v;\n\t    var cased = false;\n\t    var previous_is_cased = false;\n\t    var pos;\n\t    var ch;\n\t    Sk.builtin.pyCheckArgs(\"istitle\", arguments, 1, 1);\n\t    for (pos = 0; pos < input.length; pos ++) {\n\t        ch = input.charAt(pos);\n\t        if (! /[a-z]/.test(ch) && /[A-Z]/.test(ch)) {\n\t            if (previous_is_cased) {\n\t                return new Sk.builtin.bool( false);\n\t            }\n\t            previous_is_cased = true;\n\t            cased = true;\n\t        } else if (/[a-z]/.test(ch) && ! /[A-Z]/.test(ch)) {\n\t            if (! previous_is_cased) {\n\t                return new Sk.builtin.bool( false);\n\t            }\n\t            cased = true;\n\t        } else {\n\t            previous_is_cased = false;\n\t        }\n\t    }\n\t    return new Sk.builtin.bool( cased);\n\t});\n\n\tSk.builtin.str.prototype.nb$remainder = function (rhs) {\n\t    // % format op. rhs can be a value, a tuple, or something with __getitem__ (dict)\n\n\t    // From http://docs.python.org/library/stdtypes.html#string-formatting the\n\t    // format looks like:\n\t    // 1. The '%' character, which marks the start of the specifier.\n\t    // 2. Mapping key (optional), consisting of a parenthesised sequence of characters (for example, (somename)).\n\t    // 3. Conversion flags (optional), which affect the result of some conversion types.\n\t    // 4. Minimum field width (optional). If specified as an '*' (asterisk), the actual width is read from the next\n\t    // element of the tuple in values, and the object to convert comes after the minimum field width and optional\n\t    // precision. 5. Precision (optional), given as a '.' (dot) followed by the precision. If specified as '*' (an\n\t    // asterisk), the actual width is read from the next element of the tuple in values, and the value to convert comes\n\t    // after the precision. 6. Length modifier (optional). 7. Conversion type.  length modifier is ignored\n\n\t    var ret;\n\t    var replFunc;\n\t    var index;\n\t    var regex;\n\t    if (rhs.constructor !== Sk.builtin.tuple && (rhs.mp$subscript === undefined || rhs.constructor === Sk.builtin.str)) {\n\t        rhs = new Sk.builtin.tuple([rhs]);\n\t    }\n\n\t    // general approach is to use a regex that matches the format above, and\n\t    // do an re.sub with a function as replacement to make the subs.\n\n\t    //           1 2222222222222222   33333333   444444444   5555555555555  66666  777777777777777777\n\t    regex = /%(\\([a-zA-Z0-9]+\\))?([#0 +\\-]+)?(\\*|[0-9]+)?(\\.(\\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrs%])/g;\n\t    index = 0;\n\t    replFunc = function (substring, mappingKey, conversionFlags, fieldWidth, precision, precbody, conversionType) {\n\t        var result;\n\t        var convName;\n\t        var convValue;\n\t        var base;\n\t        var r;\n\t        var mk;\n\t        var value;\n\t        var handleWidth;\n\t        var formatNumber;\n\t        var alternateForm;\n\t        var precedeWithSign;\n\t        var blankBeforePositive;\n\t        var leftAdjust;\n\t        var zeroPad;\n\t        var i;\n\t        fieldWidth = Sk.builtin.asnum$(fieldWidth);\n\t        precision = Sk.builtin.asnum$(precision);\n\n\t        if (mappingKey === undefined || mappingKey === \"\") {\n\t            i = index++;\n\t        } // ff passes '' not undef for some reason\n\n\t        if (precision === \"\") { // ff passes '' here aswell causing problems with G,g, etc.\n\t            precision = undefined;\n\t        }\n\n\t        zeroPad = false;\n\t        leftAdjust = false;\n\t        blankBeforePositive = false;\n\t        precedeWithSign = false;\n\t        alternateForm = false;\n\t        if (conversionFlags) {\n\t            if (conversionFlags.indexOf(\"-\") !== -1) {\n\t                leftAdjust = true;\n\t            } else if (conversionFlags.indexOf(\"0\") !== -1) {\n\t                zeroPad = true;\n\t            }\n\n\t            if (conversionFlags.indexOf(\"+\") !== -1) {\n\t                precedeWithSign = true;\n\t            } else if (conversionFlags.indexOf(\" \") !== -1) {\n\t                blankBeforePositive = true;\n\t            }\n\n\t            alternateForm = conversionFlags.indexOf(\"#\") !== -1;\n\t        }\n\n\t        if (precision) {\n\t            precision = parseInt(precision.substr(1), 10);\n\t        }\n\n\t        formatNumber = function (n, base) {\n\t            var precZeroPadded;\n\t            var prefix;\n\t            var didSign;\n\t            var neg;\n\t            var r;\n\t            var j;\n\t            base = Sk.builtin.asnum$(base);\n\t            neg = false;\n\t            didSign = false;\n\t            if (typeof n === \"number\") {\n\t                if (n < 0) {\n\t                    n = -n;\n\t                    neg = true;\n\t                }\n\t                r = n.toString(base);\n\t            } else if (n instanceof Sk.builtin.float_) {\n\t                r = n.str$(base, false);\n\t                if (r.length > 2 && r.substr(-2) === \".0\") {\n\t                    r = r.substr(0, r.length - 2);\n\t                }\n\t                neg = n.nb$isnegative();\n\t            } else if (n instanceof Sk.builtin.int_) {\n\t                r = n.str$(base, false);\n\t                neg = n.nb$isnegative();\n\t            } else if (n instanceof Sk.builtin.lng) {\n\t                r = n.str$(base, false);\n\t                neg = n.nb$isnegative();\t//\tneg = n.size$ < 0;\tRNL long.js change\n\t            }\n\n\t            goog.asserts.assert(r !== undefined, \"unhandled number format\");\n\n\t            precZeroPadded = false;\n\n\t            if (precision) {\n\t                //print(\"r.length\",r.length,\"precision\",precision);\n\t                for (j = r.length; j < precision; ++j) {\n\t                    r = \"0\" + r;\n\t                    precZeroPadded = true;\n\t                }\n\t            }\n\n\t            prefix = \"\";\n\n\t            if (neg) {\n\t                prefix = \"-\";\n\t            } else if (precedeWithSign) {\n\t                prefix = \"+\" + prefix;\n\t            } else if (blankBeforePositive) {\n\t                prefix = \" \" + prefix;\n\t            }\n\n\t            if (alternateForm) {\n\t                if (base === 16) {\n\t                    prefix += \"0x\";\n\t                } else if (base === 8 && !precZeroPadded && r !== \"0\") {\n\t                    prefix += \"0\";\n\t                }\n\t            }\n\n\t            return [prefix, r];\n\t        };\n\n\t        handleWidth = function (args) {\n\t            var totLen;\n\t            var prefix = args[0];\n\t            var r = args[1];\n\t            var j;\n\t            if (fieldWidth) {\n\t                fieldWidth = parseInt(fieldWidth, 10);\n\t                totLen = r.length + prefix.length;\n\t                if (zeroPad) {\n\t                    for (j = totLen; j < fieldWidth; ++j) {\n\t                        r = \"0\" + r;\n\t                    }\n\t                } else if (leftAdjust) {\n\t                    for (j = totLen; j < fieldWidth; ++j) {\n\t                        r = r + \" \";\n\t                    }\n\t                } else {\n\t                    for (j = totLen; j < fieldWidth; ++j) {\n\t                        prefix = \" \" + prefix;\n\t                    }\n\t                }\n\t            }\n\t            return prefix + r;\n\t        };\n\n\t        //print(\"Rhs:\",rhs, \"ctor\", rhs.constructor);\n\t        if (rhs.constructor === Sk.builtin.tuple) {\n\t            value = rhs.v[i];\n\t        } else if (rhs.mp$subscript !== undefined && mappingKey !== undefined) {\n\t            mk = mappingKey.substring(1, mappingKey.length - 1);\n\t            //print(\"mk\",mk);\n\t            value = rhs.mp$subscript(new Sk.builtin.str(mk));\n\t        } else if (rhs.constructor === Sk.builtin.dict || rhs.constructor === Sk.builtin.list) {\n\t            // new case where only one argument is provided\n\t            value = rhs;\n\t        } else {\n\t            throw new Sk.builtin.AttributeError(rhs.tp$name + \" instance has no attribute 'mp$subscript'\");\n\t        }\n\t        base = 10;\n\t        if (conversionType === \"d\" || conversionType === \"i\") {\n\t            return handleWidth(formatNumber(value, 10));\n\t        } else if (conversionType === \"o\") {\n\t            return handleWidth(formatNumber(value, 8));\n\t        } else if (conversionType === \"x\") {\n\t            return handleWidth(formatNumber(value, 16));\n\t        } else if (conversionType === \"X\") {\n\t            return handleWidth(formatNumber(value, 16)).toUpperCase();\n\t        } else if (conversionType === \"f\" || conversionType === \"F\" || conversionType === \"e\" || conversionType === \"E\" || conversionType === \"g\" || conversionType === \"G\") {\n\t            convValue = Sk.builtin.asnum$(value);\n\t            if (typeof convValue === \"string\") {\n\t                convValue = Number(convValue);\n\t            }\n\t            if (convValue === Infinity) {\n\t                return \"inf\";\n\t            }\n\t            if (convValue === -Infinity) {\n\t                return \"-inf\";\n\t            }\n\t            if (isNaN(convValue)) {\n\t                return \"nan\";\n\t            }\n\t            convName = [\"toExponential\", \"toFixed\", \"toPrecision\"][\"efg\".indexOf(conversionType.toLowerCase())];\n\t            if (precision === undefined || precision === \"\") {\n\t                if (conversionType === \"e\" || conversionType === \"E\") {\n\t                    precision = 6;\n\t                } else if (conversionType === \"f\" || conversionType === \"F\") {\n\t                    precision = 7;\n\t                }\n\t            }\n\t            result = (convValue)[convName](precision); // possible loose of negative zero sign\n\n\t            // apply sign to negative zeros, floats only!\n\t            if(Sk.builtin.checkFloat(value)) {\n\t                if(convValue === 0 && 1/convValue === -Infinity) {\n\t                    result = \"-\" + result; // add sign for zero\n\t                }\n\t            }\n\n\t            if (\"EFG\".indexOf(conversionType) !== -1) {\n\t                result = result.toUpperCase();\n\t            }\n\t            return handleWidth([\"\", result]);\n\t        } else if (conversionType === \"c\") {\n\t            if (typeof value === \"number\") {\n\t                return String.fromCharCode(value);\n\t            } else if (value instanceof Sk.builtin.int_) {\n\t                return String.fromCharCode(value.v);\n\t            } else if (value instanceof Sk.builtin.float_) {\n\t                return String.fromCharCode(value.v);\n\t            } else if (value instanceof Sk.builtin.lng) {\n\t                return String.fromCharCode(value.str$(10, false)[0]);\n\t            } else if (value.constructor === Sk.builtin.str) {\n\t                return value.v.substr(0, 1);\n\t            } else {\n\t                throw new Sk.builtin.TypeError(\"an integer is required\");\n\t            }\n\t        } else if (conversionType === \"r\") {\n\t            r = Sk.builtin.repr(value);\n\t            if (precision) {\n\t                return r.v.substr(0, precision);\n\t            }\n\t            return r.v;\n\t        } else if (conversionType === \"s\") {\n\t            r = new Sk.builtin.str(value);\n\t            if (precision) {\n\t                return r.v.substr(0, precision);\n\t            }\n\t            if(fieldWidth) {\n\t                r.v = handleWidth([\" \", r.v]);\n\t            }\n\t            return r.v;\n\t        } else if (conversionType === \"%\") {\n\t            return \"%\";\n\t        }\n\t    };\n\n\t    ret = this.v.replace(regex, replFunc);\n\t    return new Sk.builtin.str(ret);\n\t};\n\n\t/**\n\t * @constructor\n\t * @param {Object} obj\n\t */\n\tSk.builtin.str_iter_ = function (obj) {\n\t    if (!(this instanceof Sk.builtin.str_iter_)) {\n\t        return new Sk.builtin.str_iter_(obj);\n\t    }\n\t    this.$index = 0;\n\t    this.$obj = obj.v.slice();\n\t    this.sq$length = this.$obj.length;\n\t    this.tp$iter = this;\n\t    this.tp$iternext = function () {\n\t        if (this.$index >= this.sq$length) {\n\t            return undefined;\n\t        }\n\t        return new Sk.builtin.str(this.$obj.substr(this.$index++, 1));\n\t    };\n\t    this.$r = function () {\n\t        return new Sk.builtin.str(\"iterator\");\n\t    };\n\t    return this;\n\t};\n\n\tSk.abstr.setUpInheritance(\"iterator\", Sk.builtin.str_iter_, Sk.builtin.object);\n\n\tSk.builtin.str_iter_.prototype.__class__ = Sk.builtin.str_iter_;\n\n\tSk.builtin.str_iter_.prototype.__iter__ = new Sk.builtin.func(function (self) {\n\t    Sk.builtin.pyCheckArgs(\"__iter__\", arguments, 0, 0, true, false);\n\t    return self;\n\t});\n\n\tSk.builtin.str_iter_.prototype[\"next\"] = new Sk.builtin.func(function (self) {\n\t    var ret = self.tp$iternext();\n\t    if (ret === undefined) {\n\t        throw new Sk.builtin.StopIteration();\n\t    }\n\t    return ret;\n\t});\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/tokenize.js ---- */ \n\n\t/*\n\t * This is a port of tokenize.py by Ka-Ping Yee.\n\t *\n\t * each call to readline should return one line of input as a string, or\n\t * undefined if it's finished.\n\t *\n\t * callback is called for each token with 5 args:\n\t * 1. the token type\n\t * 2. the token string\n\t * 3. [ start_row, start_col ]\n\t * 4. [ end_row, end_col ]\n\t * 5. logical line where the token was found, including continuation lines\n\t *\n\t * callback can return true to abort.\n\t *\n\t */\n\n\t/**\n\t * @constructor\n\t */\n\tSk.Tokenizer = function (filename, interactive, callback) {\n\t    this.filename = filename;\n\t    this.callback = callback;\n\t    this.lnum = 0;\n\t    this.parenlev = 0;\n\t    this.parenstack = [];\n\t    this.continued = false;\n\t    this.namechars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\";\n\t    this.numchars = \"0123456789\";\n\t    this.contstr = \"\";\n\t    this.needcont = false;\n\t    this.contline = undefined;\n\t    this.indents = [0];\n\t    this.endprog = /.*/;\n\t    this.strstart = [-1, -1];\n\t    this.interactive = interactive;\n\t    this.doneFunc = function () {\n\t        var i;\n\t        for (i = 1; i < this.indents.length; ++i) // pop remaining indent levels\n\t        {\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, \"\", [this.lnum, 0], [this.lnum, 0], \"\")) {\n\t                return \"done\";\n\t            }\n\t        }\n\t        if (this.callback(Sk.Tokenizer.Tokens.T_ENDMARKER, \"\", [this.lnum, 0], [this.lnum, 0], \"\")) {\n\t            return \"done\";\n\t        }\n\n\t        return \"failed\";\n\t    };\n\n\t};\n\n\t/**\n\t * @enum {number}\n\t */\n\tSk.Tokenizer.Tokens = {\n\t    T_ENDMARKER       : 0,\n\t    T_NAME            : 1,\n\t    T_NUMBER          : 2,\n\t    T_STRING          : 3,\n\t    T_NEWLINE         : 4,\n\t    T_INDENT          : 5,\n\t    T_DEDENT          : 6,\n\t    T_LPAR            : 7,\n\t    T_RPAR            : 8,\n\t    T_LSQB            : 9,\n\t    T_RSQB            : 10,\n\t    T_COLON           : 11,\n\t    T_COMMA           : 12,\n\t    T_SEMI            : 13,\n\t    T_PLUS            : 14,\n\t    T_MINUS           : 15,\n\t    T_STAR            : 16,\n\t    T_SLASH           : 17,\n\t    T_VBAR            : 18,\n\t    T_AMPER           : 19,\n\t    T_LESS            : 20,\n\t    T_GREATER         : 21,\n\t    T_EQUAL           : 22,\n\t    T_DOT             : 23,\n\t    T_PERCENT         : 24,\n\t    T_BACKQUOTE       : 25,\n\t    T_LBRACE          : 26,\n\t    T_RBRACE          : 27,\n\t    T_EQEQUAL         : 28,\n\t    T_NOTEQUAL        : 29,\n\t    T_LESSEQUAL       : 30,\n\t    T_GREATEREQUAL    : 31,\n\t    T_TILDE           : 32,\n\t    T_CIRCUMFLEX      : 33,\n\t    T_LEFTSHIFT       : 34,\n\t    T_RIGHTSHIFT      : 35,\n\t    T_DOUBLESTAR      : 36,\n\t    T_PLUSEQUAL       : 37,\n\t    T_MINEQUAL        : 38,\n\t    T_STAREQUAL       : 39,\n\t    T_SLASHEQUAL      : 40,\n\t    T_PERCENTEQUAL    : 41,\n\t    T_AMPEREQUAL      : 42,\n\t    T_VBAREQUAL       : 43,\n\t    T_CIRCUMFLEXEQUAL : 44,\n\t    T_LEFTSHIFTEQUAL  : 45,\n\t    T_RIGHTSHIFTEQUAL : 46,\n\t    T_DOUBLESTAREQUAL : 47,\n\t    T_DOUBLESLASH     : 48,\n\t    T_DOUBLESLASHEQUAL: 49,\n\t    T_AT              : 50,\n\t    T_OP              : 51,\n\t    T_COMMENT         : 52,\n\t    T_NL              : 53,\n\t    T_RARROW          : 54,\n\t    T_ERRORTOKEN      : 55,\n\t    T_N_TOKENS        : 56,\n\t    T_NT_OFFSET       : 256\n\t};\n\n\t/** @param {...*} x */\n\tfunction group (x) {\n\t    var args = Array.prototype.slice.call(arguments);\n\t    return \"(\" + args.join(\"|\") + \")\";\n\t}\n\n\t/** @param {...*} x */\n\tfunction any (x) {\n\t    return group.apply(null, arguments) + \"*\";\n\t}\n\n\t/** @param {...*} x */\n\tfunction maybe (x) {\n\t    return group.apply(null, arguments) + \"?\";\n\t}\n\n\t/* we have to use string and ctor to be able to build patterns up. + on /.../\n\t * does something strange. */\n\tvar Whitespace = \"[ \\\\f\\\\t]*\";\n\tvar Comment_ = \"#[^\\\\r\\\\n]*\";\n\tvar Ident = \"[a-zA-Z_]\\\\w*\";\n\n\tvar Binnumber = \"0[bB][01]*\";\n\tvar Hexnumber = \"0[xX][\\\\da-fA-F]*[lL]?\";\n\tvar Octnumber = \"0[oO]?[0-7]*[lL]?\";\n\tvar Decnumber = \"[1-9]\\\\d*[lL]?\";\n\tvar Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber);\n\n\tvar Exponent = \"[eE][-+]?\\\\d+\";\n\tvar Pointfloat = group(\"\\\\d+\\\\.\\\\d*\", \"\\\\.\\\\d+\") + maybe(Exponent);\n\tvar Expfloat = \"\\\\d+\" + Exponent;\n\tvar Floatnumber = group(Pointfloat, Expfloat);\n\tvar Imagnumber = group(\"\\\\d+[jJ]\", Floatnumber + \"[jJ]\");\n\tvar Number_ = group(Imagnumber, Floatnumber, Intnumber);\n\n\t// tail end of ' string\n\tvar Single = \"^[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*'\";\n\t// tail end of \" string\n\tvar Double_ = '^[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*\"';\n\t// tail end of ''' string\n\tvar Single3 = \"[^'\\\\\\\\]*(?:(?:\\\\\\\\.|'(?!''))[^'\\\\\\\\]*)*'''\";\n\t// tail end of \"\"\" string\n\tvar Double3 = '[^\"\\\\\\\\]*(?:(?:\\\\\\\\.|\"(?!\"\"))[^\"\\\\\\\\]*)*\"\"\"';\n\tvar Triple = group(\"[ubUB]?[rR]?'''\", '[ubUB]?[rR]?\"\"\"');\n\tvar String_ = group(\"[uU]?[rR]?'[^\\\\n'\\\\\\\\]*(?:\\\\\\\\.[^\\\\n'\\\\\\\\]*)*'\",\n\t    '[uU]?[rR]?\"[^\\\\n\"\\\\\\\\]*(?:\\\\\\\\.[^\\\\n\"\\\\\\\\]*)*\"');\n\n\t// Because of leftmost-then-longest match semantics, be sure to put the\n\t// longest operators first (e.g., if = came before ==, == would get\n\t// recognized as two instances of =).\n\tvar Operator = group(\"\\\\*\\\\*=?\", \">>=?\", \"<<=?\", \"<>\", \"!=\",\n\t    \"//=?\", \"->\",\n\t    \"[+\\\\-*/%&|^=<>]=?\",\n\t    \"~\");\n\n\tvar Bracket = \"[\\\\][(){}]\";\n\tvar Special = group(\"\\\\r?\\\\n\", \"[:;.,`@]\");\n\tvar Funny = group(Operator, Bracket, Special);\n\n\tvar ContStr = group(\"[uUbB]?[rR]?'[^\\\\n'\\\\\\\\]*(?:\\\\\\\\.[^\\\\n'\\\\\\\\]*)*\" +\n\t        group(\"'\", \"\\\\\\\\\\\\r?\\\\n\"),\n\t        \"[uUbB]?[rR]?\\\"[^\\\\n\\\"\\\\\\\\]*(?:\\\\\\\\.[^\\\\n\\\"\\\\\\\\]*)*\" +\n\t        group(\"\\\"\", \"\\\\\\\\\\\\r?\\\\n\"));\n\tvar PseudoExtras = group(\"\\\\\\\\\\\\r?\\\\n\", Comment_, Triple);\n\t// Need to prefix with \"^\" as we only want to match what's next\n\tvar PseudoToken = \"^\" + group(PseudoExtras, Number_, Funny, ContStr, Ident);\n\n\n\tvar triple_quoted = {\n\t    \"'''\"  : true, '\"\"\"': true,\n\t    \"r'''\" : true, 'r\"\"\"': true, \"R'''\": true, 'R\"\"\"': true,\n\t    \"u'''\" : true, 'u\"\"\"': true, \"U'''\": true, 'U\"\"\"': true,\n\t    \"b'''\" : true, 'b\"\"\"': true, \"B'''\": true, 'B\"\"\"': true,\n\t    \"ur'''\": true, 'ur\"\"\"': true, \"Ur'''\": true, 'Ur\"\"\"': true,\n\t    \"uR'''\": true, 'uR\"\"\"': true, \"UR'''\": true, 'UR\"\"\"': true,\n\t    \"br'''\": true, 'br\"\"\"': true, \"Br'''\": true, 'Br\"\"\"': true,\n\t    \"bR'''\": true, 'bR\"\"\"': true, \"BR'''\": true, 'BR\"\"\"': true\n\t};\n\n\tvar single_quoted = {\n\t    \"'\"  : true, '\"': true,\n\t    \"r'\" : true, 'r\"': true, \"R'\": true, 'R\"': true,\n\t    \"u'\" : true, 'u\"': true, \"U'\": true, 'U\"': true,\n\t    \"b'\" : true, 'b\"': true, \"B'\": true, 'B\"': true,\n\t    \"ur'\": true, 'ur\"': true, \"Ur'\": true, 'Ur\"': true,\n\t    \"uR'\": true, 'uR\"': true, \"UR'\": true, 'UR\"': true,\n\t    \"br'\": true, 'br\"': true, \"Br'\": true, 'Br\"': true,\n\t    \"bR'\": true, 'bR\"': true, \"BR'\": true, 'BR\"': true\n\t};\n\n\t// hack to make closure keep those objects. not sure what a better way is.\n\t(function () {\n\t    var k;\n\t    for (k in triple_quoted) {\n\t    }\n\t    for (k in single_quoted) {\n\t    }\n\t}());\n\n\n\tvar tabsize = 8;\n\n\tfunction contains (a, obj) {\n\t    var i = a.length;\n\t    while (i--) {\n\t        if (a[i] === obj) {\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\n\tfunction rstrip (input, what) {\n\t    var i;\n\t    for (i = input.length; i > 0; --i) {\n\t        if (what.indexOf(input.charAt(i - 1)) === -1) {\n\t            break;\n\t        }\n\t    }\n\t    return input.substring(0, i);\n\t}\n\n\tSk.Tokenizer.prototype.generateTokens = function (line) {\n\t    var nl_pos;\n\t    var newl;\n\t    var initial;\n\t    var token;\n\t    var epos;\n\t    var spos;\n\t    var start;\n\t    var pseudomatch;\n\t    var capos;\n\t    var comment_token;\n\t    var endmatch, pos, column, end, max;\n\n\n\t    // bnm - Move these definitions in this function otherwise test state is preserved between\n\t    // calls on single3prog and double3prog causing weird errors with having multiple instances\n\t    // of triple quoted strings in the same program.\n\n\t    var pseudoprog = new RegExp(PseudoToken);\n\t    var single3prog = new RegExp(Single3, \"g\");\n\t    var double3prog = new RegExp(Double3, \"g\");\n\n\t    var endprogs = {     \"'\": new RegExp(Single, \"g\"), \"\\\"\": new RegExp(Double_, \"g\"),\n\t        \"'''\"               : single3prog, '\"\"\"': double3prog,\n\t        \"r'''\"              : single3prog, 'r\"\"\"': double3prog,\n\t        \"u'''\"              : single3prog, 'u\"\"\"': double3prog,\n\t        \"b'''\"              : single3prog, 'b\"\"\"': double3prog,\n\t        \"ur'''\"             : single3prog, 'ur\"\"\"': double3prog,\n\t        \"br'''\"             : single3prog, 'br\"\"\"': double3prog,\n\t        \"R'''\"              : single3prog, 'R\"\"\"': double3prog,\n\t        \"U'''\"              : single3prog, 'U\"\"\"': double3prog,\n\t        \"B'''\"              : single3prog, 'B\"\"\"': double3prog,\n\t        \"uR'''\"             : single3prog, 'uR\"\"\"': double3prog,\n\t        \"Ur'''\"             : single3prog, 'Ur\"\"\"': double3prog,\n\t        \"UR'''\"             : single3prog, 'UR\"\"\"': double3prog,\n\t        \"bR'''\"             : single3prog, 'bR\"\"\"': double3prog,\n\t        \"Br'''\"             : single3prog, 'Br\"\"\"': double3prog,\n\t        \"BR'''\"             : single3prog, 'BR\"\"\"': double3prog,\n\t        'r'                 : null, 'R': null,\n\t        'u'                 : null, 'U': null,\n\t        'b'                 : null, 'B': null\n\t    };\n\n\n\t    if (!line) {\n\t        line = '';\n\t    }\n\t    //print(\"LINE:'\"+line+\"'\");\n\n\t    this.lnum += 1;\n\t    pos = 0;\n\t    max = line.length;\n\n\t    if (this.contstr.length > 0) {\n\t        if (!line) {\n\t            throw new Sk.builtin.SyntaxError(\"EOF in multi-line string\", this.filename, this.strstart[0], this.strstart[1], {\n\t                kind: \"STRING_EOF\",\n\t                line: this.contline\n\t            });\n\t        }\n\t        this.endprog.lastIndex = 0;\n\t        endmatch = this.endprog.test(line);\n\t        if (endmatch) {\n\t            pos = end = this.endprog.lastIndex;\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_STRING, this.contstr + line.substring(0, end),\n\t                this.strstart, [this.lnum, end], this.contline + line)) {\n\t                return 'done';\n\t            }\n\t            this.contstr = '';\n\t            this.needcont = false;\n\t            this.contline = undefined;\n\t        }\n\t        else if (this.needcont && line.substring(line.length - 2) !== \"\\\\\\n\" && line.substring(line.length - 3) !== \"\\\\\\r\\n\") {\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, this.contstr + line,\n\t                this.strstart, [this.lnum, line.length], this.contline)) {\n\t                return 'done';\n\t            }\n\t            this.contstr = '';\n\t            this.contline = undefined;\n\t            return false;\n\t        }\n\t        else {\n\t            this.contstr += line;\n\t            this.contline = this.contline + line;\n\t            return false;\n\t        }\n\t    }\n\t    else if (this.parenlev === 0 && !this.continued) {\n\t        if (!line) {\n\t            return this.doneFunc();\n\t        }\n\t        column = 0;\n\t        while (pos < max) {\n\t            if (line.charAt(pos) === ' ') {\n\t                column += 1;\n\t            }\n\t            else if (line.charAt(pos) === '\\t') {\n\t                column = (column / tabsize + 1) * tabsize;\n\t            }\n\t            else if (line.charAt(pos) === '\\f') {\n\t                column = 0;\n\t            }\n\t            else {\n\t                break;\n\t            }\n\t            pos = pos + 1;\n\t        }\n\t        if (pos === max) {\n\t            return this.doneFunc();\n\t        }\n\n\t        if (\"#\\r\\n\".indexOf(line.charAt(pos)) !== -1) // skip comments or blank lines\n\t        {\n\t            if (line.charAt(pos) === '#') {\n\t                comment_token = rstrip(line.substring(pos), '\\r\\n');\n\t                nl_pos = pos + comment_token.length;\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_COMMENT, comment_token,\n\t                    [this.lnum, pos], [this.lnum, pos + comment_token.length], line)) {\n\t                    return 'done';\n\t                }\n\t                //print(\"HERE:1\");\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_NL, line.substring(nl_pos),\n\t                    [this.lnum, nl_pos], [this.lnum, line.length], line)) {\n\t                    return 'done';\n\t                }\n\t                return false;\n\t            }\n\t            else {\n\t                //print(\"HERE:2\");\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_NL, line.substring(pos),\n\t                    [this.lnum, pos], [this.lnum, line.length], line)) {\n\t                    return 'done';\n\t                }\n\t                if (!this.interactive) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\n\t        if (column > this.indents[this.indents.length - 1]) // count indents or dedents\n\t        {\n\t            this.indents.push(column);\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_INDENT, line.substring(0, pos), [this.lnum, 0], [this.lnum, pos], line)) {\n\t                return 'done';\n\t            }\n\t        }\n\t        while (column < this.indents[this.indents.length - 1]) {\n\t            if (!contains(this.indents, column)) {\n\t                throw new Sk.builtin.IndentationError(\"unindent does not match any outer indentation level\",\n\t                    this.filename, this.lnum, pos, line);\n\t            }\n\t            this.indents.splice(this.indents.length - 1, 1);\n\t            //print(\"dedent here\");\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, '', [this.lnum, pos], [this.lnum, pos], line)) {\n\t                return 'done';\n\t            }\n\t        }\n\t    }\n\t    else // continued statement\n\t    {\n\t        if (!line) {\n\t            throw new Sk.builtin.SyntaxError(\"EOF in multi-line statement\", this.filename, this.lnum, 0, {\n\t                kind: 'STATEMENT_EOF',\n\t                parenlev: this.parenlev,\n\t                parenstack: this.parenstack\n\t            });\n\t        }\n\t        this.continued = false;\n\t    }\n\n\t    while (pos < max) {\n\t        //print(\"pos:\"+pos+\":\"+max);\n\t        // js regexes don't return any info about matches, other than the\n\t        // content. we'd like to put a \\w+ before pseudomatch, but then we\n\t        // can't get any data\n\t        capos = line.charAt(pos);\n\t        while (capos === ' ' || capos === '\\f' || capos === '\\t') {\n\t            pos += 1;\n\t            capos = line.charAt(pos);\n\t        }\n\t        pseudoprog.lastIndex = 0;\n\t        pseudomatch = pseudoprog.exec(line.substring(pos));\n\t        if (pseudomatch) {\n\t            start = pos;\n\t            end = start + pseudomatch[1].length;\n\t            spos = [this.lnum, start];\n\t            epos = [this.lnum, end];\n\t            pos = end;\n\t            token = line.substring(start, end);\n\t            initial = line.charAt(start);\n\t            //Sk.debugout(\"token:\",token, \"initial:\",initial, start, end);\n\t            if (this.numchars.indexOf(initial) !== -1 || (initial === '.' && token !== '.')) {\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_NUMBER, token, spos, epos, line)) {\n\t                    return 'done';\n\t                }\n\t            }\n\t            else if (initial === '\\r' || initial === '\\n') {\n\t                newl = Sk.Tokenizer.Tokens.T_NEWLINE;\n\t                //print(\"HERE:3\");\n\t                if (this.parenlev > 0) {\n\t                    newl = Sk.Tokenizer.Tokens.T_NL;\n\t                }\n\t                if (this.callback(newl, token, spos, epos, line)) {\n\t                    return 'done';\n\t                }\n\t            }\n\t            else if (initial === '#') {\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_COMMENT, token, spos, epos, line)) {\n\t                    return 'done';\n\t                }\n\t            }\n\t            else if (triple_quoted.hasOwnProperty(token)) {\n\t                this.endprog = endprogs[token];\n\t                this.endprog.lastIndex = 0;\n\t                endmatch = this.endprog.test(line.substring(pos));\n\t                if (endmatch) {\n\t                    pos = this.endprog.lastIndex + pos;\n\t                    token = line.substring(start, pos);\n\t                    if (this.callback(Sk.Tokenizer.Tokens.T_STRING, token, spos, [this.lnum, pos], line)) {\n\t                        return 'done';\n\t                    }\n\t                }\n\t                else {\n\t                    this.strstart = [this.lnum, start];\n\t                    this.contstr = line.substring(start);\n\t                    this.contline = line;\n\t                    return false;\n\t                }\n\t            }\n\t            else if (single_quoted.hasOwnProperty(initial) ||\n\t                single_quoted.hasOwnProperty(token.substring(0, 2)) ||\n\t                single_quoted.hasOwnProperty(token.substring(0, 3))) {\n\t                if (token[token.length - 1] === '\\n') {\n\t                    this.strstart = [this.lnum, start];\n\t                    this.endprog = endprogs[initial] || endprogs[token[1]] || endprogs[token[2]];\n\t                    this.contstr = line.substring(start);\n\t                    this.needcont = true;\n\t                    this.contline = line;\n\t                    //print(\"i, t1, t2\", initial, token[1], token[2]);\n\t                    //print(\"ep, cs\", this.endprog, this.contstr);\n\t                    return false;\n\t                }\n\t                else {\n\t                    if (this.callback(Sk.Tokenizer.Tokens.T_STRING, token, spos, epos, line)) {\n\t                        return 'done';\n\t                    }\n\t                }\n\t            }\n\t            else if (this.namechars.indexOf(initial) !== -1) {\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_NAME, token, spos, epos, line)) {\n\t                    return 'done';\n\t                }\n\t            }\n\t            else if (initial === '\\\\') {\n\t                //print(\"HERE:4\");\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_NL, token, spos, [this.lnum, pos], line)) {\n\t                    return 'done';\n\t                }\n\t                this.continued = true;\n\t            }\n\t            else {\n\t                if ('([{'.indexOf(initial) !== -1) {\n\t                    this.parenlev += 1;\n\t                    this.parenstack.push([initial, this.lnum, pos]);\n\t                }\n\t                else if (')]}'.indexOf(initial) !== -1) {\n\t                    this.parenlev -= 1;\n\t                    this.parenstack.pop();\n\t                }\n\t                if (this.callback(Sk.Tokenizer.Tokens.T_OP, token, spos, epos, line)) {\n\t                    return 'done';\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, line.charAt(pos),\n\t                [this.lnum, pos], [this.lnum, pos + 1], line)) {\n\t                return 'done';\n\t            }\n\t            pos += 1;\n\t        }\n\t    }\n\n\t    return false;\n\t};\n\n\tSk.Tokenizer.tokenNames = {\n\t    0  : 'T_ENDMARKER', 1: 'T_NAME', 2: 'T_NUMBER', 3: 'T_STRING', 4: 'T_NEWLINE',\n\t    5  : 'T_INDENT', 6: 'T_DEDENT', 7: 'T_LPAR', 8: 'T_RPAR', 9: 'T_LSQB',\n\t    10 : 'T_RSQB', 11: 'T_COLON', 12: 'T_COMMA', 13: 'T_SEMI', 14: 'T_PLUS',\n\t    15 : 'T_MINUS', 16: 'T_STAR', 17: 'T_SLASH', 18: 'T_VBAR', 19: 'T_AMPER',\n\t    20 : 'T_LESS', 21: 'T_GREATER', 22: 'T_EQUAL', 23: 'T_DOT', 24: 'T_PERCENT',\n\t    25 : 'T_BACKQUOTE', 26: 'T_LBRACE', 27: 'T_RBRACE', 28: 'T_EQEQUAL', 29: 'T_NOTEQUAL',\n\t    30 : 'T_LESSEQUAL', 31: 'T_GREATEREQUAL', 32: 'T_TILDE', 33: 'T_CIRCUMFLEX', 34: 'T_LEFTSHIFT',\n\t    35 : 'T_RIGHTSHIFT', 36: 'T_DOUBLESTAR', 37: 'T_PLUSEQUAL', 38: 'T_MINEQUAL', 39: 'T_STAREQUAL',\n\t    40 : 'T_SLASHEQUAL', 41: 'T_PERCENTEQUAL', 42: 'T_AMPEREQUAL', 43: 'T_VBAREQUAL', 44: 'T_CIRCUMFLEXEQUAL',\n\t    45 : 'T_LEFTSHIFTEQUAL', 46: 'T_RIGHTSHIFTEQUAL', 47: 'T_DOUBLESTAREQUAL', 48: 'T_DOUBLESLASH', 49: 'T_DOUBLESLASHEQUAL',\n\t    50 : 'T_AT', 51: 'T_OP', 52: 'T_COMMENT', 53: 'T_NL', 54: 'T_RARROW',\n\t    55 : 'T_ERRORTOKEN', 56: 'T_N_TOKENS',\n\t    256: 'T_NT_OFFSET'\n\t};\n\n\tgoog.exportSymbol(\"Sk.Tokenizer\", Sk.Tokenizer);\n\tgoog.exportSymbol(\"Sk.Tokenizer.prototype.generateTokens\", Sk.Tokenizer.prototype.generateTokens);\n\tgoog.exportSymbol(\"Sk.Tokenizer.tokenNames\", Sk.Tokenizer.tokenNames);\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/gen/parse_tables.js ---- */ \n\n\t// generated by pgen/main.py\n\tSk.OpMap = {\n\t\"(\": Sk.Tokenizer.Tokens.T_LPAR,\n\t\")\": Sk.Tokenizer.Tokens.T_RPAR,\n\t\"[\": Sk.Tokenizer.Tokens.T_LSQB,\n\t\"]\": Sk.Tokenizer.Tokens.T_RSQB,\n\t\":\": Sk.Tokenizer.Tokens.T_COLON,\n\t\",\": Sk.Tokenizer.Tokens.T_COMMA,\n\t\";\": Sk.Tokenizer.Tokens.T_SEMI,\n\t\"+\": Sk.Tokenizer.Tokens.T_PLUS,\n\t\"-\": Sk.Tokenizer.Tokens.T_MINUS,\n\t\"*\": Sk.Tokenizer.Tokens.T_STAR,\n\t\"/\": Sk.Tokenizer.Tokens.T_SLASH,\n\t\"|\": Sk.Tokenizer.Tokens.T_VBAR,\n\t\"&\": Sk.Tokenizer.Tokens.T_AMPER,\n\t\"<\": Sk.Tokenizer.Tokens.T_LESS,\n\t\">\": Sk.Tokenizer.Tokens.T_GREATER,\n\t\"=\": Sk.Tokenizer.Tokens.T_EQUAL,\n\t\".\": Sk.Tokenizer.Tokens.T_DOT,\n\t\"%\": Sk.Tokenizer.Tokens.T_PERCENT,\n\t\"`\": Sk.Tokenizer.Tokens.T_BACKQUOTE,\n\t\"{\": Sk.Tokenizer.Tokens.T_LBRACE,\n\t\"}\": Sk.Tokenizer.Tokens.T_RBRACE,\n\t\"@\": Sk.Tokenizer.Tokens.T_AT,\n\t\"==\": Sk.Tokenizer.Tokens.T_EQEQUAL,\n\t\"!=\": Sk.Tokenizer.Tokens.T_NOTEQUAL,\n\t\"<>\": Sk.Tokenizer.Tokens.T_NOTEQUAL,\n\t\"<=\": Sk.Tokenizer.Tokens.T_LESSEQUAL,\n\t\">=\": Sk.Tokenizer.Tokens.T_GREATEREQUAL,\n\t\"~\": Sk.Tokenizer.Tokens.T_TILDE,\n\t\"^\": Sk.Tokenizer.Tokens.T_CIRCUMFLEX,\n\t\"<<\": Sk.Tokenizer.Tokens.T_LEFTSHIFT,\n\t\">>\": Sk.Tokenizer.Tokens.T_RIGHTSHIFT,\n\t\"**\": Sk.Tokenizer.Tokens.T_DOUBLESTAR,\n\t\"+=\": Sk.Tokenizer.Tokens.T_PLUSEQUAL,\n\t\"-=\": Sk.Tokenizer.Tokens.T_MINEQUAL,\n\t\"*=\": Sk.Tokenizer.Tokens.T_STAREQUAL,\n\t\"/=\": Sk.Tokenizer.Tokens.T_SLASHEQUAL,\n\t\"%=\": Sk.Tokenizer.Tokens.T_PERCENTEQUAL,\n\t\"&=\": Sk.Tokenizer.Tokens.T_AMPEREQUAL,\n\t\"|=\": Sk.Tokenizer.Tokens.T_VBAREQUAL,\n\t\"^=\": Sk.Tokenizer.Tokens.T_CIRCUMFLEXEQUAL,\n\t\"<<=\": Sk.Tokenizer.Tokens.T_LEFTSHIFTEQUAL,\n\t\">>=\": Sk.Tokenizer.Tokens.T_RIGHTSHIFTEQUAL,\n\t\"**=\": Sk.Tokenizer.Tokens.T_DOUBLESTAREQUAL,\n\t\"//\": Sk.Tokenizer.Tokens.T_DOUBLESLASH,\n\t\"//=\": Sk.Tokenizer.Tokens.T_DOUBLESLASHEQUAL,\n\t\"->\": Sk.Tokenizer.Tokens.T_RARROW\n\t};\n\tSk.ParseTables = {\n\tsym:\n\t{and_expr: 257,\n\t and_test: 258,\n\t arglist: 259,\n\t argument: 260,\n\t arith_expr: 261,\n\t assert_stmt: 262,\n\t atom: 263,\n\t augassign: 264,\n\t break_stmt: 265,\n\t classdef: 266,\n\t comp_for: 267,\n\t comp_if: 268,\n\t comp_iter: 269,\n\t comp_op: 270,\n\t comparison: 271,\n\t compound_stmt: 272,\n\t continue_stmt: 273,\n\t debugger_stmt: 274,\n\t decorated: 275,\n\t decorator: 276,\n\t decorators: 277,\n\t del_stmt: 278,\n\t dictorsetmaker: 279,\n\t dotted_as_name: 280,\n\t dotted_as_names: 281,\n\t dotted_name: 282,\n\t encoding_decl: 283,\n\t eval_input: 284,\n\t except_clause: 285,\n\t exec_stmt: 286,\n\t expr: 287,\n\t expr_stmt: 288,\n\t exprlist: 289,\n\t factor: 290,\n\t file_input: 291,\n\t flow_stmt: 292,\n\t for_stmt: 293,\n\t fpdef: 294,\n\t fplist: 295,\n\t funcdef: 296,\n\t global_stmt: 297,\n\t if_stmt: 298,\n\t import_as_name: 299,\n\t import_as_names: 300,\n\t import_from: 301,\n\t import_name: 302,\n\t import_stmt: 303,\n\t lambdef: 304,\n\t list_for: 305,\n\t list_if: 306,\n\t list_iter: 307,\n\t listmaker: 308,\n\t not_test: 309,\n\t old_lambdef: 310,\n\t old_test: 311,\n\t or_test: 312,\n\t parameters: 313,\n\t pass_stmt: 314,\n\t power: 315,\n\t print_stmt: 316,\n\t raise_stmt: 317,\n\t return_stmt: 318,\n\t shift_expr: 319,\n\t simple_stmt: 320,\n\t single_input: 256,\n\t sliceop: 321,\n\t small_stmt: 322,\n\t stmt: 323,\n\t subscript: 324,\n\t subscriptlist: 325,\n\t suite: 326,\n\t term: 327,\n\t test: 328,\n\t testlist: 329,\n\t testlist1: 330,\n\t testlist_comp: 331,\n\t testlist_safe: 332,\n\t trailer: 333,\n\t try_stmt: 334,\n\t varargslist: 335,\n\t while_stmt: 336,\n\t with_item: 337,\n\t with_stmt: 338,\n\t xor_expr: 339,\n\t yield_expr: 340,\n\t yield_stmt: 341},\n\tnumber2symbol:\n\t{256: 'single_input',\n\t 257: 'and_expr',\n\t 258: 'and_test',\n\t 259: 'arglist',\n\t 260: 'argument',\n\t 261: 'arith_expr',\n\t 262: 'assert_stmt',\n\t 263: 'atom',\n\t 264: 'augassign',\n\t 265: 'break_stmt',\n\t 266: 'classdef',\n\t 267: 'comp_for',\n\t 268: 'comp_if',\n\t 269: 'comp_iter',\n\t 270: 'comp_op',\n\t 271: 'comparison',\n\t 272: 'compound_stmt',\n\t 273: 'continue_stmt',\n\t 274: 'debugger_stmt',\n\t 275: 'decorated',\n\t 276: 'decorator',\n\t 277: 'decorators',\n\t 278: 'del_stmt',\n\t 279: 'dictorsetmaker',\n\t 280: 'dotted_as_name',\n\t 281: 'dotted_as_names',\n\t 282: 'dotted_name',\n\t 283: 'encoding_decl',\n\t 284: 'eval_input',\n\t 285: 'except_clause',\n\t 286: 'exec_stmt',\n\t 287: 'expr',\n\t 288: 'expr_stmt',\n\t 289: 'exprlist',\n\t 290: 'factor',\n\t 291: 'file_input',\n\t 292: 'flow_stmt',\n\t 293: 'for_stmt',\n\t 294: 'fpdef',\n\t 295: 'fplist',\n\t 296: 'funcdef',\n\t 297: 'global_stmt',\n\t 298: 'if_stmt',\n\t 299: 'import_as_name',\n\t 300: 'import_as_names',\n\t 301: 'import_from',\n\t 302: 'import_name',\n\t 303: 'import_stmt',\n\t 304: 'lambdef',\n\t 305: 'list_for',\n\t 306: 'list_if',\n\t 307: 'list_iter',\n\t 308: 'listmaker',\n\t 309: 'not_test',\n\t 310: 'old_lambdef',\n\t 311: 'old_test',\n\t 312: 'or_test',\n\t 313: 'parameters',\n\t 314: 'pass_stmt',\n\t 315: 'power',\n\t 316: 'print_stmt',\n\t 317: 'raise_stmt',\n\t 318: 'return_stmt',\n\t 319: 'shift_expr',\n\t 320: 'simple_stmt',\n\t 321: 'sliceop',\n\t 322: 'small_stmt',\n\t 323: 'stmt',\n\t 324: 'subscript',\n\t 325: 'subscriptlist',\n\t 326: 'suite',\n\t 327: 'term',\n\t 328: 'test',\n\t 329: 'testlist',\n\t 330: 'testlist1',\n\t 331: 'testlist_comp',\n\t 332: 'testlist_safe',\n\t 333: 'trailer',\n\t 334: 'try_stmt',\n\t 335: 'varargslist',\n\t 336: 'while_stmt',\n\t 337: 'with_item',\n\t 338: 'with_stmt',\n\t 339: 'xor_expr',\n\t 340: 'yield_expr',\n\t 341: 'yield_stmt'},\n\tdfas:\n\t{256: [[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]],\n\t       {2: 1,\n\t        4: 1,\n\t        5: 1,\n\t        6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        10: 1,\n\t        11: 1,\n\t        12: 1,\n\t        13: 1,\n\t        14: 1,\n\t        15: 1,\n\t        16: 1,\n\t        17: 1,\n\t        18: 1,\n\t        19: 1,\n\t        20: 1,\n\t        21: 1,\n\t        22: 1,\n\t        23: 1,\n\t        24: 1,\n\t        25: 1,\n\t        26: 1,\n\t        27: 1,\n\t        28: 1,\n\t        29: 1,\n\t        30: 1,\n\t        31: 1,\n\t        32: 1,\n\t        33: 1,\n\t        34: 1,\n\t        35: 1,\n\t        36: 1,\n\t        37: 1}],\n\t 257: [[[[38, 1]], [[39, 0], [0, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 258: [[[[40, 1]], [[41, 0], [0, 1]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 259: [[[[42, 1], [43, 2], [44, 3]],\n\t        [[45, 4]],\n\t        [[46, 5], [0, 2]],\n\t        [[45, 6]],\n\t        [[46, 7], [0, 4]],\n\t        [[42, 1], [43, 2], [44, 3], [0, 5]],\n\t        [[0, 6]],\n\t        [[43, 4], [44, 3]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1,\n\t        42: 1,\n\t        44: 1}],\n\t 260: [[[[45, 1]], [[47, 2], [48, 3], [0, 1]], [[45, 3]], [[0, 3]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 261: [[[[49, 1]], [[26, 0], [37, 0], [0, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 262: [[[[21, 1]], [[45, 2]], [[46, 3], [0, 2]], [[45, 4]], [[0, 4]]],\n\t       {21: 1}],\n\t 263: [[[[19, 1], [8, 2], [9, 5], [30, 4], [14, 3], [15, 6], [22, 2]],\n\t        [[19, 1], [0, 1]],\n\t        [[0, 2]],\n\t        [[50, 7], [51, 2]],\n\t        [[52, 2], [53, 8], [54, 8]],\n\t        [[55, 2], [56, 9]],\n\t        [[57, 10]],\n\t        [[51, 2]],\n\t        [[52, 2]],\n\t        [[55, 2]],\n\t        [[15, 2]]],\n\t       {8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 30: 1}],\n\t 264: [[[[58, 1],\n\t         [59, 1],\n\t         [60, 1],\n\t         [61, 1],\n\t         [62, 1],\n\t         [63, 1],\n\t         [64, 1],\n\t         [65, 1],\n\t         [66, 1],\n\t         [67, 1],\n\t         [68, 1],\n\t         [69, 1]],\n\t        [[0, 1]]],\n\t       {58: 1,\n\t        59: 1,\n\t        60: 1,\n\t        61: 1,\n\t        62: 1,\n\t        63: 1,\n\t        64: 1,\n\t        65: 1,\n\t        66: 1,\n\t        67: 1,\n\t        68: 1,\n\t        69: 1}],\n\t 265: [[[[33, 1]], [[0, 1]]], {33: 1}],\n\t 266: [[[[10, 1]],\n\t        [[22, 2]],\n\t        [[70, 3], [30, 4]],\n\t        [[71, 5]],\n\t        [[52, 6], [72, 7]],\n\t        [[0, 5]],\n\t        [[70, 3]],\n\t        [[52, 6]]],\n\t       {10: 1}],\n\t 267: [[[[29, 1]],\n\t        [[73, 2]],\n\t        [[74, 3]],\n\t        [[75, 4]],\n\t        [[76, 5], [0, 4]],\n\t        [[0, 5]]],\n\t       {29: 1}],\n\t 268: [[[[32, 1]], [[77, 2]], [[76, 3], [0, 2]], [[0, 3]]], {32: 1}],\n\t 269: [[[[78, 1], [48, 1]], [[0, 1]]], {29: 1, 32: 1}],\n\t 270: [[[[79, 1],\n\t         [80, 1],\n\t         [7, 2],\n\t         [81, 1],\n\t         [79, 1],\n\t         [74, 1],\n\t         [82, 1],\n\t         [83, 3],\n\t         [84, 1],\n\t         [85, 1]],\n\t        [[0, 1]],\n\t        [[74, 1]],\n\t        [[7, 1], [0, 3]]],\n\t       {7: 1, 74: 1, 79: 1, 80: 1, 81: 1, 82: 1, 83: 1, 84: 1, 85: 1}],\n\t 271: [[[[86, 1]], [[87, 0], [0, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 272: [[[[88, 1],\n\t         [89, 1],\n\t         [90, 1],\n\t         [91, 1],\n\t         [92, 1],\n\t         [93, 1],\n\t         [94, 1],\n\t         [95, 1]],\n\t        [[0, 1]]],\n\t       {4: 1, 10: 1, 16: 1, 18: 1, 29: 1, 32: 1, 35: 1, 36: 1}],\n\t 273: [[[[34, 1]], [[0, 1]]], {34: 1}],\n\t 274: [[[[13, 1]], [[0, 1]]], {13: 1}],\n\t 275: [[[[96, 1]], [[94, 2], [91, 2]], [[0, 2]]], {35: 1}],\n\t 276: [[[[35, 1]],\n\t        [[97, 2]],\n\t        [[2, 4], [30, 3]],\n\t        [[52, 5], [98, 6]],\n\t        [[0, 4]],\n\t        [[2, 4]],\n\t        [[52, 5]]],\n\t       {35: 1}],\n\t 277: [[[[99, 1]], [[99, 1], [0, 1]]], {35: 1}],\n\t 278: [[[[23, 1]], [[73, 2]], [[0, 2]]], {23: 1}],\n\t 279: [[[[45, 1]],\n\t        [[70, 2], [48, 3], [46, 4], [0, 1]],\n\t        [[45, 5]],\n\t        [[0, 3]],\n\t        [[45, 6], [0, 4]],\n\t        [[48, 3], [46, 7], [0, 5]],\n\t        [[46, 4], [0, 6]],\n\t        [[45, 8], [0, 7]],\n\t        [[70, 9]],\n\t        [[45, 10]],\n\t        [[46, 7], [0, 10]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 280: [[[[97, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]], {22: 1}],\n\t 281: [[[[101, 1]], [[46, 0], [0, 1]]], {22: 1}],\n\t 282: [[[[22, 1]], [[102, 0], [0, 1]]], {22: 1}],\n\t 283: [[[[22, 1]], [[0, 1]]], {22: 1}],\n\t 284: [[[[72, 1]], [[2, 1], [103, 2]], [[0, 2]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 285: [[[[104, 1]],\n\t        [[45, 2], [0, 1]],\n\t        [[100, 3], [46, 3], [0, 2]],\n\t        [[45, 4]],\n\t        [[0, 4]]],\n\t       {104: 1}],\n\t 286: [[[[17, 1]],\n\t        [[86, 2]],\n\t        [[74, 3], [0, 2]],\n\t        [[45, 4]],\n\t        [[46, 5], [0, 4]],\n\t        [[45, 6]],\n\t        [[0, 6]]],\n\t       {17: 1}],\n\t 287: [[[[105, 1]], [[106, 0], [0, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 288: [[[[72, 1]],\n\t        [[107, 2], [47, 3], [0, 1]],\n\t        [[72, 4], [53, 4]],\n\t        [[72, 5], [53, 5]],\n\t        [[0, 4]],\n\t        [[47, 3], [0, 5]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 289: [[[[86, 1]], [[46, 2], [0, 1]], [[86, 1], [0, 2]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 290: [[[[37, 2], [26, 2], [6, 2], [108, 1]], [[0, 1]], [[109, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 291: [[[[2, 0], [103, 1], [110, 0]], [[0, 1]]],\n\t       {2: 1,\n\t        4: 1,\n\t        5: 1,\n\t        6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        10: 1,\n\t        11: 1,\n\t        12: 1,\n\t        13: 1,\n\t        14: 1,\n\t        15: 1,\n\t        16: 1,\n\t        17: 1,\n\t        18: 1,\n\t        19: 1,\n\t        20: 1,\n\t        21: 1,\n\t        22: 1,\n\t        23: 1,\n\t        24: 1,\n\t        25: 1,\n\t        26: 1,\n\t        27: 1,\n\t        28: 1,\n\t        29: 1,\n\t        30: 1,\n\t        31: 1,\n\t        32: 1,\n\t        33: 1,\n\t        34: 1,\n\t        35: 1,\n\t        36: 1,\n\t        37: 1,\n\t        103: 1}],\n\t 292: [[[[111, 1], [112, 1], [113, 1], [114, 1], [115, 1]], [[0, 1]]],\n\t       {5: 1, 20: 1, 27: 1, 33: 1, 34: 1}],\n\t 293: [[[[29, 1]],\n\t        [[73, 2]],\n\t        [[74, 3]],\n\t        [[72, 4]],\n\t        [[70, 5]],\n\t        [[71, 6]],\n\t        [[116, 7], [0, 6]],\n\t        [[70, 8]],\n\t        [[71, 9]],\n\t        [[0, 9]]],\n\t       {29: 1}],\n\t 294: [[[[30, 1], [22, 2]], [[117, 3]], [[0, 2]], [[52, 2]]], {22: 1, 30: 1}],\n\t 295: [[[[118, 1]], [[46, 2], [0, 1]], [[118, 1], [0, 2]]], {22: 1, 30: 1}],\n\t 296: [[[[4, 1]], [[22, 2]], [[119, 3]], [[70, 4]], [[71, 5]], [[0, 5]]],\n\t       {4: 1}],\n\t 297: [[[[28, 1]], [[22, 2]], [[46, 1], [0, 2]]], {28: 1}],\n\t 298: [[[[32, 1]],\n\t        [[45, 2]],\n\t        [[70, 3]],\n\t        [[71, 4]],\n\t        [[116, 5], [120, 1], [0, 4]],\n\t        [[70, 6]],\n\t        [[71, 7]],\n\t        [[0, 7]]],\n\t       {32: 1}],\n\t 299: [[[[22, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]], {22: 1}],\n\t 300: [[[[121, 1]], [[46, 2], [0, 1]], [[121, 1], [0, 2]]], {22: 1}],\n\t 301: [[[[31, 1]],\n\t        [[97, 2], [102, 3]],\n\t        [[25, 4]],\n\t        [[97, 2], [25, 4], [102, 3]],\n\t        [[122, 5], [42, 5], [30, 6]],\n\t        [[0, 5]],\n\t        [[122, 7]],\n\t        [[52, 5]]],\n\t       {31: 1}],\n\t 302: [[[[25, 1]], [[123, 2]], [[0, 2]]], {25: 1}],\n\t 303: [[[[124, 1], [125, 1]], [[0, 1]]], {25: 1, 31: 1}],\n\t 304: [[[[11, 1]], [[70, 2], [126, 3]], [[45, 4]], [[70, 2]], [[0, 4]]],\n\t       {11: 1}],\n\t 305: [[[[29, 1]],\n\t        [[73, 2]],\n\t        [[74, 3]],\n\t        [[127, 4]],\n\t        [[128, 5], [0, 4]],\n\t        [[0, 5]]],\n\t       {29: 1}],\n\t 306: [[[[32, 1]], [[77, 2]], [[128, 3], [0, 2]], [[0, 3]]], {32: 1}],\n\t 307: [[[[129, 1], [130, 1]], [[0, 1]]], {29: 1, 32: 1}],\n\t 308: [[[[45, 1]],\n\t        [[129, 2], [46, 3], [0, 1]],\n\t        [[0, 2]],\n\t        [[45, 4], [0, 3]],\n\t        [[46, 3], [0, 4]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 309: [[[[7, 1], [131, 2]], [[40, 2]], [[0, 2]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 310: [[[[11, 1]], [[70, 2], [126, 3]], [[77, 4]], [[70, 2]], [[0, 4]]],\n\t       {11: 1}],\n\t 311: [[[[132, 1], [75, 1]], [[0, 1]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 312: [[[[133, 1]], [[134, 0], [0, 1]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 313: [[[[30, 1]], [[52, 2], [126, 3]], [[0, 2]], [[52, 2]]], {30: 1}],\n\t 314: [[[[24, 1]], [[0, 1]]], {24: 1}],\n\t 315: [[[[135, 1]], [[44, 2], [136, 1], [0, 1]], [[109, 3]], [[0, 3]]],\n\t       {8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 30: 1}],\n\t 316: [[[[12, 1]],\n\t        [[45, 2], [137, 3], [0, 1]],\n\t        [[46, 4], [0, 2]],\n\t        [[45, 5]],\n\t        [[45, 2], [0, 4]],\n\t        [[46, 6], [0, 5]],\n\t        [[45, 7]],\n\t        [[46, 8], [0, 7]],\n\t        [[45, 7], [0, 8]]],\n\t       {12: 1}],\n\t 317: [[[[5, 1]],\n\t        [[45, 2], [0, 1]],\n\t        [[46, 3], [0, 2]],\n\t        [[45, 4]],\n\t        [[46, 5], [0, 4]],\n\t        [[45, 6]],\n\t        [[0, 6]]],\n\t       {5: 1}],\n\t 318: [[[[20, 1]], [[72, 2], [0, 1]], [[0, 2]]], {20: 1}],\n\t 319: [[[[138, 1]], [[139, 0], [137, 0], [0, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 320: [[[[140, 1]], [[2, 2], [141, 3]], [[0, 2]], [[140, 1], [2, 2]]],\n\t       {5: 1,\n\t        6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        12: 1,\n\t        13: 1,\n\t        14: 1,\n\t        15: 1,\n\t        17: 1,\n\t        19: 1,\n\t        20: 1,\n\t        21: 1,\n\t        22: 1,\n\t        23: 1,\n\t        24: 1,\n\t        25: 1,\n\t        26: 1,\n\t        27: 1,\n\t        28: 1,\n\t        30: 1,\n\t        31: 1,\n\t        33: 1,\n\t        34: 1,\n\t        37: 1}],\n\t 321: [[[[70, 1]], [[45, 2], [0, 1]], [[0, 2]]], {70: 1}],\n\t 322: [[[[142, 1],\n\t         [143, 1],\n\t         [144, 1],\n\t         [145, 1],\n\t         [146, 1],\n\t         [147, 1],\n\t         [148, 1],\n\t         [149, 1],\n\t         [150, 1],\n\t         [151, 1]],\n\t        [[0, 1]]],\n\t       {5: 1,\n\t        6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        12: 1,\n\t        13: 1,\n\t        14: 1,\n\t        15: 1,\n\t        17: 1,\n\t        19: 1,\n\t        20: 1,\n\t        21: 1,\n\t        22: 1,\n\t        23: 1,\n\t        24: 1,\n\t        25: 1,\n\t        26: 1,\n\t        27: 1,\n\t        28: 1,\n\t        30: 1,\n\t        31: 1,\n\t        33: 1,\n\t        34: 1,\n\t        37: 1}],\n\t 323: [[[[1, 1], [3, 1]], [[0, 1]]],\n\t       {4: 1,\n\t        5: 1,\n\t        6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        10: 1,\n\t        11: 1,\n\t        12: 1,\n\t        13: 1,\n\t        14: 1,\n\t        15: 1,\n\t        16: 1,\n\t        17: 1,\n\t        18: 1,\n\t        19: 1,\n\t        20: 1,\n\t        21: 1,\n\t        22: 1,\n\t        23: 1,\n\t        24: 1,\n\t        25: 1,\n\t        26: 1,\n\t        27: 1,\n\t        28: 1,\n\t        29: 1,\n\t        30: 1,\n\t        31: 1,\n\t        32: 1,\n\t        33: 1,\n\t        34: 1,\n\t        35: 1,\n\t        36: 1,\n\t        37: 1}],\n\t 324: [[[[45, 1], [70, 2], [102, 3]],\n\t        [[70, 2], [0, 1]],\n\t        [[45, 4], [152, 5], [0, 2]],\n\t        [[102, 6]],\n\t        [[152, 5], [0, 4]],\n\t        [[0, 5]],\n\t        [[102, 5]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1,\n\t        70: 1,\n\t        102: 1}],\n\t 325: [[[[153, 1]], [[46, 2], [0, 1]], [[153, 1], [0, 2]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1,\n\t        70: 1,\n\t        102: 1}],\n\t 326: [[[[1, 1], [2, 2]],\n\t        [[0, 1]],\n\t        [[154, 3]],\n\t        [[110, 4]],\n\t        [[155, 1], [110, 4]]],\n\t       {2: 1,\n\t        5: 1,\n\t        6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        12: 1,\n\t        13: 1,\n\t        14: 1,\n\t        15: 1,\n\t        17: 1,\n\t        19: 1,\n\t        20: 1,\n\t        21: 1,\n\t        22: 1,\n\t        23: 1,\n\t        24: 1,\n\t        25: 1,\n\t        26: 1,\n\t        27: 1,\n\t        28: 1,\n\t        30: 1,\n\t        31: 1,\n\t        33: 1,\n\t        34: 1,\n\t        37: 1}],\n\t 327: [[[[109, 1]], [[156, 0], [42, 0], [157, 0], [158, 0], [0, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 328: [[[[75, 1], [159, 2]],\n\t        [[32, 3], [0, 1]],\n\t        [[0, 2]],\n\t        [[75, 4]],\n\t        [[116, 5]],\n\t        [[45, 2]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 329: [[[[45, 1]], [[46, 2], [0, 1]], [[45, 1], [0, 2]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 330: [[[[45, 1]], [[46, 0], [0, 1]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 331: [[[[45, 1]],\n\t        [[48, 2], [46, 3], [0, 1]],\n\t        [[0, 2]],\n\t        [[45, 4], [0, 3]],\n\t        [[46, 3], [0, 4]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 332: [[[[77, 1]],\n\t        [[46, 2], [0, 1]],\n\t        [[77, 3]],\n\t        [[46, 4], [0, 3]],\n\t        [[77, 3], [0, 4]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 333: [[[[30, 1], [102, 2], [14, 3]],\n\t        [[52, 4], [98, 5]],\n\t        [[22, 4]],\n\t        [[160, 6]],\n\t        [[0, 4]],\n\t        [[52, 4]],\n\t        [[51, 4]]],\n\t       {14: 1, 30: 1, 102: 1}],\n\t 334: [[[[16, 1]],\n\t        [[70, 2]],\n\t        [[71, 3]],\n\t        [[161, 4], [162, 5]],\n\t        [[70, 6]],\n\t        [[70, 7]],\n\t        [[71, 8]],\n\t        [[71, 9]],\n\t        [[161, 4], [116, 10], [162, 5], [0, 8]],\n\t        [[0, 9]],\n\t        [[70, 11]],\n\t        [[71, 12]],\n\t        [[162, 5], [0, 12]]],\n\t       {16: 1}],\n\t 335: [[[[42, 1], [118, 2], [44, 3]],\n\t        [[22, 4]],\n\t        [[47, 5], [46, 6], [0, 2]],\n\t        [[22, 7]],\n\t        [[46, 8], [0, 4]],\n\t        [[45, 9]],\n\t        [[42, 1], [118, 2], [44, 3], [0, 6]],\n\t        [[0, 7]],\n\t        [[44, 3]],\n\t        [[46, 6], [0, 9]]],\n\t       {22: 1, 30: 1, 42: 1, 44: 1}],\n\t 336: [[[[18, 1]],\n\t        [[45, 2]],\n\t        [[70, 3]],\n\t        [[71, 4]],\n\t        [[116, 5], [0, 4]],\n\t        [[70, 6]],\n\t        [[71, 7]],\n\t        [[0, 7]]],\n\t       {18: 1}],\n\t 337: [[[[45, 1]], [[100, 2], [0, 1]], [[86, 3]], [[0, 3]]],\n\t       {6: 1,\n\t        7: 1,\n\t        8: 1,\n\t        9: 1,\n\t        11: 1,\n\t        14: 1,\n\t        15: 1,\n\t        19: 1,\n\t        22: 1,\n\t        26: 1,\n\t        30: 1,\n\t        37: 1}],\n\t 338: [[[[36, 1]], [[163, 2]], [[70, 3], [46, 1]], [[71, 4]], [[0, 4]]],\n\t       {36: 1}],\n\t 339: [[[[164, 1]], [[165, 0], [0, 1]]],\n\t       {6: 1, 8: 1, 9: 1, 14: 1, 15: 1, 19: 1, 22: 1, 26: 1, 30: 1, 37: 1}],\n\t 340: [[[[27, 1]], [[72, 2], [0, 1]], [[0, 2]]], {27: 1}],\n\t 341: [[[[53, 1]], [[0, 1]]], {27: 1}]},\n\tstates:\n\t[[[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]],\n\t [[[38, 1]], [[39, 0], [0, 1]]],\n\t [[[40, 1]], [[41, 0], [0, 1]]],\n\t [[[42, 1], [43, 2], [44, 3]],\n\t  [[45, 4]],\n\t  [[46, 5], [0, 2]],\n\t  [[45, 6]],\n\t  [[46, 7], [0, 4]],\n\t  [[42, 1], [43, 2], [44, 3], [0, 5]],\n\t  [[0, 6]],\n\t  [[43, 4], [44, 3]]],\n\t [[[45, 1]], [[47, 2], [48, 3], [0, 1]], [[45, 3]], [[0, 3]]],\n\t [[[49, 1]], [[26, 0], [37, 0], [0, 1]]],\n\t [[[21, 1]], [[45, 2]], [[46, 3], [0, 2]], [[45, 4]], [[0, 4]]],\n\t [[[19, 1], [8, 2], [9, 5], [30, 4], [14, 3], [15, 6], [22, 2]],\n\t  [[19, 1], [0, 1]],\n\t  [[0, 2]],\n\t  [[50, 7], [51, 2]],\n\t  [[52, 2], [53, 8], [54, 8]],\n\t  [[55, 2], [56, 9]],\n\t  [[57, 10]],\n\t  [[51, 2]],\n\t  [[52, 2]],\n\t  [[55, 2]],\n\t  [[15, 2]]],\n\t [[[58, 1],\n\t   [59, 1],\n\t   [60, 1],\n\t   [61, 1],\n\t   [62, 1],\n\t   [63, 1],\n\t   [64, 1],\n\t   [65, 1],\n\t   [66, 1],\n\t   [67, 1],\n\t   [68, 1],\n\t   [69, 1]],\n\t  [[0, 1]]],\n\t [[[33, 1]], [[0, 1]]],\n\t [[[10, 1]],\n\t  [[22, 2]],\n\t  [[70, 3], [30, 4]],\n\t  [[71, 5]],\n\t  [[52, 6], [72, 7]],\n\t  [[0, 5]],\n\t  [[70, 3]],\n\t  [[52, 6]]],\n\t [[[29, 1]], [[73, 2]], [[74, 3]], [[75, 4]], [[76, 5], [0, 4]], [[0, 5]]],\n\t [[[32, 1]], [[77, 2]], [[76, 3], [0, 2]], [[0, 3]]],\n\t [[[78, 1], [48, 1]], [[0, 1]]],\n\t [[[79, 1],\n\t   [80, 1],\n\t   [7, 2],\n\t   [81, 1],\n\t   [79, 1],\n\t   [74, 1],\n\t   [82, 1],\n\t   [83, 3],\n\t   [84, 1],\n\t   [85, 1]],\n\t  [[0, 1]],\n\t  [[74, 1]],\n\t  [[7, 1], [0, 3]]],\n\t [[[86, 1]], [[87, 0], [0, 1]]],\n\t [[[88, 1], [89, 1], [90, 1], [91, 1], [92, 1], [93, 1], [94, 1], [95, 1]],\n\t  [[0, 1]]],\n\t [[[34, 1]], [[0, 1]]],\n\t [[[13, 1]], [[0, 1]]],\n\t [[[96, 1]], [[94, 2], [91, 2]], [[0, 2]]],\n\t [[[35, 1]],\n\t  [[97, 2]],\n\t  [[2, 4], [30, 3]],\n\t  [[52, 5], [98, 6]],\n\t  [[0, 4]],\n\t  [[2, 4]],\n\t  [[52, 5]]],\n\t [[[99, 1]], [[99, 1], [0, 1]]],\n\t [[[23, 1]], [[73, 2]], [[0, 2]]],\n\t [[[45, 1]],\n\t  [[70, 2], [48, 3], [46, 4], [0, 1]],\n\t  [[45, 5]],\n\t  [[0, 3]],\n\t  [[45, 6], [0, 4]],\n\t  [[48, 3], [46, 7], [0, 5]],\n\t  [[46, 4], [0, 6]],\n\t  [[45, 8], [0, 7]],\n\t  [[70, 9]],\n\t  [[45, 10]],\n\t  [[46, 7], [0, 10]]],\n\t [[[97, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]],\n\t [[[101, 1]], [[46, 0], [0, 1]]],\n\t [[[22, 1]], [[102, 0], [0, 1]]],\n\t [[[22, 1]], [[0, 1]]],\n\t [[[72, 1]], [[2, 1], [103, 2]], [[0, 2]]],\n\t [[[104, 1]],\n\t  [[45, 2], [0, 1]],\n\t  [[100, 3], [46, 3], [0, 2]],\n\t  [[45, 4]],\n\t  [[0, 4]]],\n\t [[[17, 1]],\n\t  [[86, 2]],\n\t  [[74, 3], [0, 2]],\n\t  [[45, 4]],\n\t  [[46, 5], [0, 4]],\n\t  [[45, 6]],\n\t  [[0, 6]]],\n\t [[[105, 1]], [[106, 0], [0, 1]]],\n\t [[[72, 1]],\n\t  [[107, 2], [47, 3], [0, 1]],\n\t  [[72, 4], [53, 4]],\n\t  [[72, 5], [53, 5]],\n\t  [[0, 4]],\n\t  [[47, 3], [0, 5]]],\n\t [[[86, 1]], [[46, 2], [0, 1]], [[86, 1], [0, 2]]],\n\t [[[37, 2], [26, 2], [6, 2], [108, 1]], [[0, 1]], [[109, 1]]],\n\t [[[2, 0], [103, 1], [110, 0]], [[0, 1]]],\n\t [[[111, 1], [112, 1], [113, 1], [114, 1], [115, 1]], [[0, 1]]],\n\t [[[29, 1]],\n\t  [[73, 2]],\n\t  [[74, 3]],\n\t  [[72, 4]],\n\t  [[70, 5]],\n\t  [[71, 6]],\n\t  [[116, 7], [0, 6]],\n\t  [[70, 8]],\n\t  [[71, 9]],\n\t  [[0, 9]]],\n\t [[[30, 1], [22, 2]], [[117, 3]], [[0, 2]], [[52, 2]]],\n\t [[[118, 1]], [[46, 2], [0, 1]], [[118, 1], [0, 2]]],\n\t [[[4, 1]], [[22, 2]], [[119, 3]], [[70, 4]], [[71, 5]], [[0, 5]]],\n\t [[[28, 1]], [[22, 2]], [[46, 1], [0, 2]]],\n\t [[[32, 1]],\n\t  [[45, 2]],\n\t  [[70, 3]],\n\t  [[71, 4]],\n\t  [[116, 5], [120, 1], [0, 4]],\n\t  [[70, 6]],\n\t  [[71, 7]],\n\t  [[0, 7]]],\n\t [[[22, 1]], [[100, 2], [0, 1]], [[22, 3]], [[0, 3]]],\n\t [[[121, 1]], [[46, 2], [0, 1]], [[121, 1], [0, 2]]],\n\t [[[31, 1]],\n\t  [[97, 2], [102, 3]],\n\t  [[25, 4]],\n\t  [[97, 2], [25, 4], [102, 3]],\n\t  [[122, 5], [42, 5], [30, 6]],\n\t  [[0, 5]],\n\t  [[122, 7]],\n\t  [[52, 5]]],\n\t [[[25, 1]], [[123, 2]], [[0, 2]]],\n\t [[[124, 1], [125, 1]], [[0, 1]]],\n\t [[[11, 1]], [[70, 2], [126, 3]], [[45, 4]], [[70, 2]], [[0, 4]]],\n\t [[[29, 1]], [[73, 2]], [[74, 3]], [[127, 4]], [[128, 5], [0, 4]], [[0, 5]]],\n\t [[[32, 1]], [[77, 2]], [[128, 3], [0, 2]], [[0, 3]]],\n\t [[[129, 1], [130, 1]], [[0, 1]]],\n\t [[[45, 1]],\n\t  [[129, 2], [46, 3], [0, 1]],\n\t  [[0, 2]],\n\t  [[45, 4], [0, 3]],\n\t  [[46, 3], [0, 4]]],\n\t [[[7, 1], [131, 2]], [[40, 2]], [[0, 2]]],\n\t [[[11, 1]], [[70, 2], [126, 3]], [[77, 4]], [[70, 2]], [[0, 4]]],\n\t [[[132, 1], [75, 1]], [[0, 1]]],\n\t [[[133, 1]], [[134, 0], [0, 1]]],\n\t [[[30, 1]], [[52, 2], [126, 3]], [[0, 2]], [[52, 2]]],\n\t [[[24, 1]], [[0, 1]]],\n\t [[[135, 1]], [[44, 2], [136, 1], [0, 1]], [[109, 3]], [[0, 3]]],\n\t [[[12, 1]],\n\t  [[45, 2], [137, 3], [0, 1]],\n\t  [[46, 4], [0, 2]],\n\t  [[45, 5]],\n\t  [[45, 2], [0, 4]],\n\t  [[46, 6], [0, 5]],\n\t  [[45, 7]],\n\t  [[46, 8], [0, 7]],\n\t  [[45, 7], [0, 8]]],\n\t [[[5, 1]],\n\t  [[45, 2], [0, 1]],\n\t  [[46, 3], [0, 2]],\n\t  [[45, 4]],\n\t  [[46, 5], [0, 4]],\n\t  [[45, 6]],\n\t  [[0, 6]]],\n\t [[[20, 1]], [[72, 2], [0, 1]], [[0, 2]]],\n\t [[[138, 1]], [[139, 0], [137, 0], [0, 1]]],\n\t [[[140, 1]], [[2, 2], [141, 3]], [[0, 2]], [[140, 1], [2, 2]]],\n\t [[[70, 1]], [[45, 2], [0, 1]], [[0, 2]]],\n\t [[[142, 1],\n\t   [143, 1],\n\t   [144, 1],\n\t   [145, 1],\n\t   [146, 1],\n\t   [147, 1],\n\t   [148, 1],\n\t   [149, 1],\n\t   [150, 1],\n\t   [151, 1]],\n\t  [[0, 1]]],\n\t [[[1, 1], [3, 1]], [[0, 1]]],\n\t [[[45, 1], [70, 2], [102, 3]],\n\t  [[70, 2], [0, 1]],\n\t  [[45, 4], [152, 5], [0, 2]],\n\t  [[102, 6]],\n\t  [[152, 5], [0, 4]],\n\t  [[0, 5]],\n\t  [[102, 5]]],\n\t [[[153, 1]], [[46, 2], [0, 1]], [[153, 1], [0, 2]]],\n\t [[[1, 1], [2, 2]], [[0, 1]], [[154, 3]], [[110, 4]], [[155, 1], [110, 4]]],\n\t [[[109, 1]], [[156, 0], [42, 0], [157, 0], [158, 0], [0, 1]]],\n\t [[[75, 1], [159, 2]],\n\t  [[32, 3], [0, 1]],\n\t  [[0, 2]],\n\t  [[75, 4]],\n\t  [[116, 5]],\n\t  [[45, 2]]],\n\t [[[45, 1]], [[46, 2], [0, 1]], [[45, 1], [0, 2]]],\n\t [[[45, 1]], [[46, 0], [0, 1]]],\n\t [[[45, 1]],\n\t  [[48, 2], [46, 3], [0, 1]],\n\t  [[0, 2]],\n\t  [[45, 4], [0, 3]],\n\t  [[46, 3], [0, 4]]],\n\t [[[77, 1]],\n\t  [[46, 2], [0, 1]],\n\t  [[77, 3]],\n\t  [[46, 4], [0, 3]],\n\t  [[77, 3], [0, 4]]],\n\t [[[30, 1], [102, 2], [14, 3]],\n\t  [[52, 4], [98, 5]],\n\t  [[22, 4]],\n\t  [[160, 6]],\n\t  [[0, 4]],\n\t  [[52, 4]],\n\t  [[51, 4]]],\n\t [[[16, 1]],\n\t  [[70, 2]],\n\t  [[71, 3]],\n\t  [[161, 4], [162, 5]],\n\t  [[70, 6]],\n\t  [[70, 7]],\n\t  [[71, 8]],\n\t  [[71, 9]],\n\t  [[161, 4], [116, 10], [162, 5], [0, 8]],\n\t  [[0, 9]],\n\t  [[70, 11]],\n\t  [[71, 12]],\n\t  [[162, 5], [0, 12]]],\n\t [[[42, 1], [118, 2], [44, 3]],\n\t  [[22, 4]],\n\t  [[47, 5], [46, 6], [0, 2]],\n\t  [[22, 7]],\n\t  [[46, 8], [0, 4]],\n\t  [[45, 9]],\n\t  [[42, 1], [118, 2], [44, 3], [0, 6]],\n\t  [[0, 7]],\n\t  [[44, 3]],\n\t  [[46, 6], [0, 9]]],\n\t [[[18, 1]],\n\t  [[45, 2]],\n\t  [[70, 3]],\n\t  [[71, 4]],\n\t  [[116, 5], [0, 4]],\n\t  [[70, 6]],\n\t  [[71, 7]],\n\t  [[0, 7]]],\n\t [[[45, 1]], [[100, 2], [0, 1]], [[86, 3]], [[0, 3]]],\n\t [[[36, 1]], [[163, 2]], [[70, 3], [46, 1]], [[71, 4]], [[0, 4]]],\n\t [[[164, 1]], [[165, 0], [0, 1]]],\n\t [[[27, 1]], [[72, 2], [0, 1]], [[0, 2]]],\n\t [[[53, 1]], [[0, 1]]]],\n\tlabels:\n\t[[0, 'EMPTY'],\n\t [320, null],\n\t [4, null],\n\t [272, null],\n\t [1, 'def'],\n\t [1, 'raise'],\n\t [32, null],\n\t [1, 'not'],\n\t [2, null],\n\t [26, null],\n\t [1, 'class'],\n\t [1, 'lambda'],\n\t [1, 'print'],\n\t [1, 'debugger'],\n\t [9, null],\n\t [25, null],\n\t [1, 'try'],\n\t [1, 'exec'],\n\t [1, 'while'],\n\t [3, null],\n\t [1, 'return'],\n\t [1, 'assert'],\n\t [1, null],\n\t [1, 'del'],\n\t [1, 'pass'],\n\t [1, 'import'],\n\t [15, null],\n\t [1, 'yield'],\n\t [1, 'global'],\n\t [1, 'for'],\n\t [7, null],\n\t [1, 'from'],\n\t [1, 'if'],\n\t [1, 'break'],\n\t [1, 'continue'],\n\t [50, null],\n\t [1, 'with'],\n\t [14, null],\n\t [319, null],\n\t [19, null],\n\t [309, null],\n\t [1, 'and'],\n\t [16, null],\n\t [260, null],\n\t [36, null],\n\t [328, null],\n\t [12, null],\n\t [22, null],\n\t [267, null],\n\t [327, null],\n\t [308, null],\n\t [10, null],\n\t [8, null],\n\t [340, null],\n\t [331, null],\n\t [27, null],\n\t [279, null],\n\t [330, null],\n\t [46, null],\n\t [39, null],\n\t [41, null],\n\t [47, null],\n\t [42, null],\n\t [43, null],\n\t [37, null],\n\t [44, null],\n\t [49, null],\n\t [45, null],\n\t [38, null],\n\t [40, null],\n\t [11, null],\n\t [326, null],\n\t [329, null],\n\t [289, null],\n\t [1, 'in'],\n\t [312, null],\n\t [269, null],\n\t [311, null],\n\t [268, null],\n\t [29, null],\n\t [21, null],\n\t [28, null],\n\t [30, null],\n\t [1, 'is'],\n\t [31, null],\n\t [20, null],\n\t [287, null],\n\t [270, null],\n\t [334, null],\n\t [298, null],\n\t [293, null],\n\t [266, null],\n\t [338, null],\n\t [336, null],\n\t [296, null],\n\t [275, null],\n\t [277, null],\n\t [282, null],\n\t [259, null],\n\t [276, null],\n\t [1, 'as'],\n\t [280, null],\n\t [23, null],\n\t [0, null],\n\t [1, 'except'],\n\t [339, null],\n\t [18, null],\n\t [264, null],\n\t [315, null],\n\t [290, null],\n\t [323, null],\n\t [265, null],\n\t [273, null],\n\t [317, null],\n\t [318, null],\n\t [341, null],\n\t [1, 'else'],\n\t [295, null],\n\t [294, null],\n\t [313, null],\n\t [1, 'elif'],\n\t [299, null],\n\t [300, null],\n\t [281, null],\n\t [302, null],\n\t [301, null],\n\t [335, null],\n\t [332, null],\n\t [307, null],\n\t [305, null],\n\t [306, null],\n\t [271, null],\n\t [310, null],\n\t [258, null],\n\t [1, 'or'],\n\t [263, null],\n\t [333, null],\n\t [35, null],\n\t [261, null],\n\t [34, null],\n\t [322, null],\n\t [13, null],\n\t [292, null],\n\t [278, null],\n\t [288, null],\n\t [314, null],\n\t [316, null],\n\t [262, null],\n\t [286, null],\n\t [297, null],\n\t [303, null],\n\t [274, null],\n\t [321, null],\n\t [324, null],\n\t [5, null],\n\t [6, null],\n\t [48, null],\n\t [17, null],\n\t [24, null],\n\t [304, null],\n\t [325, null],\n\t [285, null],\n\t [1, 'finally'],\n\t [337, null],\n\t [257, null],\n\t [33, null]],\n\tkeywords:\n\t{'and': 41,\n\t 'as': 100,\n\t 'assert': 21,\n\t 'break': 33,\n\t 'class': 10,\n\t 'continue': 34,\n\t 'debugger': 13,\n\t 'def': 4,\n\t 'del': 23,\n\t 'elif': 120,\n\t 'else': 116,\n\t 'except': 104,\n\t 'exec': 17,\n\t 'finally': 162,\n\t 'for': 29,\n\t 'from': 31,\n\t 'global': 28,\n\t 'if': 32,\n\t 'import': 25,\n\t 'in': 74,\n\t 'is': 83,\n\t 'lambda': 11,\n\t 'not': 7,\n\t 'or': 134,\n\t 'pass': 24,\n\t 'print': 12,\n\t 'raise': 5,\n\t 'return': 20,\n\t 'try': 16,\n\t 'while': 18,\n\t 'with': 36,\n\t 'yield': 27},\n\ttokens:\n\t{0: 103,\n\t 1: 22,\n\t 2: 8,\n\t 3: 19,\n\t 4: 2,\n\t 5: 154,\n\t 6: 155,\n\t 7: 30,\n\t 8: 52,\n\t 9: 14,\n\t 10: 51,\n\t 11: 70,\n\t 12: 46,\n\t 13: 141,\n\t 14: 37,\n\t 15: 26,\n\t 16: 42,\n\t 17: 157,\n\t 18: 106,\n\t 19: 39,\n\t 20: 85,\n\t 21: 80,\n\t 22: 47,\n\t 23: 102,\n\t 24: 158,\n\t 25: 15,\n\t 26: 9,\n\t 27: 55,\n\t 28: 81,\n\t 29: 79,\n\t 30: 82,\n\t 31: 84,\n\t 32: 6,\n\t 33: 165,\n\t 34: 139,\n\t 35: 137,\n\t 36: 44,\n\t 37: 64,\n\t 38: 68,\n\t 39: 59,\n\t 40: 69,\n\t 41: 60,\n\t 42: 62,\n\t 43: 63,\n\t 44: 65,\n\t 45: 67,\n\t 46: 58,\n\t 47: 61,\n\t 48: 156,\n\t 49: 66,\n\t 50: 35},\n\tstart: 256\n\t};\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/parser.js ---- */ \n\n\t// low level parser to a concrete syntax tree, derived from cpython's lib2to3\n\n\t/**\n\t *\n\t * @constructor\n\t * @param {Object} grammar\n\t *\n\t * p = new Parser(grammar);\n\t * p.setup([start]);\n\t * foreach input token:\n\t *     if p.addtoken(...):\n\t *         break\n\t * root = p.rootnode\n\t *\n\t * can throw SyntaxError\n\t */\n\tfunction Parser (filename, grammar) {\n\t    this.filename = filename;\n\t    this.grammar = grammar;\n\t    this.p_flags = 0;\n\t    return this;\n\t}\n\n\t// all possible parser flags\n\tParser.FUTURE_PRINT_FUNCTION = \"print_function\";\n\tParser.FUTURE_UNICODE_LITERALS = \"unicode_literals\";\n\tParser.FUTURE_DIVISION = \"division\";\n\tParser.FUTURE_ABSOLUTE_IMPORT = \"absolute_import\";\n\tParser.FUTURE_WITH_STATEMENT = \"with_statement\";\n\tParser.FUTURE_NESTED_SCOPES = \"nested_scopes\";\n\tParser.FUTURE_GENERATORS = \"generators\";\n\tParser.CO_FUTURE_PRINT_FUNCTION = 0x10000;\n\tParser.CO_FUTURE_UNICODE_LITERALS = 0x20000;\n\tParser.CO_FUTURE_DIVISON = 0x2000;\n\tParser.CO_FUTURE_ABSOLUTE_IMPORT = 0x4000;\n\tParser.CO_FUTURE_WITH_STATEMENT = 0x8000;\n\n\tParser.prototype.setup = function (start) {\n\t    var stackentry;\n\t    var newnode;\n\t    start = start || this.grammar.start;\n\t    //print(\"START:\"+start);\n\n\t    newnode =\n\t    {\n\t        type    : start,\n\t        value   : null,\n\t        context : null,\n\t        children: []\n\t    };\n\t    stackentry =\n\t    {\n\t        dfa  : this.grammar.dfas[start],\n\t        state: 0,\n\t        node : newnode\n\t    };\n\t    this.stack = [stackentry];\n\t    this.used_names = {};\n\t};\n\n\tfunction findInDfa (a, obj) {\n\t    var i = a.length;\n\t    while (i--) {\n\t        if (a[i][0] === obj[0] && a[i][1] === obj[1]) {\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\n\n\t// Add a token; return true if we're done\n\tParser.prototype.addtoken = function (type, value, context) {\n\t    var errline;\n\t    var itsfirst;\n\t    var itsdfa;\n\t    var state;\n\t    var v;\n\t    var t;\n\t    var newstate;\n\t    var i;\n\t    var a;\n\t    var arcs;\n\t    var first;\n\t    var states;\n\t    var tp;\n\t    var ilabel = this.classify(type, value, context);\n\t    //print(\"ilabel:\"+ilabel);\n\n\t    OUTERWHILE:\n\t    while (true) {\n\t        tp = this.stack[this.stack.length - 1];\n\t        states = tp.dfa[0];\n\t        first = tp.dfa[1];\n\t        arcs = states[tp.state];\n\n\t        // look for a state with this label\n\t        for (a = 0; a < arcs.length; ++a) {\n\t            i = arcs[a][0];\n\t            newstate = arcs[a][1];\n\t            t = this.grammar.labels[i][0];\n\t            v = this.grammar.labels[i][1];\n\t            if (ilabel === i) {\n\t                // look it up in the list of labels\n\t                goog.asserts.assert(t < 256);\n\t                // shift a token; we're done with it\n\t                this.shift(type, value, newstate, context);\n\t                // pop while we are in an accept-only state\n\t                state = newstate;\n\t                //print(\"before:\"+JSON.stringify(states[state]) + \":state:\"+state+\":\"+JSON.stringify(states[state]));\n\t                /* jshint ignore:start */\n\t                while (states[state].length === 1\n\t                    && states[state][0][0] === 0\n\t                    && states[state][0][1] === state) {\n\t                    // states[state] == [(0, state)])\n\t                    this.pop();\n\t                    //print(\"in after pop:\"+JSON.stringify(states[state]) + \":state:\"+state+\":\"+JSON.stringify(states[state]));\n\t                    if (this.stack.length === 0) {\n\t                        // done!\n\t                        return true;\n\t                    }\n\t                    tp = this.stack[this.stack.length - 1];\n\t                    state = tp.state;\n\t                    states = tp.dfa[0];\n\t                    first = tp.dfa[1];\n\t                    //print(JSON.stringify(states), JSON.stringify(first));\n\t                    //print(\"bottom:\"+JSON.stringify(states[state]) + \":state:\"+state+\":\"+JSON.stringify(states[state]));\n\t                }\n\t                /* jshint ignore:end */\n\t                // done with this token\n\t                //print(\"DONE, return false\");\n\t                return false;\n\t            } else if (t >= 256) {\n\t                itsdfa = this.grammar.dfas[t];\n\t                itsfirst = itsdfa[1];\n\t                if (itsfirst.hasOwnProperty(ilabel)) {\n\t                    // push a symbol\n\t                    this.push(t, this.grammar.dfas[t], newstate, context);\n\t                    continue OUTERWHILE;\n\t                }\n\t            }\n\t        }\n\n\t        //print(\"findInDfa: \" + JSON.stringify(arcs)+\" vs. \" + tp.state);\n\t        if (findInDfa(arcs, [0, tp.state])) {\n\t            // an accepting state, pop it and try somethign else\n\t            //print(\"WAA\");\n\t            this.pop();\n\t            if (this.stack.length === 0) {\n\t                throw new Sk.builtin.SyntaxError(\"too much input\", this.filename);\n\t            }\n\t        } else {\n\t            // no transition\n\t            errline = context[0][0];\n\n\t            var that = this;\n\t            var ar = arcs.map(function(a) {\n\t                var i = a[0];\n\t                var t = that.grammar.labels[i][0];\n\t                return Sk.nameForToken(t);\n\t            });\n\t            var extra = {\n\t                kind: \"DAG_MISS\",\n\t                expected: ar,\n\t                found: Sk.nameForToken(type),\n\t                found_val: value,\n\t                inside: Sk.nameForToken(tp.node.type),\n\t                node: tp.node,\n\t                parent: this.stack.length > 1 ? this.stack[this.stack.length - 2].node : undefined\n\t            };\n\t            var reason = \"expected \" + ar.join(', ') + \" but found \" + extra.found + \" while parsing \" + extra.inside;\n\n\t            throw new Sk.builtin.SyntaxError(reason, this.filename, errline, context, extra);\n\t        }\n\t    }\n\t};\n\n\t// turn a token into a label\n\tParser.prototype.classify = function (type, value, context) {\n\t    var ilabel;\n\t    if (type === Sk.Tokenizer.Tokens.T_NAME) {\n\t        this.used_names[value] = true;\n\t        ilabel = this.grammar.keywords.hasOwnProperty(value) && this.grammar.keywords[value];\n\n\t        /* Check for handling print as an builtin function */\n\t        if(value === \"print\" && (this.p_flags & Parser.CO_FUTURE_PRINT_FUNCTION || Sk.python3 === true)) {\n\t            ilabel = false; // ilabel determines if the value is a keyword\n\t        }\n\n\t        if (ilabel) {\n\t            //print(\"is keyword\");\n\t            return ilabel;\n\t        }\n\t    }\n\t    ilabel = this.grammar.tokens.hasOwnProperty(type) && this.grammar.tokens[type];\n\t    if (!ilabel) {\n\t        // throw new Sk.builtin.SyntaxError(\"bad token\", type, value, context);\n\t        // Questionable modification to put line number in position 2\n\t        // like everywhere else and filename in position 1.\n\t        var extra = {\n\t            kind: \"CLASSIFY\",\n\t            type: type,\n\t            value: value\n\t        };\n\t        throw new Sk.builtin.SyntaxError(\"bad token\", this.filename, context[0][0], context, extra);\n\t    }\n\t    return ilabel;\n\t};\n\n\t// shift a token\n\tParser.prototype.shift = function (type, value, newstate, context) {\n\t    var dfa = this.stack[this.stack.length - 1].dfa;\n\t    var state = this.stack[this.stack.length - 1].state;\n\t    var node = this.stack[this.stack.length - 1].node;\n\t    //print(\"context\", context);\n\t    var newnode = {\n\t        type      : type,\n\t        value     : value,\n\t        lineno    : context[0][0],         // throwing away end here to match cpython\n\t        col_offset: context[0][1],\n\t        children  : null\n\t    };\n\t    if (newnode) {\n\t        node.children.push(newnode);\n\t    }\n\t    this.stack[this.stack.length - 1] = {\n\t        dfa  : dfa,\n\t        state: newstate,\n\t        node : node\n\t    };\n\t};\n\n\t// push a nonterminal\n\tParser.prototype.push = function (type, newdfa, newstate, context) {\n\t    var dfa = this.stack[this.stack.length - 1].dfa;\n\t    var node = this.stack[this.stack.length - 1].node;\n\t    var newnode = {\n\t        type      : type,\n\t        value     : null,\n\t        lineno    : context[0][0],      // throwing away end here to match cpython\n\t        col_offset: context[0][1],\n\t        children  : []\n\t    };\n\t    this.stack[this.stack.length - 1] = {\n\t        dfa  : dfa,\n\t        state: newstate,\n\t        node : node\n\t    };\n\t    this.stack.push({\n\t        dfa  : newdfa,\n\t        state: 0,\n\t        node : newnode\n\t    });\n\t};\n\n\t//var ac = 0;\n\t//var bc = 0;\n\n\t// pop a nonterminal\n\tParser.prototype.pop = function () {\n\t    var node;\n\t    var pop = this.stack.pop();\n\t    var newnode = pop.node;\n\t    //print(\"POP\");\n\t    if (newnode) {\n\t        //print(\"A\", ac++, newnode.type);\n\t        //print(\"stacklen:\"+this.stack.length);\n\t        if (this.stack.length !== 0) {\n\t            //print(\"B\", bc++);\n\t            node = this.stack[this.stack.length - 1].node;\n\t            node.children.push(newnode);\n\t        } else {\n\t            //print(\"C\");\n\t            this.rootnode = newnode;\n\t            this.rootnode.used_names = this.used_names;\n\t        }\n\t    }\n\t};\n\n\t/**\n\t * parser for interactive input. returns a function that should be called with\n\t * lines of input as they are entered. the function will return false\n\t * until the input is complete, when it will return the rootnode of the parse.\n\t *\n\t * @param {string} filename\n\t * @param {string=} style root of parse tree (optional)\n\t */\n\tfunction makeParser (filename, style) {\n\t    var tokenizer;\n\t    var T_OP;\n\t    var T_NL;\n\t    var T_COMMENT;\n\t    var prefix;\n\t    var column;\n\t    var lineno;\n\t    var p;\n\t    if (style === undefined) {\n\t        style = \"file_input\";\n\t    }\n\t    p = new Parser(filename, Sk.ParseTables);\n\t    // for closure's benefit\n\t    if (style === \"file_input\") {\n\t        p.setup(Sk.ParseTables.sym.file_input);\n\t    } else {\n\t        goog.asserts.fail(\"todo;\");\n\t    }\n\t    lineno = 1;\n\t    column = 0;\n\t    prefix = \"\";\n\t    T_COMMENT = Sk.Tokenizer.Tokens.T_COMMENT;\n\t    T_NL = Sk.Tokenizer.Tokens.T_NL;\n\t    T_OP = Sk.Tokenizer.Tokens.T_OP;\n\t    tokenizer = new Sk.Tokenizer(filename, style === \"single_input\", function (type, value, start, end, line) {\n\t        var s_lineno = start[0];\n\t        var s_column = start[1];\n\t        /*\n\t         if (s_lineno !== lineno && s_column !== column)\n\t         {\n\t         // todo; update prefix and line/col\n\t         }\n\t         */\n\t        if (type === T_COMMENT || type === T_NL) {\n\t            prefix += value;\n\t            lineno = end[0];\n\t            column = end[1];\n\t            if (value[value.length - 1] === \"\\n\") {\n\t                lineno += 1;\n\t                column = 0;\n\t            }\n\t            //print(\"  not calling addtoken\");\n\t            return undefined;\n\t        }\n\t        if (type === T_OP) {\n\t            type = Sk.OpMap[value];\n\t        }\n\t        if (p.addtoken(type, value, [start, end, line])) {\n\t            return true;\n\t        }\n\t    });\n\n\t    // create parser function\n\t    var parseFunc = function (line) {\n\t        var ret = tokenizer.generateTokens(line);\n\t        //print(\"tok:\"+ret);\n\t        if (ret) {\n\t            if (ret !== \"done\") {\n\t                throw new Sk.builtin.SyntaxError(\"incomplete input\", this.filename);\n\t            }\n\t            return p.rootnode;\n\t        }\n\t        return false;\n\t    };\n\n\t    // set flags, and return\n\t    parseFunc.p_flags = p.p_flags;\n\t    return parseFunc;\n\t}\n\n\tSk.parse = function parse (filename, input) {\n\t    var i;\n\t    var ret;\n\t    var lines;\n\t    var parseFunc = makeParser(filename);\n\t    if (input.substr(input.length - 1, 1) !== \"\\n\") {\n\t        input += \"\\n\";\n\t    }\n\t    //print(\"input:\"+input);\n\t    lines = input.split(\"\\n\");\n\t    for (i = 0; i < lines.length; ++i) {\n\t        ret = parseFunc(lines[i] + ((i === lines.length - 1) ? \"\" : \"\\n\"));\n\t    }\n\n\t    /*\n\t     * Small adjustments here in order to return th flags and the cst\n\t     */\n\t    return {\"cst\": ret, \"flags\": parseFunc.p_flags};\n\t};\n\n\tSk.parseTreeDump = function parseTreeDump (n, indent) {\n\t    //return JSON.stringify(n, null, 2);\n\t    var i;\n\t    var ret;\n\t    indent = indent || \"\";\n\t    ret = \"\";\n\t    ret += indent;\n\t    if (n.type >= 256) { // non-term\n\t        ret += Sk.ParseTables.number2symbol[n.type] + \"\\n\";\n\t        for (i = 0; i < n.children.length; ++i) {\n\t            ret += Sk.parseTreeDump(n.children[i], indent + \"  \");\n\t        }\n\t    } else {\n\t        ret += Sk.Tokenizer.tokenNames[n.type] + \": \" + new Sk.builtin.str(n.value)[\"$r\"]().v + \"\\n\";\n\t    }\n\t    return ret;\n\t};\n\n\n\tgoog.exportSymbol(\"Sk.parse\", Sk.parse);\n\tgoog.exportSymbol(\"Sk.parseTreeDump\", Sk.parseTreeDump);\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/gen/astnodes.js ---- */ \n\n\t/* File automatically generated by ./asdl_js.py. */\n\n\t/* ----- expr_context ----- */\n\t/** @constructor */\n\tfunction Load() {}\n\t/** @constructor */\n\tfunction Store() {}\n\t/** @constructor */\n\tfunction Del() {}\n\t/** @constructor */\n\tfunction AugLoad() {}\n\t/** @constructor */\n\tfunction AugStore() {}\n\t/** @constructor */\n\tfunction Param() {}\n\n\t/* ----- boolop ----- */\n\t/** @constructor */\n\tfunction And() {}\n\t/** @constructor */\n\tfunction Or() {}\n\n\t/* ----- operator ----- */\n\t/** @constructor */\n\tfunction Add() {}\n\t/** @constructor */\n\tfunction Sub() {}\n\t/** @constructor */\n\tfunction Mult() {}\n\t/** @constructor */\n\tfunction Div() {}\n\t/** @constructor */\n\tfunction Mod() {}\n\t/** @constructor */\n\tfunction Pow() {}\n\t/** @constructor */\n\tfunction LShift() {}\n\t/** @constructor */\n\tfunction RShift() {}\n\t/** @constructor */\n\tfunction BitOr() {}\n\t/** @constructor */\n\tfunction BitXor() {}\n\t/** @constructor */\n\tfunction BitAnd() {}\n\t/** @constructor */\n\tfunction FloorDiv() {}\n\n\t/* ----- unaryop ----- */\n\t/** @constructor */\n\tfunction Invert() {}\n\t/** @constructor */\n\tfunction Not() {}\n\t/** @constructor */\n\tfunction UAdd() {}\n\t/** @constructor */\n\tfunction USub() {}\n\n\t/* ----- cmpop ----- */\n\t/** @constructor */\n\tfunction Eq() {}\n\t/** @constructor */\n\tfunction NotEq() {}\n\t/** @constructor */\n\tfunction Lt() {}\n\t/** @constructor */\n\tfunction LtE() {}\n\t/** @constructor */\n\tfunction Gt() {}\n\t/** @constructor */\n\tfunction GtE() {}\n\t/** @constructor */\n\tfunction Is() {}\n\t/** @constructor */\n\tfunction IsNot() {}\n\t/** @constructor */\n\tfunction In_() {}\n\t/** @constructor */\n\tfunction NotIn() {}\n\n\n\n\n\n\n\n\t/* ---------------------- */\n\t/* constructors for nodes */\n\t/* ---------------------- */\n\n\n\n\n\n\t/** @constructor */\n\tfunction Module(/* {asdl_seq *} */ body)\n\t{\n\t    this.body = body;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Interactive(/* {asdl_seq *} */ body)\n\t{\n\t    this.body = body;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Expression(/* {expr_ty} */ body)\n\t{\n\t    goog.asserts.assert(body !== null && body !== undefined);\n\t    this.body = body;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Suite(/* {asdl_seq *} */ body)\n\t{\n\t    this.body = body;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction FunctionDef(/* {identifier} */ name, /* {arguments__ty} */ args, /*\n\t                          {asdl_seq *} */ body, /* {asdl_seq *} */\n\t                          decorator_list, /* {int} */ lineno, /* {int} */\n\t                          col_offset)\n\t{\n\t    goog.asserts.assert(name !== null && name !== undefined);\n\t    goog.asserts.assert(args !== null && args !== undefined);\n\t    this.name = name;\n\t    this.args = args;\n\t    this.body = body;\n\t    this.decorator_list = decorator_list;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction ClassDef(/* {identifier} */ name, /* {asdl_seq *} */ bases, /*\n\t                       {asdl_seq *} */ body, /* {asdl_seq *} */ decorator_list,\n\t                       /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(name !== null && name !== undefined);\n\t    this.name = name;\n\t    this.bases = bases;\n\t    this.body = body;\n\t    this.decorator_list = decorator_list;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Return_(/* {expr_ty} */ value, /* {int} */ lineno, /* {int} */\n\t                      col_offset)\n\t{\n\t    this.value = value;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Delete_(/* {asdl_seq *} */ targets, /* {int} */ lineno, /* {int} */\n\t                      col_offset)\n\t{\n\t    this.targets = targets;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Assign(/* {asdl_seq *} */ targets, /* {expr_ty} */ value, /* {int} */\n\t                     lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    this.targets = targets;\n\t    this.value = value;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction AugAssign(/* {expr_ty} */ target, /* {operator_ty} */ op, /* {expr_ty}\n\t                        */ value, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(target !== null && target !== undefined);\n\t    goog.asserts.assert(op !== null && op !== undefined);\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    this.target = target;\n\t    this.op = op;\n\t    this.value = value;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Print(/* {expr_ty} */ dest, /* {asdl_seq *} */ values, /* {bool} */\n\t                    nl, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    this.dest = dest;\n\t    this.values = values;\n\t    this.nl = nl;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction For_(/* {expr_ty} */ target, /* {expr_ty} */ iter, /* {asdl_seq *} */\n\t                   body, /* {asdl_seq *} */ orelse, /* {int} */ lineno, /*\n\t                   {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(target !== null && target !== undefined);\n\t    goog.asserts.assert(iter !== null && iter !== undefined);\n\t    this.target = target;\n\t    this.iter = iter;\n\t    this.body = body;\n\t    this.orelse = orelse;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction While_(/* {expr_ty} */ test, /* {asdl_seq *} */ body, /* {asdl_seq *}\n\t                     */ orelse, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(test !== null && test !== undefined);\n\t    this.test = test;\n\t    this.body = body;\n\t    this.orelse = orelse;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction If_(/* {expr_ty} */ test, /* {asdl_seq *} */ body, /* {asdl_seq *} */\n\t                  orelse, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(test !== null && test !== undefined);\n\t    this.test = test;\n\t    this.body = body;\n\t    this.orelse = orelse;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction With_(/* {expr_ty} */ context_expr, /* {expr_ty} */ optional_vars, /*\n\t                    {asdl_seq *} */ body, /* {int} */ lineno, /* {int} */\n\t                    col_offset)\n\t{\n\t    goog.asserts.assert(context_expr !== null && context_expr !== undefined);\n\t    this.context_expr = context_expr;\n\t    this.optional_vars = optional_vars;\n\t    this.body = body;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Raise(/* {expr_ty} */ type, /* {expr_ty} */ inst, /* {expr_ty} */\n\t                    tback, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    this.type = type;\n\t    this.inst = inst;\n\t    this.tback = tback;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction TryExcept(/* {asdl_seq *} */ body, /* {asdl_seq *} */ handlers, /*\n\t                        {asdl_seq *} */ orelse, /* {int} */ lineno, /* {int} */\n\t                        col_offset)\n\t{\n\t    this.body = body;\n\t    this.handlers = handlers;\n\t    this.orelse = orelse;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction TryFinally(/* {asdl_seq *} */ body, /* {asdl_seq *} */ finalbody, /*\n\t                         {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    this.body = body;\n\t    this.finalbody = finalbody;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Assert(/* {expr_ty} */ test, /* {expr_ty} */ msg, /* {int} */ lineno,\n\t                     /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(test !== null && test !== undefined);\n\t    this.test = test;\n\t    this.msg = msg;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Import_(/* {asdl_seq *} */ names, /* {int} */ lineno, /* {int} */\n\t                      col_offset)\n\t{\n\t    this.names = names;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction ImportFrom(/* {identifier} */ module, /* {asdl_seq *} */ names, /*\n\t                         {int} */ level, /* {int} */ lineno, /* {int} */\n\t                         col_offset)\n\t{\n\t    goog.asserts.assert(module !== null && module !== undefined);\n\t    this.module = module;\n\t    this.names = names;\n\t    this.level = level;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Exec(/* {expr_ty} */ body, /* {expr_ty} */ globals, /* {expr_ty} */\n\t                   locals, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(body !== null && body !== undefined);\n\t    this.body = body;\n\t    this.globals = globals;\n\t    this.locals = locals;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Global(/* {asdl_seq *} */ names, /* {int} */ lineno, /* {int} */\n\t                     col_offset)\n\t{\n\t    this.names = names;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Expr(/* {expr_ty} */ value, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    this.value = value;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Pass(/* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Break_(/* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Continue_(/* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Debugger_(/* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction BoolOp(/* {boolop_ty} */ op, /* {asdl_seq *} */ values, /* {int} */\n\t                     lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(op !== null && op !== undefined);\n\t    this.op = op;\n\t    this.values = values;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction BinOp(/* {expr_ty} */ left, /* {operator_ty} */ op, /* {expr_ty} */\n\t                    right, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(left !== null && left !== undefined);\n\t    goog.asserts.assert(op !== null && op !== undefined);\n\t    goog.asserts.assert(right !== null && right !== undefined);\n\t    this.left = left;\n\t    this.op = op;\n\t    this.right = right;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction UnaryOp(/* {unaryop_ty} */ op, /* {expr_ty} */ operand, /* {int} */\n\t                      lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(op !== null && op !== undefined);\n\t    goog.asserts.assert(operand !== null && operand !== undefined);\n\t    this.op = op;\n\t    this.operand = operand;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Lambda(/* {arguments__ty} */ args, /* {expr_ty} */ body, /* {int} */\n\t                     lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(args !== null && args !== undefined);\n\t    goog.asserts.assert(body !== null && body !== undefined);\n\t    this.args = args;\n\t    this.body = body;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction IfExp(/* {expr_ty} */ test, /* {expr_ty} */ body, /* {expr_ty} */\n\t                    orelse, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(test !== null && test !== undefined);\n\t    goog.asserts.assert(body !== null && body !== undefined);\n\t    goog.asserts.assert(orelse !== null && orelse !== undefined);\n\t    this.test = test;\n\t    this.body = body;\n\t    this.orelse = orelse;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Dict(/* {asdl_seq *} */ keys, /* {asdl_seq *} */ values, /* {int} */\n\t                   lineno, /* {int} */ col_offset)\n\t{\n\t    this.keys = keys;\n\t    this.values = values;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Set(/* {asdl_seq *} */ elts, /* {int} */ lineno, /* {int} */\n\t                  col_offset)\n\t{\n\t    this.elts = elts;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction ListComp(/* {expr_ty} */ elt, /* {asdl_seq *} */ generators, /* {int}\n\t                       */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(elt !== null && elt !== undefined);\n\t    this.elt = elt;\n\t    this.generators = generators;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction SetComp(/* {expr_ty} */ elt, /* {asdl_seq *} */ generators, /* {int}\n\t                      */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(elt !== null && elt !== undefined);\n\t    this.elt = elt;\n\t    this.generators = generators;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction DictComp(/* {expr_ty} */ key, /* {expr_ty} */ value, /* {asdl_seq *}\n\t                       */ generators, /* {int} */ lineno, /* {int} */\n\t                       col_offset)\n\t{\n\t    goog.asserts.assert(key !== null && key !== undefined);\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    this.key = key;\n\t    this.value = value;\n\t    this.generators = generators;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction GeneratorExp(/* {expr_ty} */ elt, /* {asdl_seq *} */ generators, /*\n\t                           {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(elt !== null && elt !== undefined);\n\t    this.elt = elt;\n\t    this.generators = generators;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Yield(/* {expr_ty} */ value, /* {int} */ lineno, /* {int} */\n\t                    col_offset)\n\t{\n\t    this.value = value;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Compare(/* {expr_ty} */ left, /* {asdl_int_seq *} */ ops, /* {asdl_seq\n\t                      *} */ comparators, /* {int} */ lineno, /* {int} */\n\t                      col_offset)\n\t{\n\t    goog.asserts.assert(left !== null && left !== undefined);\n\t    this.left = left;\n\t    this.ops = ops;\n\t    this.comparators = comparators;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Call(/* {expr_ty} */ func, /* {asdl_seq *} */ args, /* {asdl_seq *} */\n\t                   keywords, /* {expr_ty} */ starargs, /* {expr_ty} */ kwargs,\n\t                   /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(func !== null && func !== undefined);\n\t    this.func = func;\n\t    this.args = args;\n\t    this.keywords = keywords;\n\t    this.starargs = starargs;\n\t    this.kwargs = kwargs;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Repr(/* {expr_ty} */ value, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    this.value = value;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Num(/* {object} */ n, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(n !== null && n !== undefined);\n\t    this.n = n;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Str(/* {string} */ s, /* {int} */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(s !== null && s !== undefined);\n\t    this.s = s;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Attribute(/* {expr_ty} */ value, /* {identifier} */ attr, /*\n\t                        {expr_context_ty} */ ctx, /* {int} */ lineno, /* {int}\n\t                        */ col_offset)\n\t{\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    goog.asserts.assert(attr !== null && attr !== undefined);\n\t    goog.asserts.assert(ctx !== null && ctx !== undefined);\n\t    this.value = value;\n\t    this.attr = attr;\n\t    this.ctx = ctx;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Subscript(/* {expr_ty} */ value, /* {slice_ty} */ slice, /*\n\t                        {expr_context_ty} */ ctx, /* {int} */ lineno, /* {int}\n\t                        */ col_offset)\n\t{\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    goog.asserts.assert(slice !== null && slice !== undefined);\n\t    goog.asserts.assert(ctx !== null && ctx !== undefined);\n\t    this.value = value;\n\t    this.slice = slice;\n\t    this.ctx = ctx;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Name(/* {identifier} */ id, /* {expr_context_ty} */ ctx, /* {int} */\n\t                   lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(id !== null && id !== undefined);\n\t    goog.asserts.assert(ctx !== null && ctx !== undefined);\n\t    this.id = id;\n\t    this.ctx = ctx;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction List(/* {asdl_seq *} */ elts, /* {expr_context_ty} */ ctx, /* {int} */\n\t                   lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(ctx !== null && ctx !== undefined);\n\t    this.elts = elts;\n\t    this.ctx = ctx;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Tuple(/* {asdl_seq *} */ elts, /* {expr_context_ty} */ ctx, /* {int}\n\t                    */ lineno, /* {int} */ col_offset)\n\t{\n\t    goog.asserts.assert(ctx !== null && ctx !== undefined);\n\t    this.elts = elts;\n\t    this.ctx = ctx;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Ellipsis()\n\t{\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Slice(/* {expr_ty} */ lower, /* {expr_ty} */ upper, /* {expr_ty} */\n\t                    step)\n\t{\n\t    this.lower = lower;\n\t    this.upper = upper;\n\t    this.step = step;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction ExtSlice(/* {asdl_seq *} */ dims)\n\t{\n\t    this.dims = dims;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction Index(/* {expr_ty} */ value)\n\t{\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    this.value = value;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction comprehension(/* {expr_ty} */ target, /* {expr_ty} */ iter, /*\n\t                            {asdl_seq *} */ ifs)\n\t{\n\t    goog.asserts.assert(target !== null && target !== undefined);\n\t    goog.asserts.assert(iter !== null && iter !== undefined);\n\t    this.target = target;\n\t    this.iter = iter;\n\t    this.ifs = ifs;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction ExceptHandler(/* {expr_ty} */ type, /* {expr_ty} */ name, /* {asdl_seq\n\t                            *} */ body, /* {int} */ lineno, /* {int} */\n\t                            col_offset)\n\t{\n\t    this.type = type;\n\t    this.name = name;\n\t    this.body = body;\n\t    this.lineno = lineno;\n\t    this.col_offset = col_offset;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction arguments_(/* {asdl_seq *} */ args, /* {identifier} */ vararg, /*\n\t                         {identifier} */ kwarg, /* {asdl_seq *} */ defaults)\n\t{\n\t    this.args = args;\n\t    this.vararg = vararg;\n\t    this.kwarg = kwarg;\n\t    this.defaults = defaults;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction keyword(/* {identifier} */ arg, /* {expr_ty} */ value)\n\t{\n\t    goog.asserts.assert(arg !== null && arg !== undefined);\n\t    goog.asserts.assert(value !== null && value !== undefined);\n\t    this.arg = arg;\n\t    this.value = value;\n\t    return this;\n\t}\n\n\t/** @constructor */\n\tfunction alias(/* {identifier} */ name, /* {identifier} */ asname)\n\t{\n\t    goog.asserts.assert(name !== null && name !== undefined);\n\t    this.name = name;\n\t    this.asname = asname;\n\t    return this;\n\t}\n\n\n\tModule.prototype._astname = \"Module\";\n\tModule.prototype._fields = [\n\t    \"body\", function(n) { return n.body; }\n\t];\n\tInteractive.prototype._astname = \"Interactive\";\n\tInteractive.prototype._fields = [\n\t    \"body\", function(n) { return n.body; }\n\t];\n\tExpression.prototype._astname = \"Expression\";\n\tExpression.prototype._fields = [\n\t    \"body\", function(n) { return n.body; }\n\t];\n\tSuite.prototype._astname = \"Suite\";\n\tSuite.prototype._fields = [\n\t    \"body\", function(n) { return n.body; }\n\t];\n\tFunctionDef.prototype._astname = \"FunctionDef\";\n\tFunctionDef.prototype._fields = [\n\t    \"name\", function(n) { return n.name; },\n\t    \"args\", function(n) { return n.args; },\n\t    \"body\", function(n) { return n.body; },\n\t    \"decorator_list\", function(n) { return n.decorator_list; }\n\t];\n\tClassDef.prototype._astname = \"ClassDef\";\n\tClassDef.prototype._fields = [\n\t    \"name\", function(n) { return n.name; },\n\t    \"bases\", function(n) { return n.bases; },\n\t    \"body\", function(n) { return n.body; },\n\t    \"decorator_list\", function(n) { return n.decorator_list; }\n\t];\n\tReturn_.prototype._astname = \"Return\";\n\tReturn_.prototype._fields = [\n\t    \"value\", function(n) { return n.value; }\n\t];\n\tDelete_.prototype._astname = \"Delete\";\n\tDelete_.prototype._fields = [\n\t    \"targets\", function(n) { return n.targets; }\n\t];\n\tAssign.prototype._astname = \"Assign\";\n\tAssign.prototype._fields = [\n\t    \"targets\", function(n) { return n.targets; },\n\t    \"value\", function(n) { return n.value; }\n\t];\n\tAugAssign.prototype._astname = \"AugAssign\";\n\tAugAssign.prototype._fields = [\n\t    \"target\", function(n) { return n.target; },\n\t    \"op\", function(n) { return n.op; },\n\t    \"value\", function(n) { return n.value; }\n\t];\n\tPrint.prototype._astname = \"Print\";\n\tPrint.prototype._fields = [\n\t    \"dest\", function(n) { return n.dest; },\n\t    \"values\", function(n) { return n.values; },\n\t    \"nl\", function(n) { return n.nl; }\n\t];\n\tFor_.prototype._astname = \"For\";\n\tFor_.prototype._fields = [\n\t    \"target\", function(n) { return n.target; },\n\t    \"iter\", function(n) { return n.iter; },\n\t    \"body\", function(n) { return n.body; },\n\t    \"orelse\", function(n) { return n.orelse; }\n\t];\n\tWhile_.prototype._astname = \"While\";\n\tWhile_.prototype._fields = [\n\t    \"test\", function(n) { return n.test; },\n\t    \"body\", function(n) { return n.body; },\n\t    \"orelse\", function(n) { return n.orelse; }\n\t];\n\tIf_.prototype._astname = \"If\";\n\tIf_.prototype._fields = [\n\t    \"test\", function(n) { return n.test; },\n\t    \"body\", function(n) { return n.body; },\n\t    \"orelse\", function(n) { return n.orelse; }\n\t];\n\tWith_.prototype._astname = \"With\";\n\tWith_.prototype._fields = [\n\t    \"context_expr\", function(n) { return n.context_expr; },\n\t    \"optional_vars\", function(n) { return n.optional_vars; },\n\t    \"body\", function(n) { return n.body; }\n\t];\n\tRaise.prototype._astname = \"Raise\";\n\tRaise.prototype._fields = [\n\t    \"type\", function(n) { return n.type; },\n\t    \"inst\", function(n) { return n.inst; },\n\t    \"tback\", function(n) { return n.tback; }\n\t];\n\tTryExcept.prototype._astname = \"TryExcept\";\n\tTryExcept.prototype._fields = [\n\t    \"body\", function(n) { return n.body; },\n\t    \"handlers\", function(n) { return n.handlers; },\n\t    \"orelse\", function(n) { return n.orelse; }\n\t];\n\tTryFinally.prototype._astname = \"TryFinally\";\n\tTryFinally.prototype._fields = [\n\t    \"body\", function(n) { return n.body; },\n\t    \"finalbody\", function(n) { return n.finalbody; }\n\t];\n\tAssert.prototype._astname = \"Assert\";\n\tAssert.prototype._fields = [\n\t    \"test\", function(n) { return n.test; },\n\t    \"msg\", function(n) { return n.msg; }\n\t];\n\tImport_.prototype._astname = \"Import\";\n\tImport_.prototype._fields = [\n\t    \"names\", function(n) { return n.names; }\n\t];\n\tImportFrom.prototype._astname = \"ImportFrom\";\n\tImportFrom.prototype._fields = [\n\t    \"module\", function(n) { return n.module; },\n\t    \"names\", function(n) { return n.names; },\n\t    \"level\", function(n) { return n.level; }\n\t];\n\tExec.prototype._astname = \"Exec\";\n\tExec.prototype._fields = [\n\t    \"body\", function(n) { return n.body; },\n\t    \"globals\", function(n) { return n.globals; },\n\t    \"locals\", function(n) { return n.locals; }\n\t];\n\tGlobal.prototype._astname = \"Global\";\n\tGlobal.prototype._fields = [\n\t    \"names\", function(n) { return n.names; }\n\t];\n\tExpr.prototype._astname = \"Expr\";\n\tExpr.prototype._fields = [\n\t    \"value\", function(n) { return n.value; }\n\t];\n\tPass.prototype._astname = \"Pass\";\n\tPass.prototype._fields = [\n\t];\n\tBreak_.prototype._astname = \"Break\";\n\tBreak_.prototype._fields = [\n\t];\n\tContinue_.prototype._astname = \"Continue\";\n\tContinue_.prototype._fields = [\n\t];\n\tDebugger_.prototype._astname = \"Debugger\";\n\tDebugger_.prototype._fields = [\n\t];\n\tBoolOp.prototype._astname = \"BoolOp\";\n\tBoolOp.prototype._fields = [\n\t    \"op\", function(n) { return n.op; },\n\t    \"values\", function(n) { return n.values; }\n\t];\n\tBinOp.prototype._astname = \"BinOp\";\n\tBinOp.prototype._fields = [\n\t    \"left\", function(n) { return n.left; },\n\t    \"op\", function(n) { return n.op; },\n\t    \"right\", function(n) { return n.right; }\n\t];\n\tUnaryOp.prototype._astname = \"UnaryOp\";\n\tUnaryOp.prototype._fields = [\n\t    \"op\", function(n) { return n.op; },\n\t    \"operand\", function(n) { return n.operand; }\n\t];\n\tLambda.prototype._astname = \"Lambda\";\n\tLambda.prototype._fields = [\n\t    \"args\", function(n) { return n.args; },\n\t    \"body\", function(n) { return n.body; }\n\t];\n\tIfExp.prototype._astname = \"IfExp\";\n\tIfExp.prototype._fields = [\n\t    \"test\", function(n) { return n.test; },\n\t    \"body\", function(n) { return n.body; },\n\t    \"orelse\", function(n) { return n.orelse; }\n\t];\n\tDict.prototype._astname = \"Dict\";\n\tDict.prototype._fields = [\n\t    \"keys\", function(n) { return n.keys; },\n\t    \"values\", function(n) { return n.values; }\n\t];\n\tSet.prototype._astname = \"Set\";\n\tSet.prototype._fields = [\n\t    \"elts\", function(n) { return n.elts; }\n\t];\n\tListComp.prototype._astname = \"ListComp\";\n\tListComp.prototype._fields = [\n\t    \"elt\", function(n) { return n.elt; },\n\t    \"generators\", function(n) { return n.generators; }\n\t];\n\tSetComp.prototype._astname = \"SetComp\";\n\tSetComp.prototype._fields = [\n\t    \"elt\", function(n) { return n.elt; },\n\t    \"generators\", function(n) { return n.generators; }\n\t];\n\tDictComp.prototype._astname = \"DictComp\";\n\tDictComp.prototype._fields = [\n\t    \"key\", function(n) { return n.key; },\n\t    \"value\", function(n) { return n.value; },\n\t    \"generators\", function(n) { return n.generators; }\n\t];\n\tGeneratorExp.prototype._astname = \"GeneratorExp\";\n\tGeneratorExp.prototype._fields = [\n\t    \"elt\", function(n) { return n.elt; },\n\t    \"generators\", function(n) { return n.generators; }\n\t];\n\tYield.prototype._astname = \"Yield\";\n\tYield.prototype._fields = [\n\t    \"value\", function(n) { return n.value; }\n\t];\n\tCompare.prototype._astname = \"Compare\";\n\tCompare.prototype._fields = [\n\t    \"left\", function(n) { return n.left; },\n\t    \"ops\", function(n) { return n.ops; },\n\t    \"comparators\", function(n) { return n.comparators; }\n\t];\n\tCall.prototype._astname = \"Call\";\n\tCall.prototype._fields = [\n\t    \"func\", function(n) { return n.func; },\n\t    \"args\", function(n) { return n.args; },\n\t    \"keywords\", function(n) { return n.keywords; },\n\t    \"starargs\", function(n) { return n.starargs; },\n\t    \"kwargs\", function(n) { return n.kwargs; }\n\t];\n\tRepr.prototype._astname = \"Repr\";\n\tRepr.prototype._fields = [\n\t    \"value\", function(n) { return n.value; }\n\t];\n\tNum.prototype._astname = \"Num\";\n\tNum.prototype._fields = [\n\t    \"n\", function(n) { return n.n; }\n\t];\n\tStr.prototype._astname = \"Str\";\n\tStr.prototype._fields = [\n\t    \"s\", function(n) { return n.s; }\n\t];\n\tAttribute.prototype._astname = \"Attribute\";\n\tAttribute.prototype._fields = [\n\t    \"value\", function(n) { return n.value; },\n\t    \"attr\", function(n) { return n.attr; },\n\t    \"ctx\", function(n) { return n.ctx; }\n\t];\n\tSubscript.prototype._astname = \"Subscript\";\n\tSubscript.prototype._fields = [\n\t    \"value\", function(n) { return n.value; },\n\t    \"slice\", function(n) { return n.slice; },\n\t    \"ctx\", function(n) { return n.ctx; }\n\t];\n\tName.prototype._astname = \"Name\";\n\tName.prototype._fields = [\n\t    \"id\", function(n) { return n.id; },\n\t    \"ctx\", function(n) { return n.ctx; }\n\t];\n\tList.prototype._astname = \"List\";\n\tList.prototype._fields = [\n\t    \"elts\", function(n) { return n.elts; },\n\t    \"ctx\", function(n) { return n.ctx; }\n\t];\n\tTuple.prototype._astname = \"Tuple\";\n\tTuple.prototype._fields = [\n\t    \"elts\", function(n) { return n.elts; },\n\t    \"ctx\", function(n) { return n.ctx; }\n\t];\n\tLoad.prototype._astname = \"Load\";\n\tLoad.prototype._isenum = true;\n\tStore.prototype._astname = \"Store\";\n\tStore.prototype._isenum = true;\n\tDel.prototype._astname = \"Del\";\n\tDel.prototype._isenum = true;\n\tAugLoad.prototype._astname = \"AugLoad\";\n\tAugLoad.prototype._isenum = true;\n\tAugStore.prototype._astname = \"AugStore\";\n\tAugStore.prototype._isenum = true;\n\tParam.prototype._astname = \"Param\";\n\tParam.prototype._isenum = true;\n\tEllipsis.prototype._astname = \"Ellipsis\";\n\tEllipsis.prototype._fields = [\n\t];\n\tSlice.prototype._astname = \"Slice\";\n\tSlice.prototype._fields = [\n\t    \"lower\", function(n) { return n.lower; },\n\t    \"upper\", function(n) { return n.upper; },\n\t    \"step\", function(n) { return n.step; }\n\t];\n\tExtSlice.prototype._astname = \"ExtSlice\";\n\tExtSlice.prototype._fields = [\n\t    \"dims\", function(n) { return n.dims; }\n\t];\n\tIndex.prototype._astname = \"Index\";\n\tIndex.prototype._fields = [\n\t    \"value\", function(n) { return n.value; }\n\t];\n\tAnd.prototype._astname = \"And\";\n\tAnd.prototype._isenum = true;\n\tOr.prototype._astname = \"Or\";\n\tOr.prototype._isenum = true;\n\tAdd.prototype._astname = \"Add\";\n\tAdd.prototype._isenum = true;\n\tSub.prototype._astname = \"Sub\";\n\tSub.prototype._isenum = true;\n\tMult.prototype._astname = \"Mult\";\n\tMult.prototype._isenum = true;\n\tDiv.prototype._astname = \"Div\";\n\tDiv.prototype._isenum = true;\n\tMod.prototype._astname = \"Mod\";\n\tMod.prototype._isenum = true;\n\tPow.prototype._astname = \"Pow\";\n\tPow.prototype._isenum = true;\n\tLShift.prototype._astname = \"LShift\";\n\tLShift.prototype._isenum = true;\n\tRShift.prototype._astname = \"RShift\";\n\tRShift.prototype._isenum = true;\n\tBitOr.prototype._astname = \"BitOr\";\n\tBitOr.prototype._isenum = true;\n\tBitXor.prototype._astname = \"BitXor\";\n\tBitXor.prototype._isenum = true;\n\tBitAnd.prototype._astname = \"BitAnd\";\n\tBitAnd.prototype._isenum = true;\n\tFloorDiv.prototype._astname = \"FloorDiv\";\n\tFloorDiv.prototype._isenum = true;\n\tInvert.prototype._astname = \"Invert\";\n\tInvert.prototype._isenum = true;\n\tNot.prototype._astname = \"Not\";\n\tNot.prototype._isenum = true;\n\tUAdd.prototype._astname = \"UAdd\";\n\tUAdd.prototype._isenum = true;\n\tUSub.prototype._astname = \"USub\";\n\tUSub.prototype._isenum = true;\n\tEq.prototype._astname = \"Eq\";\n\tEq.prototype._isenum = true;\n\tNotEq.prototype._astname = \"NotEq\";\n\tNotEq.prototype._isenum = true;\n\tLt.prototype._astname = \"Lt\";\n\tLt.prototype._isenum = true;\n\tLtE.prototype._astname = \"LtE\";\n\tLtE.prototype._isenum = true;\n\tGt.prototype._astname = \"Gt\";\n\tGt.prototype._isenum = true;\n\tGtE.prototype._astname = \"GtE\";\n\tGtE.prototype._isenum = true;\n\tIs.prototype._astname = \"Is\";\n\tIs.prototype._isenum = true;\n\tIsNot.prototype._astname = \"IsNot\";\n\tIsNot.prototype._isenum = true;\n\tIn_.prototype._astname = \"In\";\n\tIn_.prototype._isenum = true;\n\tNotIn.prototype._astname = \"NotIn\";\n\tNotIn.prototype._isenum = true;\n\tcomprehension.prototype._astname = \"comprehension\";\n\tcomprehension.prototype._fields = [\n\t    \"target\", function(n) { return n.target; },\n\t    \"iter\", function(n) { return n.iter; },\n\t    \"ifs\", function(n) { return n.ifs; }\n\t];\n\tExceptHandler.prototype._astname = \"ExceptHandler\";\n\tExceptHandler.prototype._fields = [\n\t    \"type\", function(n) { return n.type; },\n\t    \"name\", function(n) { return n.name; },\n\t    \"body\", function(n) { return n.body; }\n\t];\n\targuments_.prototype._astname = \"arguments\";\n\targuments_.prototype._fields = [\n\t    \"args\", function(n) { return n.args; },\n\t    \"vararg\", function(n) { return n.vararg; },\n\t    \"kwarg\", function(n) { return n.kwarg; },\n\t    \"defaults\", function(n) { return n.defaults; }\n\t];\n\tkeyword.prototype._astname = \"keyword\";\n\tkeyword.prototype._fields = [\n\t    \"arg\", function(n) { return n.arg; },\n\t    \"value\", function(n) { return n.value; }\n\t];\n\talias.prototype._astname = \"alias\";\n\talias.prototype._fields = [\n\t    \"name\", function(n) { return n.name; },\n\t    \"asname\", function(n) { return n.asname; }\n\t];\n\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/../node_modules/skulpt/src/ast.js ---- */ \n\n\t//\n\t// This is pretty much a straight port of ast.c from CPython 2.6.5.\n\t//\n\t// The previous version was easier to work with and more JS-ish, but having a\n\t// somewhat different ast structure than cpython makes testing more difficult.\n\t//\n\t// This way, we can use a dump from the ast module on any arbitrary python\n\t// code and know that we're the same up to ast level, at least.\n\t//\n\n\tvar SYM = Sk.ParseTables.sym;\n\tvar TOK = Sk.Tokenizer.Tokens;\n\tvar COMP_GENEXP = 0;\n\tvar COMP_SETCOMP = 1;\n\n\t/** @constructor */\n\tfunction Compiling (encoding, filename, c_flags) {\n\t    this.c_encoding = encoding;\n\t    this.c_filename = filename;\n\t    this.c_flags = c_flags || 0;\n\t}\n\n\t/**\n\t * @return {number}\n\t */\n\tfunction NCH (n) {\n\t    goog.asserts.assert(n !== undefined);\n\t    if (n.children === null) {\n\t        return 0;\n\t    }\n\t    return n.children.length;\n\t}\n\n\tfunction CHILD (n, i) {\n\t    goog.asserts.assert(n !== undefined);\n\t    goog.asserts.assert(i !== undefined);\n\t    return n.children[i];\n\t}\n\n\tfunction REQ (n, type) {\n\t    goog.asserts.assert(n.type === type, \"node wasn't expected type\");\n\t}\n\n\tfunction strobj (s) {\n\t    goog.asserts.assert(typeof s === \"string\", \"expecting string, got \" + (typeof s));\n\t    return new Sk.builtin.str(s);\n\t}\n\n\t/** @return {number} */\n\tfunction numStmts (n) {\n\t    var ch;\n\t    var i;\n\t    var cnt;\n\t    switch (n.type) {\n\t        case SYM.single_input:\n\t            if (CHILD(n, 0).type === TOK.T_NEWLINE) {\n\t                return 0;\n\t            }\n\t            else {\n\t                return numStmts(CHILD(n, 0));\n\t            }\n\t        case SYM.file_input:\n\t            cnt = 0;\n\t            for (i = 0; i < NCH(n); ++i) {\n\t                ch = CHILD(n, i);\n\t                if (ch.type === SYM.stmt) {\n\t                    cnt += numStmts(ch);\n\t                }\n\t            }\n\t            return cnt;\n\t        case SYM.stmt:\n\t            return numStmts(CHILD(n, 0));\n\t        case SYM.compound_stmt:\n\t            return 1;\n\t        case SYM.simple_stmt:\n\t            return Math.floor(NCH(n) / 2); // div 2 is to remove count of ;s\n\t        case SYM.suite:\n\t            if (NCH(n) === 1) {\n\t                return numStmts(CHILD(n, 0));\n\t            }\n\t            else {\n\t                cnt = 0;\n\t                for (i = 2; i < NCH(n) - 1; ++i) {\n\t                    cnt += numStmts(CHILD(n, i));\n\t                }\n\t                return cnt;\n\t            }\n\t            break;\n\t        default:\n\t            goog.asserts.fail(\"Non-statement found\");\n\t    }\n\t    return 0;\n\t}\n\n\tfunction forbiddenCheck (c, n, x, lineno) {\n\t    if (x === \"None\") {\n\t        throw new Sk.builtin.SyntaxError(\"assignment to None\", c.c_filename, lineno, [], {node: n});\n\t    }\n\t    if (x === \"True\" || x === \"False\") {\n\t        throw new Sk.builtin.SyntaxError(\"assignment to True or False is forbidden\", c.c_filename, lineno, [], {node: n});\n\t    }\n\t}\n\n\t/**\n\t * Set the context ctx for e, recursively traversing e.\n\t *\n\t * Only sets context for expr kinds that can appear in assignment context as\n\t * per the asdl file.\n\t */\n\tfunction setContext (c, e, ctx, n) {\n\t    var i;\n\t    var exprName;\n\t    var s;\n\t    goog.asserts.assert(ctx !== AugStore && ctx !== AugLoad);\n\t    s = null;\n\t    exprName = null;\n\n\t    switch (e.constructor) {\n\t        case Attribute:\n\t        case Name:\n\t            if (ctx === Store) {\n\t                forbiddenCheck(c, n, e.attr, n.lineno);\n\t            }\n\t            e.ctx = ctx;\n\t            break;\n\t        case Subscript:\n\t            e.ctx = ctx;\n\t            break;\n\t        case List:\n\t            e.ctx = ctx;\n\t            s = e.elts;\n\t            break;\n\t        case Tuple:\n\t            if (e.elts.length === 0) {\n\t                throw new Sk.builtin.SyntaxError(\"can't assign to ()\", c.c_filename, n.lineno, ctx, {node: n});\n\t            }\n\t            e.ctx = ctx;\n\t            s = e.elts;\n\t            break;\n\t        case Lambda:\n\t            exprName = \"lambda\";\n\t            break;\n\t        case Call:\n\t            exprName = \"function call\";\n\t            break;\n\t        case BoolOp:\n\t        case BinOp:\n\t        case UnaryOp:\n\t            exprName = \"operator\";\n\t            break;\n\t        case GeneratorExp:\n\t            exprName = \"generator expression\";\n\t            break;\n\t        case Yield:\n\t            exprName = \"yield expression\";\n\t            break;\n\t        case ListComp:\n\t            exprName = \"list comprehension\";\n\t            break;\n\t        case SetComp:\n\t            exprName = \"set comprehension\";\n\t            break;\n\t        case DictComp:\n\t            exprName = \"dict comprehension\";\n\t            break;\n\t        case Dict:\n\t        case Set:\n\t        case Num:\n\t        case Str:\n\t            exprName = \"literal\";\n\t            break;\n\t        case Compare:\n\t            exprName = \"comparison\";\n\t            break;\n\t        case Repr:\n\t            exprName = \"repr\";\n\t            break;\n\t        case IfExp:\n\t            exprName = \"conditional expression\";\n\t            break;\n\t        default:\n\t            goog.asserts.fail(\"unhandled expression in assignment\");\n\t    }\n\t    if (exprName) {\n\t        throw new Sk.builtin.SyntaxError(\"can't \" + (ctx === Store ? \"assign to\" : \"delete\") + \" \" + exprName, c.c_filename, n.lineno, [], {node: n});\n\t    }\n\n\t    if (s) {\n\t        for (i = 0; i < s.length; ++i) {\n\t            setContext(c, s[i], ctx, n);\n\t        }\n\t    }\n\t}\n\n\tvar operatorMap = {};\n\t(function () {\n\t    operatorMap[TOK.T_VBAR] = BitOr;\n\t    operatorMap[TOK.T_CIRCUMFLEX] = BitXor;\n\t    operatorMap[TOK.T_AMPER] = BitAnd;\n\t    operatorMap[TOK.T_LEFTSHIFT] = LShift;\n\t    operatorMap[TOK.T_RIGHTSHIFT] = RShift;\n\t    operatorMap[TOK.T_PLUS] = Add;\n\t    operatorMap[TOK.T_MINUS] = Sub;\n\t    operatorMap[TOK.T_STAR] = Mult;\n\t    operatorMap[TOK.T_SLASH] = Div;\n\t    operatorMap[TOK.T_DOUBLESLASH] = FloorDiv;\n\t    operatorMap[TOK.T_PERCENT] = Mod;\n\t}());\n\n\tfunction getOperator (n) {\n\t    goog.asserts.assert(operatorMap[n.type] !== undefined);\n\t    return operatorMap[n.type];\n\t}\n\n\tfunction astForCompOp (c, n) {\n\t    /* comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'\n\t     |'is' 'not'\n\t     */\n\t    REQ(n, SYM.comp_op);\n\t    if (NCH(n) === 1) {\n\t        n = CHILD(n, 0);\n\t        switch (n.type) {\n\t            case TOK.T_LESS:\n\t                return Lt;\n\t            case TOK.T_GREATER:\n\t                return Gt;\n\t            case TOK.T_EQEQUAL:\n\t                return Eq;\n\t            case TOK.T_LESSEQUAL:\n\t                return LtE;\n\t            case TOK.T_GREATEREQUAL:\n\t                return GtE;\n\t            case TOK.T_NOTEQUAL:\n\t                return NotEq;\n\t            case TOK.T_NAME:\n\t                if (n.value === \"in\") {\n\t                    return In_;\n\t                }\n\t                if (n.value === \"is\") {\n\t                    return Is;\n\t                }\n\t        }\n\t    }\n\t    else if (NCH(n) === 2) {\n\t        if (CHILD(n, 0).type === TOK.T_NAME) {\n\t            if (CHILD(n, 1).value === \"in\") {\n\t                return NotIn;\n\t            }\n\t            if (CHILD(n, 0).value === \"is\") {\n\t                return IsNot;\n\t            }\n\t        }\n\t    }\n\t    goog.asserts.fail(\"invalid comp_op\");\n\t}\n\n\tfunction seqForTestlist (c, n) {\n\t    /* testlist: test (',' test)* [','] */\n\t    var i;\n\t    var seq = [];\n\t    goog.asserts.assert(n.type === SYM.testlist ||\n\t        n.type === SYM.listmaker ||\n\t        n.type === SYM.testlist_comp ||\n\t        n.type === SYM.testlist_safe ||\n\t        n.type === SYM.testlist1);\n\t    for (i = 0; i < NCH(n); i += 2) {\n\t        goog.asserts.assert(CHILD(n, i).type === SYM.test || CHILD(n, i).type === SYM.old_test);\n\t        seq[i / 2] = astForExpr(c, CHILD(n, i));\n\t    }\n\t    return seq;\n\t}\n\n\tfunction astForSuite (c, n) {\n\t    /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */\n\t    var j;\n\t    var num;\n\t    var i;\n\t    var end;\n\t    var ch;\n\t    var pos;\n\t    var seq;\n\t    REQ(n, SYM.suite);\n\t    seq = [];\n\t    pos = 0;\n\t    if (CHILD(n, 0).type === SYM.simple_stmt) {\n\t        n = CHILD(n, 0);\n\t        /* simple_stmt always ends with an NEWLINE and may have a trailing\n\t         * SEMI. */\n\t        end = NCH(n) - 1;\n\t        if (CHILD(n, end - 1).type === TOK.T_SEMI) {\n\t            end -= 1;\n\t        }\n\t        for (i = 0; i < end; i += 2) // by 2 to skip ;\n\t        {\n\t            seq[pos++] = astForStmt(c, CHILD(n, i));\n\t        }\n\t    }\n\t    else {\n\t        for (i = 2; i < NCH(n) - 1; ++i) {\n\t            ch = CHILD(n, i);\n\t            REQ(ch, SYM.stmt);\n\t            num = numStmts(ch);\n\t            if (num === 1) {\n\t                // small_stmt or compound_stmt w/ only 1 child\n\t                seq[pos++] = astForStmt(c, ch);\n\t            }\n\t            else {\n\t                ch = CHILD(ch, 0);\n\t                REQ(ch, SYM.simple_stmt);\n\t                for (j = 0; j < NCH(ch); j += 2) {\n\t                    if (NCH(CHILD(ch, j)) === 0) {\n\t                        goog.asserts.assert(j + 1 === NCH(ch));\n\t                        break;\n\t                    }\n\t                    seq[pos++] = astForStmt(c, CHILD(ch, j));\n\t                }\n\t            }\n\t        }\n\t    }\n\t    goog.asserts.assert(pos === numStmts(n));\n\t    return seq;\n\t}\n\n\tfunction astForExceptClause (c, exc, body) {\n\t    /* except_clause: 'except' [test [(',' | 'as') test]] */\n\t    var e;\n\t    REQ(exc, SYM.except_clause);\n\t    REQ(body, SYM.suite);\n\t    if (NCH(exc) === 1) {\n\t        return new ExceptHandler(null, null, astForSuite(c, body), exc.lineno, exc.col_offset);\n\t    }\n\t    else if (NCH(exc) === 2) {\n\t        return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), null, astForSuite(c, body), exc.lineno, exc.col_offset);\n\t    }\n\t    else if (NCH(exc) === 4) {\n\t        e = astForExpr(c, CHILD(exc, 3));\n\t        setContext(c, e, Store, CHILD(exc, 3));\n\t        return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), e, astForSuite(c, body), exc.lineno, exc.col_offset);\n\t    }\n\t    goog.asserts.fail(\"wrong number of children for except clause\");\n\t}\n\n\tfunction astForTryStmt (c, n) {\n\t    var exceptSt;\n\t    var i;\n\t    var handlers;\n\t    var nc = NCH(n);\n\t    var nexcept = (nc - 3) / 3;\n\t    var body, orelse = [],\n\t        finally_ = null;\n\n\t    REQ(n, SYM.try_stmt);\n\t    body = astForSuite(c, CHILD(n, 2));\n\t    if (CHILD(n, nc - 3).type === TOK.T_NAME) {\n\t        if (CHILD(n, nc - 3).value === \"finally\") {\n\t            if (nc >= 9 && CHILD(n, nc - 6).type === TOK.T_NAME) {\n\t                /* we can assume it's an \"else\",\n\t                 because nc >= 9 for try-else-finally and\n\t                 it would otherwise have a type of except_clause */\n\t                orelse = astForSuite(c, CHILD(n, nc - 4));\n\t                nexcept--;\n\t            }\n\n\t            finally_ = astForSuite(c, CHILD(n, nc - 1));\n\t            nexcept--;\n\t        }\n\t        else {\n\t            /* we can assume it's an \"else\",\n\t             otherwise it would have a type of except_clause */\n\t            orelse = astForSuite(c, CHILD(n, nc - 1));\n\t            nexcept--;\n\t        }\n\t    }\n\t    else if (CHILD(n, nc - 3).type !== SYM.except_clause) {\n\t        throw new Sk.builtin.SyntaxError(\"malformed 'try' statement\", c.c_filename, n.lineno);\n\t    }\n\n\t    if (nexcept > 0) {\n\t        handlers = [];\n\t        for (i = 0; i < nexcept; ++i) {\n\t            handlers[i] = astForExceptClause(c, CHILD(n, 3 + i * 3), CHILD(n, 5 + i * 3));\n\t        }\n\t        exceptSt = new TryExcept(body, handlers, orelse, n.lineno, n.col_offset);\n\n\t        if (!finally_) {\n\t            return exceptSt;\n\t        }\n\n\t        /* if a 'finally' is present too, we nest the TryExcept within a\n\t         TryFinally to emulate try ... except ... finally */\n\t        body = [exceptSt];\n\t    }\n\n\t    goog.asserts.assert(finally_ !== null);\n\t    return new TryFinally(body, finally_, n.lineno, n.col_offset);\n\t}\n\n\n\tfunction astForDottedName (c, n) {\n\t    var i;\n\t    var e;\n\t    var id;\n\t    var col_offset;\n\t    var lineno;\n\t    REQ(n, SYM.dotted_name);\n\t    lineno = n.lineno;\n\t    col_offset = n.col_offset;\n\t    id = strobj(CHILD(n, 0).value);\n\t    e = new Name(id, Load, lineno, col_offset);\n\t    for (i = 2; i < NCH(n); i += 2) {\n\t        id = strobj(CHILD(n, i).value);\n\t        e = new Attribute(e, id, Load, lineno, col_offset);\n\t    }\n\t    return e;\n\t}\n\n\tfunction astForDecorator (c, n) {\n\t    /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */\n\t    var nameExpr;\n\t    REQ(n, SYM.decorator);\n\t    REQ(CHILD(n, 0), TOK.T_AT);\n\t    REQ(CHILD(n, NCH(n) - 1), TOK.T_NEWLINE);\n\t    nameExpr = astForDottedName(c, CHILD(n, 1));\n\t    if (NCH(n) === 3) // no args\n\t    {\n\t        return nameExpr;\n\t    }\n\t    else if (NCH(n) === 5) // call with no args\n\t    {\n\t        return new Call(nameExpr, [], [], null, null, n.lineno, n.col_offset);\n\t    }\n\t    else {\n\t        return astForCall(c, CHILD(n, 3), nameExpr);\n\t    }\n\t}\n\n\tfunction astForDecorators (c, n) {\n\t    var i;\n\t    var decoratorSeq;\n\t    REQ(n, SYM.decorators);\n\t    decoratorSeq = [];\n\t    for (i = 0; i < NCH(n); ++i) {\n\t        decoratorSeq[i] = astForDecorator(c, CHILD(n, i));\n\t    }\n\t    return decoratorSeq;\n\t}\n\n\tfunction astForDecorated (c, n) {\n\t    var thing;\n\t    var decoratorSeq;\n\t    REQ(n, SYM.decorated);\n\t    decoratorSeq = astForDecorators(c, CHILD(n, 0));\n\t    goog.asserts.assert(CHILD(n, 1).type === SYM.funcdef || CHILD(n, 1).type === SYM.classdef);\n\n\t    thing = null;\n\t    if (CHILD(n, 1).type === SYM.funcdef) {\n\t        thing = astForFuncdef(c, CHILD(n, 1), decoratorSeq);\n\t    }\n\t    else if (CHILD(n, 1) === SYM.classdef) {\n\t        thing = astForClassdef(c, CHILD(n, 1), decoratorSeq);\n\t    }\n\t    if (thing) {\n\t        thing.lineno = n.lineno;\n\t        thing.col_offset = n.col_offset;\n\t    }\n\t    return thing;\n\t}\n\n\t//note: with statements need to be updated to 2.7\n\t//see: ast.c lines: 3127 -> 3185\n\n\tfunction astForWithVar (c, n) {\n\t    REQ(n, SYM.with_item);\n\t    return astForExpr(c, CHILD(n, 1));\n\t}\n\n\tfunction astForWithStmt (c, n) {\n\t    /* with_stmt: 'with' test [ with_var ] ':' suite */\n\t    var optionalVars;\n\t    var contextExpr;\n\t    var suiteIndex = 3; // skip with, test, :\n\t    goog.asserts.assert(n.type === SYM.with_stmt);\n\t    contextExpr = astForExpr(c, CHILD(n, 1));\n\t    if (CHILD(n, 2).type === SYM.with_item) {\n\t        optionalVars = astForWithVar(c, CHILD(n, 2));\n\t        setContext(c, optionalVars, Store, n);\n\t        suiteIndex = 4;\n\t    }\n\t    return new With_(contextExpr, optionalVars, astForSuite(c, CHILD(n, suiteIndex)), n.lineno, n.col_offset);\n\t}\n\n\tfunction astForExecStmt (c, n) {\n\t    var expr1, globals = null, locals = null;\n\t    var nchildren = NCH(n);\n\t    goog.asserts.assert(nchildren === 2 || nchildren === 4 || nchildren === 6);\n\n\t    /* exec_stmt: 'exec' expr ['in' test [',' test]] */\n\t    REQ(n, SYM.exec_stmt);\n\t    expr1 = astForExpr(c, CHILD(n, 1));\n\t    if (nchildren >= 4) {\n\t        globals = astForExpr(c, CHILD(n, 3));\n\t    }\n\t    if (nchildren === 6) {\n\t        locals = astForExpr(c, CHILD(n, 5));\n\t    }\n\t    return new Exec(expr1, globals, locals, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForIfStmt (c, n) {\n\t    /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*\n\t     ['else' ':' suite]\n\t     */\n\t    var off;\n\t    var i;\n\t    var orelse;\n\t    var hasElse;\n\t    var nElif;\n\t    var decider;\n\t    var s;\n\t    REQ(n, SYM.if_stmt);\n\t    if (NCH(n) === 4) {\n\t        return new If_(\n\t            astForExpr(c, CHILD(n, 1)),\n\t            astForSuite(c, CHILD(n, 3)),\n\t            [], n.lineno, n.col_offset);\n\t    }\n\n\t    s = CHILD(n, 4).value;\n\t    decider = s.charAt(2); // elSe or elIf\n\t    if (decider === \"s\") {\n\t        return new If_(\n\t            astForExpr(c, CHILD(n, 1)),\n\t            astForSuite(c, CHILD(n, 3)),\n\t            astForSuite(c, CHILD(n, 6)),\n\t            n.lineno, n.col_offset);\n\t    }\n\t    else if (decider === \"i\") {\n\t        nElif = NCH(n) - 4;\n\t        hasElse = false;\n\t        orelse = [];\n\n\t        /* must reference the child nElif+1 since 'else' token is third, not\n\t         * fourth child from the end. */\n\t        if (CHILD(n, nElif + 1).type === TOK.T_NAME &&\n\t            CHILD(n, nElif + 1).value.charAt(2) === \"s\") {\n\t            hasElse = true;\n\t            nElif -= 3;\n\t        }\n\t        nElif /= 4;\n\n\t        if (hasElse) {\n\t            orelse = [\n\t                new If_(\n\t                    astForExpr(c, CHILD(n, NCH(n) - 6)),\n\t                    astForSuite(c, CHILD(n, NCH(n) - 4)),\n\t                    astForSuite(c, CHILD(n, NCH(n) - 1)),\n\t                    CHILD(n, NCH(n) - 6).lineno,\n\t                    CHILD(n, NCH(n) - 6).col_offset)];\n\t            nElif--;\n\t        }\n\n\t        for (i = 0; i < nElif; ++i) {\n\t            off = 5 + (nElif - i - 1) * 4;\n\t            orelse = [\n\t                new If_(\n\t                    astForExpr(c, CHILD(n, off)),\n\t                    astForSuite(c, CHILD(n, off + 2)),\n\t                    orelse,\n\t                    CHILD(n, off).lineno,\n\t                    CHILD(n, off).col_offset)];\n\t        }\n\t        return new If_(\n\t            astForExpr(c, CHILD(n, 1)),\n\t            astForSuite(c, CHILD(n, 3)),\n\t            orelse, n.lineno, n.col_offset);\n\t    }\n\n\t    goog.asserts.fail(\"unexpected token in 'if' statement\");\n\t}\n\n\tfunction astForExprlist (c, n, context) {\n\t    var e;\n\t    var i;\n\t    var seq;\n\t    REQ(n, SYM.exprlist);\n\t    seq = [];\n\t    for (i = 0; i < NCH(n); i += 2) {\n\t        e = astForExpr(c, CHILD(n, i));\n\t        seq[i / 2] = e;\n\t        if (context) {\n\t            setContext(c, e, context, CHILD(n, i));\n\t        }\n\t    }\n\t    return seq;\n\t}\n\n\tfunction astForDelStmt (c, n) {\n\t    /* del_stmt: 'del' exprlist */\n\t    REQ(n, SYM.del_stmt);\n\t    return new Delete_(astForExprlist(c, CHILD(n, 1), Del), n.lineno, n.col_offset);\n\t}\n\n\tfunction astForGlobalStmt (c, n) {\n\t    /* global_stmt: 'global' NAME (',' NAME)* */\n\t    var i;\n\t    var s = [];\n\t    REQ(n, SYM.global_stmt);\n\t    for (i = 1; i < NCH(n); i += 2) {\n\t        s[(i - 1) / 2] = strobj(CHILD(n, i).value);\n\t    }\n\t    return new Global(s, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForAssertStmt (c, n) {\n\t    /* assert_stmt: 'assert' test [',' test] */\n\t    REQ(n, SYM.assert_stmt);\n\t    if (NCH(n) === 2) {\n\t        return new Assert(astForExpr(c, CHILD(n, 1)), null, n.lineno, n.col_offset);\n\t    }\n\t    else if (NCH(n) === 4) {\n\t        return new Assert(astForExpr(c, CHILD(n, 1)), astForExpr(c, CHILD(n, 3)), n.lineno, n.col_offset);\n\t    }\n\t    goog.asserts.fail(\"improper number of parts to assert stmt\");\n\t}\n\n\tfunction aliasForImportName (c, n) {\n\t    /*\n\t     import_as_name: NAME ['as' NAME]\n\t     dotted_as_name: dotted_name ['as' NAME]\n\t     dotted_name: NAME ('.' NAME)*\n\t     */\n\n\t    var i;\n\t    var a;\n\t    var name;\n\t    var str;\n\t    loop: while (true) {\n\t        switch (n.type) {\n\t            case SYM.import_as_name:\n\t                str = null;\n\t                name = strobj(CHILD(n, 0).value);\n\t                if (NCH(n) === 3) {\n\t                    str = CHILD(n, 2).value;\n\t                }\n\t                return new alias(name, str == null ? null : strobj(str));\n\t            case SYM.dotted_as_name:\n\t                if (NCH(n) === 1) {\n\t                    n = CHILD(n, 0);\n\t                    continue loop;\n\t                }\n\t                else {\n\t                    a = aliasForImportName(c, CHILD(n, 0));\n\t                    goog.asserts.assert(!a.asname);\n\t                    a.asname = strobj(CHILD(n, 2).value);\n\t                    return a;\n\t                }\n\t                break;\n\t            case SYM.dotted_name:\n\t                if (NCH(n) === 1) {\n\t                    return new alias(strobj(CHILD(n, 0).value), null);\n\t                }\n\t                else {\n\t                    // create a string of the form a.b.c\n\t                    str = \"\";\n\t                    for (i = 0; i < NCH(n); i += 2) {\n\t                        str += CHILD(n, i).value + \".\";\n\t                    }\n\t                    return new alias(strobj(str.substr(0, str.length - 1)), null);\n\t                }\n\t                break;\n\t            case TOK.T_STAR:\n\t                return new alias(strobj(\"*\"), null);\n\t            default:\n\t                throw new Sk.builtin.SyntaxError(\"unexpected import name\", c.c_filename, n.lineno);\n\t        }\n\t        break;\n\t    }\n\t}\n\n\tfunction astForImportStmt (c, n) {\n\t    /*\n\t     import_stmt: import_name | import_from\n\t     import_name: 'import' dotted_as_names\n\t     import_from: 'from' ('.'* dotted_name | '.') 'import'\n\t     ('*' | '(' import_as_names ')' | import_as_names)\n\t     */\n\t    var modname;\n\t    var idx;\n\t    var nchildren;\n\t    var ndots;\n\t    var mod;\n\t    var i;\n\t    var aliases;\n\t    var col_offset;\n\t    var lineno;\n\t    REQ(n, SYM.import_stmt);\n\t    lineno = n.lineno;\n\t    col_offset = n.col_offset;\n\t    n = CHILD(n, 0);\n\t    if (n.type === SYM.import_name) {\n\t        n = CHILD(n, 1);\n\t        REQ(n, SYM.dotted_as_names);\n\t        aliases = [];\n\t        for (i = 0; i < NCH(n); i += 2) {\n\t            aliases[i / 2] = aliasForImportName(c, CHILD(n, i));\n\t        }\n\t        return new Import_(aliases, lineno, col_offset);\n\t    }\n\t    else if (n.type === SYM.import_from) {\n\t        mod = null;\n\t        ndots = 0;\n\n\t        for (idx = 1; idx < NCH(n); ++idx) {\n\t            if (CHILD(n, idx).type === SYM.dotted_name) {\n\t                mod = aliasForImportName(c, CHILD(n, idx));\n\t                idx++;\n\t                break;\n\t            }\n\t            else if (CHILD(n, idx).type !== TOK.T_DOT) {\n\t                break;\n\t            }\n\t            ndots++;\n\t        }\n\t        ++idx; // skip the import keyword\n\t        switch (CHILD(n, idx).type) {\n\t            case TOK.T_STAR:\n\t                // from ... import\n\t                n = CHILD(n, idx);\n\t                nchildren = 1;\n\t                break;\n\t            case TOK.T_LPAR:\n\t                // from ... import (x, y, z)\n\t                n = CHILD(n, idx + 1);\n\t                nchildren = NCH(n);\n\t                break;\n\t            case SYM.import_as_names:\n\t                // from ... import x, y, z\n\t                n = CHILD(n, idx);\n\t                nchildren = NCH(n);\n\t                if (nchildren % 2 === 0) {\n\t                    throw new Sk.builtin.SyntaxError(\"trailing comma not allowed without surrounding parentheses\", c.c_filename, n.lineno);\n\t                }\n\t                break;\n\t            default:\n\t                throw new Sk.builtin.SyntaxError(\"Unexpected node-type in from-import\", c.c_filename, n.lineno);\n\t        }\n\t        aliases = [];\n\t        if (n.type === TOK.T_STAR) {\n\t            aliases[0] = aliasForImportName(c, n);\n\t        }\n\t        else {\n\t            for (i = 0; i < NCH(n); i += 2) {\n\t                aliases[i / 2] = aliasForImportName(c, CHILD(n, i));\n\t            }\n\t        }\n\t        modname = mod ? mod.name.v : \"\";\n\t        return new ImportFrom(strobj(modname), aliases, ndots, lineno, col_offset);\n\t    }\n\t    throw new Sk.builtin.SyntaxError(\"unknown import statement\", c.c_filename, n.lineno);\n\t}\n\n\tfunction astForTestlistComp(c, n) {\n\t    /* testlist_comp: test ( comp_for | (',' test)* [','] ) */\n\t    /* argument: test [comp_for] */\n\t    goog.asserts.assert(n.type === SYM.testlist_comp || n.type === SYM.argument);\n\t    if (NCH(n) > 1 && CHILD(n, 1).type === SYM.comp_for) {\n\t        return astForGenExpr(c, n);\n\t    }\n\t    return astForTestlist(c, n);\n\t}\n\n\tfunction astForListcomp (c, n) {\n\t    /* listmaker: test ( list_for | (',' test)* [','] )\n\t     list_for: 'for' exprlist 'in' testlist_safe [list_iter]\n\t     list_iter: list_for | list_if\n\t     list_if: 'if' test [list_iter]\n\t     testlist_safe: test [(',' test)+ [',']]\n\t     */\n\n\t    function countListFors (c, n) {\n\t        var nfors = 0;\n\t        var ch = CHILD(n, 1);\n\t        count_list_for: while (true) {\n\t            nfors++;\n\t            REQ(ch, SYM.list_for);\n\t            if (NCH(ch) === 5) {\n\t                ch = CHILD(ch, 4);\n\t            }\n\t            else {\n\t                return nfors;\n\t            }\n\t            count_list_iter: while (true) {\n\t                REQ(ch, SYM.list_iter);\n\t                ch = CHILD(ch, 0);\n\t                if (ch.type === SYM.list_for) {\n\t                    continue count_list_for;\n\t                }\n\t                else if (ch.type === SYM.list_if) {\n\t                    if (NCH(ch) === 3) {\n\t                        ch = CHILD(ch, 2);\n\t                        continue count_list_iter;\n\t                    }\n\t                    else {\n\t                        return nfors;\n\t                    }\n\t                }\n\t                break;\n\t            }\n\t            break;\n\t        }\n\t    }\n\n\t    function countListIfs (c, n) {\n\t        var nifs = 0;\n\t        while (true) {\n\t            REQ(n, SYM.list_iter);\n\t            if (CHILD(n, 0).type === SYM.list_for) {\n\t                return nifs;\n\t            }\n\t            n = CHILD(n, 0);\n\t            REQ(n, SYM.list_if);\n\t            nifs++;\n\t            if (NCH(n) == 2) {\n\t                return nifs;\n\t            }\n\t            n = CHILD(n, 2);\n\t        }\n\t    }\n\n\t    var j;\n\t    var ifs;\n\t    var nifs;\n\t    var lc;\n\t    var expression;\n\t    var t;\n\t    var forch;\n\t    var i;\n\t    var ch;\n\t    var listcomps;\n\t    var nfors;\n\t    var elt;\n\t    REQ(n, SYM.listmaker);\n\t    goog.asserts.assert(NCH(n) > 1);\n\t    elt = astForExpr(c, CHILD(n, 0));\n\t    nfors = countListFors(c, n);\n\t    listcomps = [];\n\t    ch = CHILD(n, 1);\n\t    for (i = 0; i < nfors; ++i) {\n\t        REQ(ch, SYM.list_for);\n\t        forch = CHILD(ch, 1);\n\t        t = astForExprlist(c, forch, Store);\n\t        expression = astForTestlist(c, CHILD(ch, 3));\n\t        if (NCH(forch) === 1) {\n\t            lc = new comprehension(t[0], expression, []);\n\t        }\n\t        else {\n\t            lc = new comprehension(new Tuple(t, Store, ch.lineno, ch.col_offset), expression, []);\n\t        }\n\n\t        if (NCH(ch) === 5) {\n\t            ch = CHILD(ch, 4);\n\t            nifs = countListIfs(c, ch);\n\t            ifs = [];\n\t            for (j = 0; j < nifs; ++j) {\n\t                REQ(ch, SYM.list_iter);\n\t                ch = CHILD(ch, 0);\n\t                REQ(ch, SYM.list_if);\n\t                ifs[j] = astForExpr(c, CHILD(ch, 1));\n\t                if (NCH(ch) === 3) {\n\t                    ch = CHILD(ch, 2);\n\t                }\n\t            }\n\t            if (ch.type === SYM.list_iter) {\n\t                ch = CHILD(ch, 0);\n\t            }\n\t            lc.ifs = ifs;\n\t        }\n\t        listcomps[i] = lc;\n\t    }\n\t    return new ListComp(elt, listcomps, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForFactor (c, n) {\n\t    /* some random peephole thing that cpy does */\n\t    var expression;\n\t    var pnum;\n\t    var patom;\n\t    var ppower;\n\t    var pfactor;\n\t    if (CHILD(n, 0).type === TOK.T_MINUS && NCH(n) === 2) {\n\t        pfactor = CHILD(n, 1);\n\t        if (pfactor.type === SYM.factor && NCH(pfactor) === 1) {\n\t            ppower = CHILD(pfactor, 0);\n\t            if (ppower.type === SYM.power && NCH(ppower) === 1) {\n\t                patom = CHILD(ppower, 0);\n\t                if (patom.type === SYM.atom) {\n\t                    pnum = CHILD(patom, 0);\n\t                    if (pnum.type === TOK.T_NUMBER) {\n\t                        pnum.value = \"-\" + pnum.value;\n\t                        return astForAtom(c, patom);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    expression = astForExpr(c, CHILD(n, 1));\n\t    switch (CHILD(n, 0).type) {\n\t        case TOK.T_PLUS:\n\t            return new UnaryOp(UAdd, expression, n.lineno, n.col_offset);\n\t        case TOK.T_MINUS:\n\t            return new UnaryOp(USub, expression, n.lineno, n.col_offset);\n\t        case TOK.T_TILDE:\n\t            return new UnaryOp(Invert, expression, n.lineno, n.col_offset);\n\t    }\n\n\t    goog.asserts.fail(\"unhandled factor\");\n\t}\n\n\tfunction astForForStmt (c, n) {\n\t    /* for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite] */\n\t    var target;\n\t    var _target;\n\t    var nodeTarget;\n\t    var seq = [];\n\t    REQ(n, SYM.for_stmt);\n\t    if (NCH(n) === 9) {\n\t        seq = astForSuite(c, CHILD(n, 8));\n\t    }\n\t    nodeTarget = CHILD(n, 1);\n\t    _target = astForExprlist(c, nodeTarget, Store);\n\t    if (NCH(nodeTarget) === 1) {\n\t        target = _target[0];\n\t    }\n\t    else {\n\t        target = new Tuple(_target, Store, n.lineno, n.col_offset);\n\t    }\n\n\t    return new For_(target,\n\t        astForTestlist(c, CHILD(n, 3)),\n\t        astForSuite(c, CHILD(n, 5)),\n\t        seq, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForCall (c, n, func) {\n\t    /*\n\t      arglist: (argument ',')* (argument [',']| '*' test [',' '**' test]\n\t               | '**' test)\n\t      argument: test [comp_for] | test '=' test       # Really [keyword '='] test\n\t    */\n\t    var tmp;\n\t    var k;\n\t    var key;\n\t    var e;\n\t    var kwarg;\n\t    var vararg;\n\t    var keywords;\n\t    var args;\n\t    var ch;\n\t    var i;\n\t    var ngens;\n\t    var nkeywords;\n\t    var nargs;\n\n\t    REQ(n, SYM.arglist);\n\t    nargs = 0;\n\t    nkeywords = 0;\n\t    ngens = 0;\n\t    for (i = 0; i < NCH(n); i++) {\n\t        ch = CHILD(n, i);\n\t        if (ch.type === SYM.argument) {\n\t            if (NCH(ch) === 1) {\n\t                nargs++;\n\t            }\n\t            else if (CHILD(ch, 1).type === SYM.comp_for) {\n\t                ngens++;\n\t            }\n\t            else {\n\t                nkeywords++;\n\t            }\n\t        }\n\t    }\n\t    if (ngens > 1 || (ngens && (nargs || nkeywords))) {\n\t        throw new Sk.builtin.SyntaxError(\"Generator expression must be parenthesized if not sole argument\", c.c_filename, n.lineno);\n\t    }\n\t    if (nargs + nkeywords + ngens > 255) {\n\t        throw new Sk.builtin.SyntaxError(\"more than 255 arguments\", c.c_filename, n.lineno);\n\t    }\n\t    args = [];\n\t    keywords = [];\n\t    nargs = 0;\n\t    nkeywords = 0;\n\t    vararg = null;\n\t    kwarg = null;\n\t    for (i = 0; i < NCH(n); i++) {\n\t        ch = CHILD(n, i);\n\t        if (ch.type === SYM.argument) {\n\t            if (NCH(ch) === 1) {\n\t                if (nkeywords) {\n\t                    throw new Sk.builtin.SyntaxError(\"non-keyword arg after keyword arg\", c.c_filename, n.lineno);\n\t                }\n\t                if (vararg) {\n\t                    throw new Sk.builtin.SyntaxError(\"only named arguments may follow *expression\", c.c_filename, n.lineno);\n\t                }\n\t                args[nargs++] = astForExpr(c, CHILD(ch, 0));\n\t            }\n\t            else if (CHILD(ch, 1).type === SYM.comp_for) {\n\t                args[nargs++] = astForGenExpr(c, ch);\n\t            }\n\t            else {\n\t                e = astForExpr(c, CHILD(ch, 0));\n\t                if (e.constructor === Lambda) {\n\t                    throw new Sk.builtin.SyntaxError(\"lambda cannot contain assignment\", c.c_filename, n.lineno);\n\t                }\n\t                else if (e.constructor !== Name) {\n\t                    throw new Sk.builtin.SyntaxError(\"keyword can't be an expression\", c.c_filename, n.lineno);\n\t                }\n\t                key = e.id;\n\t                forbiddenCheck(c, CHILD(ch, 0), key, n.lineno);\n\t                for (k = 0; k < nkeywords; ++k) {\n\t                    tmp = keywords[k].arg;\n\t                    if (tmp === key) {\n\t                        throw new Sk.builtin.SyntaxError(\"keyword argument repeated\", c.c_filename, n.lineno);\n\t                    }\n\t                }\n\t                keywords[nkeywords++] = new keyword(key, astForExpr(c, CHILD(ch, 2)));\n\t            }\n\t        }\n\t        else if (ch.type === TOK.T_STAR) {\n\t            vararg = astForExpr(c, CHILD(n, ++i));\n\t        }\n\t        else if (ch.type === TOK.T_DOUBLESTAR) {\n\t            kwarg = astForExpr(c, CHILD(n, ++i));\n\t        }\n\t    }\n\t    return new Call(func, args, keywords, vararg, kwarg, func.lineno, func.col_offset);\n\t}\n\n\tfunction astForTrailer (c, n, leftExpr) {\n\t    /* trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME \n\t     subscriptlist: subscript (',' subscript)* [',']\n\t     subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]\n\t     */\n\t    var e;\n\t    var elts;\n\t    var slc;\n\t    var j;\n\t    var slices;\n\t    var simple;\n\t    REQ(n, SYM.trailer);\n\t    if (CHILD(n, 0).type === TOK.T_LPAR) {\n\t        if (NCH(n) === 2) {\n\t            return new Call(leftExpr, [], [], null, null, n.lineno, n.col_offset);\n\t        }\n\t        else {\n\t            return astForCall(c, CHILD(n, 1), leftExpr);\n\t        }\n\t    }\n\t    else if (CHILD(n, 0).type === TOK.T_DOT) {\n\t        return new Attribute(leftExpr, strobj(CHILD(n, 1).value), Load, n.lineno, n.col_offset);\n\t    }\n\t    else {\n\t        REQ(CHILD(n, 0), TOK.T_LSQB);\n\t        REQ(CHILD(n, 2), TOK.T_RSQB);\n\t        n = CHILD(n, 1);\n\t        if (NCH(n) === 1) {\n\t            return new Subscript(leftExpr, astForSlice(c, CHILD(n, 0)), Load, n.lineno, n.col_offset);\n\t        }\n\t        else {\n\t            /* The grammar is ambiguous here. The ambiguity is resolved \n\t             by treating the sequence as a tuple literal if there are\n\t             no slice features.\n\t             */\n\t            simple = true;\n\t            slices = [];\n\t            for (j = 0; j < NCH(n); j += 2) {\n\t                slc = astForSlice(c, CHILD(n, j));\n\t                if (slc.constructor !== Index) {\n\t                    simple = false;\n\t                }\n\t                slices[j / 2] = slc;\n\t            }\n\t            if (!simple) {\n\t                return new Subscript(leftExpr, new ExtSlice(slices), Load, n.lineno, n.col_offset);\n\t            }\n\t            elts = [];\n\t            for (j = 0; j < slices.length; ++j) {\n\t                slc = slices[j];\n\t                goog.asserts.assert(slc.constructor === Index && slc.value !== null && slc.value !== undefined);\n\t                elts[j] = slc.value;\n\t            }\n\t            e = new Tuple(elts, Load, n.lineno, n.col_offset);\n\t            return new Subscript(leftExpr, new Index(e), Load, n.lineno, n.col_offset);\n\t        }\n\t    }\n\t}\n\n\tfunction astForFlowStmt (c, n) {\n\t    /*\n\t     flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt\n\t     | yield_stmt\n\t     break_stmt: 'break'\n\t     continue_stmt: 'continue'\n\t     return_stmt: 'return' [testlist]\n\t     yield_stmt: yield_expr\n\t     yield_expr: 'yield' testlist\n\t     raise_stmt: 'raise' [test [',' test [',' test]]]\n\t     */\n\t    var ch;\n\t    REQ(n, SYM.flow_stmt);\n\t    ch = CHILD(n, 0);\n\t    switch (ch.type) {\n\t        case SYM.break_stmt:\n\t            return new Break_(n.lineno, n.col_offset);\n\t        case SYM.continue_stmt:\n\t            return new Continue_(n.lineno, n.col_offset);\n\t        case SYM.yield_stmt:\n\t            return new Expr(astForExpr(c, CHILD(ch, 0)), n.lineno, n.col_offset);\n\t        case SYM.return_stmt:\n\t            if (NCH(ch) === 1) {\n\t                return new Return_(null, n.lineno, n.col_offset);\n\t            }\n\t            else {\n\t                return new Return_(astForTestlist(c, CHILD(ch, 1)), n.lineno, n.col_offset);\n\t            }\n\t            break;\n\t        case SYM.raise_stmt:\n\t            if (NCH(ch) === 1) {\n\t                return new Raise(null, null, null, n.lineno, n.col_offset);\n\t            }\n\t            else if (NCH(ch) === 2) {\n\t                return new Raise(astForExpr(c, CHILD(ch, 1)), null, null, n.lineno, n.col_offset);\n\t            }\n\t            else if (NCH(ch) === 4) {\n\t                return new Raise(\n\t                    astForExpr(c, CHILD(ch, 1)),\n\t                    astForExpr(c, CHILD(ch, 3)),\n\t                    null, n.lineno, n.col_offset);\n\t            }\n\t            else if (NCH(ch) === 6) {\n\t                return new Raise(\n\t                    astForExpr(c, CHILD(ch, 1)),\n\t                    astForExpr(c, CHILD(ch, 3)),\n\t                    astForExpr(c, CHILD(ch, 5)),\n\t                    n.lineno, n.col_offset);\n\t            }\n\t            break;\n\t        default:\n\t            goog.asserts.fail(\"unexpected flow_stmt\");\n\t    }\n\t    goog.asserts.fail(\"unhandled flow statement\");\n\t}\n\n\tfunction astForArguments (c, n) {\n\t    /* parameters: '(' [varargslist] ')'\n\t     varargslist: (fpdef ['=' test] ',')* ('*' NAME [',' '**' NAME]\n\t     | '**' NAME) | fpdef ['=' test] (',' fpdef ['=' test])* [',']\n\t     */\n\t    var parenthesized;\n\t    var id;\n\t    var complexArgs;\n\t    var k;\n\t    var j;\n\t    var i;\n\t    var foundDefault;\n\t    var defaults;\n\t    var args;\n\t    var ch;\n\t    var vararg = null;\n\t    var kwarg = null;\n\t    if (n.type === SYM.parameters) {\n\t        if (NCH(n) === 2) // () as arglist\n\t        {\n\t            return new arguments_([], null, null, []);\n\t        }\n\t        n = CHILD(n, 1);\n\t    }\n\t    REQ(n, SYM.varargslist);\n\n\t    args = [];\n\t    defaults = [];\n\n\t    /* fpdef: NAME | '(' fplist ')'\n\t     fplist: fpdef (',' fpdef)* [',']\n\t     */\n\t    foundDefault = false;\n\t    i = 0;\n\t    j = 0; // index for defaults\n\t    k = 0; // index for args\n\t    while (i < NCH(n)) {\n\t        ch = CHILD(n, i);\n\t        switch (ch.type) {\n\t            case SYM.fpdef:\n\t                complexArgs = 0;\n\t                parenthesized = 0;\n\t                handle_fpdef: while (true) {\n\t                    if (i + 1 < NCH(n) && CHILD(n, i + 1).type === TOK.T_EQUAL) {\n\t                        defaults[j++] = astForExpr(c, CHILD(n, i + 2));\n\t                        i += 2;\n\t                        foundDefault = true;\n\t                    }\n\t                    else if (foundDefault) {\n\t                        /* def f((x)=4): pass should raise an error.\n\t                         def f((x, (y))): pass will just incur the tuple unpacking warning. */\n\t                        if (parenthesized && !complexArgs) {\n\t                            throw new Sk.builtin.SyntaxError(\"parenthesized arg with default\", c.c_filename, n.lineno);\n\t                        }\n\t                        throw new Sk.builtin.SyntaxError(\"non-default argument follows default argument\", c.c_filename, n.lineno);\n\t                    }\n\n\t                    if (NCH(ch) === 3) {\n\t                        ch = CHILD(ch, 1);\n\t                        // def foo((x)): is not complex, special case.\n\t                        if (NCH(ch) !== 1) {\n\t                            throw new Sk.builtin.SyntaxError(\"tuple parameter unpacking has been removed\", c.c_filename, n.lineno);\n\t                        }\n\t                        else {\n\t                            /* def foo((x)): setup for checking NAME below. */\n\t                            /* Loop because there can be many parens and tuple\n\t                             unpacking mixed in. */\n\t                            parenthesized = true;\n\t                            ch = CHILD(ch, 0);\n\t                            goog.asserts.assert(ch.type === SYM.fpdef);\n\t                            continue handle_fpdef;\n\t                        }\n\t                    }\n\t                    if (CHILD(ch, 0).type === TOK.T_NAME) {\n\t                        forbiddenCheck(c, n, CHILD(ch, 0).value, n.lineno);\n\t                        id = strobj(CHILD(ch, 0).value);\n\t                        args[k++] = new Name(id, Param, ch.lineno, ch.col_offset);\n\t                    }\n\t                    i += 2;\n\t                    if (parenthesized) {\n\t                        throw new Sk.builtin.SyntaxError(\"parenthesized argument names are invalid\", c.c_filename, n.lineno);\n\t                    }\n\t                    break;\n\t                }\n\t                break;\n\t            case TOK.T_STAR:\n\t                forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.lineno);\n\t                vararg = strobj(CHILD(n, i + 1).value);\n\t                i += 3;\n\t                break;\n\t            case TOK.T_DOUBLESTAR:\n\t                forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.lineno);\n\t                kwarg = strobj(CHILD(n, i + 1).value);\n\t                i += 3;\n\t                break;\n\t            default:\n\t                goog.asserts.fail(\"unexpected node in varargslist\");\n\t        }\n\t    }\n\t    return new arguments_(args, vararg, kwarg, defaults);\n\t}\n\n\tfunction astForFuncdef (c, n, decoratorSeq) {\n\t    /* funcdef: 'def' NAME parameters ':' suite */\n\t    var body;\n\t    var args;\n\t    var name;\n\t    REQ(n, SYM.funcdef);\n\t    name = strobj(CHILD(n, 1).value);\n\t    forbiddenCheck(c, CHILD(n, 1), CHILD(n, 1).value, n.lineno);\n\t    args = astForArguments(c, CHILD(n, 2));\n\t    body = astForSuite(c, CHILD(n, 4));\n\t    return new FunctionDef(name, args, body, decoratorSeq, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForClassBases (c, n) {\n\t    /* testlist: test (',' test)* [','] */\n\t    goog.asserts.assert(NCH(n) > 0);\n\t    REQ(n, SYM.testlist);\n\t    if (NCH(n) === 1) {\n\t        return [ astForExpr(c, CHILD(n, 0)) ];\n\t    }\n\t    return seqForTestlist(c, n);\n\t}\n\n\tfunction astForClassdef (c, n, decoratorSeq) {\n\t    /* classdef: 'class' NAME ['(' testlist ')'] ':' suite */\n\t    var s;\n\t    var bases;\n\t    var classname;\n\t    REQ(n, SYM.classdef);\n\t    forbiddenCheck(c, n, CHILD(n, 1).value, n.lineno);\n\t    classname = strobj(CHILD(n, 1).value);\n\t    if (NCH(n) === 4) {\n\t        return new ClassDef(classname, [], astForSuite(c, CHILD(n, 3)), decoratorSeq, n.lineno, n.col_offset);\n\t    }\n\t    if (CHILD(n, 3).type === TOK.T_RPAR) {\n\t        return new ClassDef(classname, [], astForSuite(c, CHILD(n, 5)), decoratorSeq, n.lineno, n.col_offset);\n\t    }\n\n\t    bases = astForClassBases(c, CHILD(n, 3));\n\t    s = astForSuite(c, CHILD(n, 6));\n\t    return new ClassDef(classname, bases, s, decoratorSeq, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForLambdef (c, n) {\n\t    /* lambdef: 'lambda' [varargslist] ':' test */\n\t    var args;\n\t    var expression;\n\t    if (NCH(n) === 3) {\n\t        args = new arguments_([], null, null, []);\n\t        expression = astForExpr(c, CHILD(n, 2));\n\t    }\n\t    else {\n\t        args = astForArguments(c, CHILD(n, 1));\n\t        expression = astForExpr(c, CHILD(n, 3));\n\t    }\n\t    return new Lambda(args, expression, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForComprehension(c, n) {\n\t    /* testlist_comp: test ( comp_for | (',' test)* [','] )\n\t       argument: test [comp_for] | test '=' test       # Really [keyword '='] test */\n\t    \n\t    var j;\n\t    var ifs;\n\t    var nifs;\n\t    var ge;\n\t    var expression;\n\t    var t;\n\t    var forch;\n\t    var i;\n\t    var ch;\n\t    var genexps;\n\t    var nfors;\n\t    var elt;\n\t    var comps;\n\t    var comp;\n\n\t    function countCompFors(c, n) {\n\t        var nfors = 0;\n\t        count_comp_for: while (true) {\n\t            nfors++;\n\t            REQ(n, SYM.comp_for);\n\t            if (NCH(n) === 5) {\n\t                n = CHILD(n, 4);\n\t            } else {\n\t                return nfors;\n\t            }\n\t            count_comp_iter: while (true) {\n\t                REQ(n, SYM.comp_iter);\n\t                n = CHILD(n, 0);\n\t                if (n.type === SYM.comp_for) {\n\t                    continue count_comp_for;\n\t                } else if (n.type === SYM.comp_if) {\n\t                    if (NCH(n) === 3) {\n\t                        n = CHILD(n, 2);\n\t                        continue count_comp_iter;\n\t                    } else {\n\t                        return nfors;\n\t                    }\n\t                }\n\t                break;\n\t            }\n\t            break;\n\t        }\n\t        goog.asserts.fail(\"logic error in countCompFors\");\n\t    }\n\n\t    function countCompIfs(c, n) {\n\t        var nifs = 0;\n\t        while (true) {\n\t            REQ(n, SYM.comp_iter);\n\t            if (CHILD(n, 0).type === SYM.comp_for) {\n\t                return nifs;\n\t            }\n\t            n = CHILD(n, 0);\n\t            REQ(n, SYM.comp_if);\n\t            nifs++;\n\t            if (NCH(n) == 2) {\n\t                return nifs;\n\t            }\n\t            n = CHILD(n, 2);\n\t        }\n\t    }\n\n\t    nfors = countCompFors(c, n);\n\t    comps = [];\n\t    for (i = 0; i < nfors; ++i) {\n\t        REQ(n, SYM.comp_for);\n\t        forch = CHILD(n, 1);\n\t        t = astForExprlist(c, forch, Store);\n\t        expression = astForExpr(c, CHILD(n, 3));\n\t        if (NCH(forch) === 1) {\n\t            comp = new comprehension(t[0], expression, []);\n\t        } else {\n\t            comp = new comprehension(new Tuple(t, Store, n.lineno, n.col_offset), expression, []);\n\t        }\n\t        if (NCH(n) === 5) {\n\t            n = CHILD(n, 4);\n\t            nifs = countCompIfs(c, n);\n\t            ifs = [];\n\t            for (j = 0; j < nifs; ++j) {\n\t                REQ(n, SYM.comp_iter);\n\t                n = CHILD(n, 0);\n\t                REQ(n, SYM.comp_if);\n\t                expression = astForExpr(c, CHILD(n, 1));\n\t                ifs[j] = expression;\n\t                if (NCH(n) === 3) {\n\t                    n = CHILD(n, 2);\n\t                }\n\t            }\n\t            if (n.type === SYM.comp_iter) {\n\t                n = CHILD(n, 0);\n\t            }\n\t            comp.ifs = ifs;\n\t        }\n\t        comps[i] = comp;\n\t    }\n\t    return comps;\n\t}\n\n\tfunction astForIterComp(c, n, type) {\n\t    var elt, comps;\n\t    goog.asserts.assert(NCH(n) > 1);\n\t    elt = astForExpr(c, CHILD(n, 0));\n\t    comps = astForComprehension(c, CHILD(n, 1));\n\t    if (type === COMP_GENEXP) {\n\t        return new GeneratorExp(elt, comps, n.lineno, n.col_offset);\n\t    } else if (type === COMP_SETCOMP) {\n\t        return new SetComp(elt, comps, n.lineno, n.col_offset);\n\t    }\n\t}\n\n\tfunction astForDictComp(c, n) {\n\t    var key, value;\n\t    var comps = [];\n\t    goog.asserts.assert(NCH(n) > 3);\n\t    REQ(CHILD(n, 1), TOK.T_COLON);\n\t    key = astForExpr(c, CHILD(n, 0));\n\t    value = astForExpr(c, CHILD(n, 2));\n\t    comps = astForComprehension(c, CHILD(n, 3));\n\t    return new DictComp(key, value, comps, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForGenExpr(c, n) {\n\t    goog.asserts.assert(n.type === SYM.testlist_comp || n.type === SYM.argument);\n\t    return astForIterComp(c, n, COMP_GENEXP);\n\t}\n\n\tfunction astForSetComp(c, n) {\n\t    goog.asserts.assert(n.type === SYM.dictorsetmaker);\n\t    return astForIterComp(c, n, COMP_SETCOMP);\n\t}\n\n\tfunction astForWhileStmt (c, n) {\n\t    /* while_stmt: 'while' test ':' suite ['else' ':' suite] */\n\t    REQ(n, SYM.while_stmt);\n\t    if (NCH(n) === 4) {\n\t        return new While_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.lineno, n.col_offset);\n\t    }\n\t    else if (NCH(n) === 7) {\n\t        return new While_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.lineno, n.col_offset);\n\t    }\n\t    goog.asserts.fail(\"wrong number of tokens for 'while' stmt\");\n\t}\n\n\tfunction astForAugassign (c, n) {\n\t    REQ(n, SYM.augassign);\n\t    n = CHILD(n, 0);\n\t    switch (n.value.charAt(0)) {\n\t        case \"+\":\n\t            return Add;\n\t        case \"-\":\n\t            return Sub;\n\t        case \"/\":\n\t            if (n.value.charAt(1) === \"/\") {\n\t                return FloorDiv;\n\t            }\n\t            return Div;\n\t        case \"%\":\n\t            return Mod;\n\t        case \"<\":\n\t            return LShift;\n\t        case \">\":\n\t            return RShift;\n\t        case \"&\":\n\t            return BitAnd;\n\t        case \"^\":\n\t            return BitXor;\n\t        case \"|\":\n\t            return BitOr;\n\t        case \"*\":\n\t            if (n.value.charAt(1) === \"*\") {\n\t                return Pow;\n\t            }\n\t            return Mult;\n\t        default:\n\t            goog.asserts.fail(\"invalid augassign\");\n\t    }\n\t}\n\n\tfunction astForBinop (c, n) {\n\t    /* Must account for a sequence of expressions.\n\t     How should A op B op C by represented?\n\t     BinOp(BinOp(A, op, B), op, C).\n\t     */\n\t    var tmp;\n\t    var newoperator;\n\t    var nextOper;\n\t    var i;\n\t    var result = new BinOp(\n\t        astForExpr(c, CHILD(n, 0)),\n\t        getOperator(CHILD(n, 1)),\n\t        astForExpr(c, CHILD(n, 2)),\n\t        n.lineno, n.col_offset);\n\t    var nops = (NCH(n) - 1) / 2;\n\t    for (i = 1; i < nops; ++i) {\n\t        nextOper = CHILD(n, i * 2 + 1);\n\t        newoperator = getOperator(nextOper);\n\t        tmp = astForExpr(c, CHILD(n, i * 2 + 2));\n\t        result = new BinOp(result, newoperator, tmp, nextOper.lineno, nextOper.col_offset);\n\t    }\n\t    return result;\n\n\t}\n\n\n\tfunction astForTestlist(c, n) {\n\t    /* this doesn't show up in Grammar.txt never did: testlist_gexp: test (',' test)* [','] */\n\t    /* testlist_comp: test (',' test)* [','] */\n\t    /* testlist: test (',' test)* [','] */\n\t    /* testlist_safe: test (',' test)+ [','] */\n\t    /* testlist1: test (',' test)* */\n\t    goog.asserts.assert(NCH(n) > 0);\n\t    if (n.type === SYM.testlist_comp) {\n\t        if (NCH(n) > 1) {\n\t            goog.asserts.assert(CHILD(n, 1).type !== SYM.comp_for);\n\t        }\n\t    }\n\t    else {\n\t        goog.asserts.assert(n.type === SYM.testlist || n.type === SYM.testlist_safe || n.type === SYM.testlist1);\n\t    }\n\n\t    if (NCH(n) === 1) {\n\t        return astForExpr(c, CHILD(n, 0));\n\t    }\n\t    else {\n\t        return new Tuple(seqForTestlist(c, n), Load, n.lineno, n.col_offset);\n\t    }\n\n\t}\n\n\tfunction astForExprStmt (c, n) {\n\t    var expression;\n\t    var value;\n\t    var e;\n\t    var i;\n\t    var targets;\n\t    var expr2;\n\t    var varName;\n\t    var expr1;\n\t    var ch;\n\t    REQ(n, SYM.expr_stmt);\n\t    /* expr_stmt: testlist (augassign (yield_expr|testlist) \n\t     | ('=' (yield_expr|testlist))*)\n\t     testlist: test (',' test)* [',']\n\t     augassign: '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^='\n\t     | '<<=' | '>>=' | '**=' | '//='\n\t     test: ... here starts the operator precendence dance\n\t     */\n\t    if (NCH(n) === 1) {\n\t        return new Expr(astForTestlist(c, CHILD(n, 0)), n.lineno, n.col_offset);\n\t    }\n\t    else if (CHILD(n, 1).type === SYM.augassign) {\n\t        ch = CHILD(n, 0);\n\t        expr1 = astForTestlist(c, ch);\n\t        switch (expr1.constructor) {\n\t            case GeneratorExp:\n\t                throw new Sk.builtin.SyntaxError(\"augmented assignment to generator expression not possible\", c.c_filename, n.lineno);\n\t            case Yield:\n\t                throw new Sk.builtin.SyntaxError(\"augmented assignment to yield expression not possible\", c.c_filename, n.lineno);\n\t            case Name:\n\t                varName = expr1.id;\n\t                forbiddenCheck(c, ch, varName, n.lineno);\n\t                break;\n\t            case Attribute:\n\t            case Subscript:\n\t                break;\n\t            default:\n\t                throw new Sk.builtin.SyntaxError(\"illegal expression for augmented assignment\", c.c_filename, n.lineno);\n\t        }\n\t        setContext(c, expr1, Store, ch);\n\n\t        ch = CHILD(n, 2);\n\t        if (ch.type === SYM.testlist) {\n\t            expr2 = astForTestlist(c, ch);\n\t        }\n\t        else {\n\t            expr2 = astForExpr(c, ch);\n\t        }\n\n\t        return new AugAssign(expr1, astForAugassign(c, CHILD(n, 1)), expr2, n.lineno, n.col_offset);\n\t    }\n\t    else {\n\t        // normal assignment\n\t        REQ(CHILD(n, 1), TOK.T_EQUAL);\n\t        targets = [];\n\t        for (i = 0; i < NCH(n) - 2; i += 2) {\n\t            ch = CHILD(n, i);\n\t            if (ch.type === SYM.yield_expr) {\n\t                throw new Sk.builtin.SyntaxError(\"assignment to yield expression not possible\", c.c_filename, n.lineno);\n\t            }\n\t            e = astForTestlist(c, ch);\n\t            setContext(c, e, Store, CHILD(n, i));\n\t            targets[i / 2] = e;\n\t        }\n\t        value = CHILD(n, NCH(n) - 1);\n\t        if (value.type === SYM.testlist) {\n\t            expression = astForTestlist(c, value);\n\t        }\n\t        else {\n\t            expression = astForExpr(c, value);\n\t        }\n\t        return new Assign(targets, expression, n.lineno, n.col_offset);\n\t    }\n\t}\n\n\tfunction astForIfexpr (c, n) {\n\t    /* test: or_test 'if' or_test 'else' test */\n\t    goog.asserts.assert(NCH(n) === 5);\n\t    return new IfExp(\n\t        astForExpr(c, CHILD(n, 2)),\n\t        astForExpr(c, CHILD(n, 0)),\n\t        astForExpr(c, CHILD(n, 4)),\n\t        n.lineno, n.col_offset);\n\t}\n\n\t/**\n\t * s is a python-style string literal, including quote characters and u/r/b\n\t * prefixes. Returns decoded string object.\n\t */\n\tfunction parsestr (c, s) {\n\t    var encodeUtf8 = function (s) {\n\t        return unescape(encodeURIComponent(s));\n\t    };\n\t    var decodeUtf8 = function (s) {\n\t        return decodeURIComponent(escape(s));\n\t    };\n\t    var decodeEscape = function (s, quote) {\n\t        var d3;\n\t        var d2;\n\t        var d1;\n\t        var d0;\n\t        var c;\n\t        var i;\n\t        var len = s.length;\n\t        var ret = \"\";\n\t        for (i = 0; i < len; ++i) {\n\t            c = s.charAt(i);\n\t            if (c === \"\\\\\") {\n\t                ++i;\n\t                c = s.charAt(i);\n\t                if (c === \"n\") {\n\t                    ret += \"\\n\";\n\t                }\n\t                else if (c === \"\\\\\") {\n\t                    ret += \"\\\\\";\n\t                }\n\t                else if (c === \"t\") {\n\t                    ret += \"\\t\";\n\t                }\n\t                else if (c === \"r\") {\n\t                    ret += \"\\r\";\n\t                }\n\t                else if (c === \"b\") {\n\t                    ret += \"\\b\";\n\t                }\n\t                else if (c === \"f\") {\n\t                    ret += \"\\f\";\n\t                }\n\t                else if (c === \"v\") {\n\t                    ret += \"\\v\";\n\t                }\n\t                else if (c === \"0\") {\n\t                    ret += \"\\0\";\n\t                }\n\t                else if (c === '\"') {\n\t                    ret += '\"';\n\t                }\n\t                else if (c === '\\'') {\n\t                    ret += '\\'';\n\t                }\n\t                else if (c === \"\\n\") /* escaped newline, join lines */ {\n\t                }\n\t                else if (c === \"x\") {\n\t                    d0 = s.charAt(++i);\n\t                    d1 = s.charAt(++i);\n\t                    ret += String.fromCharCode(parseInt(d0 + d1, 16));\n\t                }\n\t                else if (c === \"u\" || c === \"U\") {\n\t                    d0 = s.charAt(++i);\n\t                    d1 = s.charAt(++i);\n\t                    d2 = s.charAt(++i);\n\t                    d3 = s.charAt(++i);\n\t                    ret += String.fromCharCode(parseInt(d0 + d1, 16), parseInt(d2 + d3, 16));\n\t                }\n\t                else {\n\t                    // Leave it alone\n\t                    ret += \"\\\\\" + c;\n\t                    // goog.asserts.fail(\"unhandled escape: '\" + c.charCodeAt(0) + \"'\");\n\t                }\n\t            }\n\t            else {\n\t                ret += c;\n\t            }\n\t        }\n\t        return ret;\n\t    };\n\n\t    //print(\"parsestr\", s);\n\n\t    var quote = s.charAt(0);\n\t    var rawmode = false;\n\t    var unicode = false;\n\n\t    // treats every sequence as unicodes even if they are not treated with uU prefix\n\t    // kinda hacking though working for most purposes\n\t    if((c.c_flags & Parser.CO_FUTURE_UNICODE_LITERALS || Sk.python3 === true)) {\n\t        unicode = true;\n\t    }\n\n\t    if (quote === \"u\" || quote === \"U\") {\n\t        s = s.substr(1);\n\t        quote = s.charAt(0);\n\t        unicode = true;\n\t    }\n\t    else if (quote === \"r\" || quote === \"R\") {\n\t        s = s.substr(1);\n\t        quote = s.charAt(0);\n\t        rawmode = true;\n\t    }\n\t    goog.asserts.assert(quote !== \"b\" && quote !== \"B\", \"todo; haven't done b'' strings yet\");\n\n\t    goog.asserts.assert(quote === \"'\" || quote === '\"' && s.charAt(s.length - 1) === quote);\n\t    s = s.substr(1, s.length - 2);\n\t    if (unicode) {\n\t        s = encodeUtf8(s);\n\t    }\n\n\t    if (s.length >= 4 && s.charAt(0) === quote && s.charAt(1) === quote) {\n\t        goog.asserts.assert(s.charAt(s.length - 1) === quote && s.charAt(s.length - 2) === quote);\n\t        s = s.substr(2, s.length - 4);\n\t    }\n\n\t    if (rawmode || s.indexOf(\"\\\\\") === -1) {\n\t        return strobj(decodeUtf8(s));\n\t    }\n\t    return strobj(decodeEscape(s, quote));\n\t}\n\n\tfunction parsestrplus (c, n) {\n\t    var i;\n\t    var ret;\n\t    REQ(CHILD(n, 0), TOK.T_STRING);\n\t    ret = new Sk.builtin.str(\"\");\n\t    for (i = 0; i < NCH(n); ++i) {\n\t        try {\n\t            ret = ret.sq$concat(parsestr(c, CHILD(n, i).value));\n\t        } catch (x) {\n\t            throw new Sk.builtin.SyntaxError(\"invalid string (possibly contains a unicode character)\", c.c_filename, CHILD(n, i).lineno);\n\t        }\n\t    }\n\t    return ret;\n\t}\n\n\tfunction parsenumber (c, s, lineno) {\n\t    var neg;\n\t    var val;\n\t    var tmp;\n\t    var end = s.charAt(s.length - 1);\n\n\t    // call internal complex type constructor for complex strings\n\t    if (end === \"j\" || end === \"J\") {\n\t        return Sk.builtin.complex.complex_subtype_from_string(s);\n\t    }\n\n\t    // Handle longs\n\t    if (end === \"l\" || end === \"L\") {\n\t        return Sk.longFromStr(s.substr(0, s.length - 1), 0);\n\t    }\n\n\t    // todo; we don't currently distinguish between int and float so\n\t    // str is wrong for these.\n\t    if (s.indexOf(\".\") !== -1) {\n\t        return new Sk.builtin.float_(parseFloat(s));\n\t    }\n\n\t    // Handle integers of various bases\n\t    tmp = s;\n\t    neg = false;\n\t    if (s.charAt(0) === \"-\") {\n\t        tmp = s.substr(1);\n\t        neg = true;\n\t    }\n\n\t    if (tmp.charAt(0) === \"0\" && (tmp.charAt(1) === \"x\" || tmp.charAt(1) === \"X\")) {\n\t        // Hex\n\t        tmp = tmp.substring(2);\n\t        val = parseInt(tmp, 16);\n\t    } else if ((s.indexOf(\"e\") !== -1) || (s.indexOf(\"E\") !== -1)) {\n\t        // Float with exponent (needed to make sure e/E wasn't hex first)\n\t        return new Sk.builtin.float_(parseFloat(s));\n\t    } else if (tmp.charAt(0) === \"0\" && (tmp.charAt(1) === \"b\" || tmp.charAt(1) === \"B\")) {\n\t        // Binary\n\t        tmp = tmp.substring(2);\n\t        val = parseInt(tmp, 2);\n\t    } else if (tmp.charAt(0) === \"0\") {\n\t        if (tmp === \"0\") {\n\t            // Zero\n\t            val = 0;\n\t        } else {\n\t            // Octal\n\t            tmp = tmp.substring(1);\n\t            if ((tmp.charAt(0) === \"o\") || (tmp.charAt(0) === \"O\")) {\n\t                tmp = tmp.substring(1);\n\t            }\n\t            val = parseInt(tmp, 8);\n\t        }\n\t    }\n\t    else {\n\t        // Decimal\n\t        val = parseInt(tmp, 10);\n\t    }\n\n\t    // Convert to long\n\t    if (val > Sk.builtin.int_.threshold$ &&\n\t        Math.floor(val) === val &&\n\t        (s.indexOf(\"e\") === -1 && s.indexOf(\"E\") === -1)) {\n\t        return Sk.longFromStr(s, 0);\n\t    }\n\n\t    // Small enough, return parsed number\n\t    if (neg) {\n\t        return new Sk.builtin.int_(-val);\n\t    } else {\n\t        return new Sk.builtin.int_(val);\n\t    }\n\t}\n\n\tfunction astForSlice (c, n) {\n\t    var n2;\n\t    var step;\n\t    var upper;\n\t    var lower;\n\t    var ch;\n\t    REQ(n, SYM.subscript);\n\n\t    /*\n\t     subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]\n\t     sliceop: ':' [test]\n\t     */\n\t    ch = CHILD(n, 0);\n\t    lower = null;\n\t    upper = null;\n\t    step = null;\n\t    if (ch.type === TOK.T_DOT) {\n\t        return new Ellipsis();\n\t    }\n\t    if (NCH(n) === 1 && ch.type === SYM.test) {\n\t        return new Index(astForExpr(c, ch));\n\t    }\n\t    if (ch.type === SYM.test) {\n\t        lower = astForExpr(c, ch);\n\t    }\n\t    if (ch.type === TOK.T_COLON) {\n\t        if (NCH(n) > 1) {\n\t            n2 = CHILD(n, 1);\n\t            if (n2.type === SYM.test) {\n\t                upper = astForExpr(c, n2);\n\t            }\n\t        }\n\t    }\n\t    else if (NCH(n) > 2) {\n\t        n2 = CHILD(n, 2);\n\t        if (n2.type === SYM.test) {\n\t            upper = astForExpr(c, n2);\n\t        }\n\t    }\n\n\t    ch = CHILD(n, NCH(n) - 1);\n\t    if (ch.type === SYM.sliceop) {\n\t        if (NCH(ch) === 1) {\n\t            ch = CHILD(ch, 0);\n\t            step = new Name(strobj(\"None\"), Load, ch.lineno, ch.col_offset);\n\t        }\n\t        else {\n\t            ch = CHILD(ch, 1);\n\t            if (ch.type === SYM.test) {\n\t                step = astForExpr(c, ch);\n\t            }\n\t        }\n\t    }\n\t    return new Slice(lower, upper, step);\n\t}\n\n\tfunction astForAtom(c, n) {\n\t    /* atom: ('(' [yield_expr|testlist_comp] ')' |\n\t       '[' [listmaker] ']' |\n\t       '{' [dictorsetmaker] '}' |\n\t       '`' testlist1 '`' |\n\t       NAME | NUMBER | STRING+)\n\t    */\n\t    var i;\n\t    var values;\n\t    var keys;\n\t    var size;\n\t    var ch = CHILD(n, 0);\n\t    var elts;\n\t    switch (ch.type) {\n\t        case TOK.T_NAME:\n\t            // All names start in Load context, but may be changed later\n\t            return new Name(strobj(ch.value), Load, n.lineno, n.col_offset);\n\t        case TOK.T_STRING:\n\t            return new Str(parsestrplus(c, n), n.lineno, n.col_offset);\n\t        case TOK.T_NUMBER:\n\t            return new Num(parsenumber(c, ch.value, n.lineno), n.lineno, n.col_offset);\n\t        case TOK.T_LPAR: // various uses for parens\n\t            ch = CHILD(n, 1);\n\t            if (ch.type === TOK.T_RPAR) {\n\t                return new Tuple([], Load, n.lineno, n.col_offset);\n\t            }\n\t            if (ch.type === SYM.yield_expr) {\n\t                return astForExpr(c, ch);\n\t            }\n\t            //            if (NCH(ch) > 1 && CHILD(ch, 1).type === SYM.comp_for) {\n\t            //                return astForComprehension(c, ch);\n\t            //            }\n\t            return astForTestlistComp(c, ch);\n\t        case TOK.T_LSQB: // list or listcomp\n\t            ch = CHILD(n, 1);\n\t            if (ch.type === TOK.T_RSQB) {\n\t                return new List([], Load, n.lineno, n.col_offset);\n\t            }\n\t            REQ(ch, SYM.listmaker);\n\t            if (NCH(ch) === 1 || CHILD(ch, 1).type === TOK.T_COMMA) {\n\t                return new List(seqForTestlist(c, ch), Load, n.lineno, n.col_offset);\n\t            } \n\t            return astForListcomp(c, ch);\n\t            \n\t        case TOK.T_LBRACE:\n\t            /* dictorsetmaker: \n\t             *     (test ':' test (comp_for : (',' test ':' test)* [','])) |\n\t             *     (test (comp_for | (',' test)* [',']))\n\t             */\n\t            keys = [];\n\t            values = [];\n\t            ch = CHILD(n, 1);\n\t            if (n.type === TOK.T_RBRACE) {\n\t                //it's an empty dict\n\t                return new Dict([], null, n.lineno, n.col_offset);\n\t            } \n\t            else if (NCH(ch) === 1 || (NCH(ch) !== 0 && CHILD(ch, 1).type === TOK.T_COMMA)) {\n\t                //it's a simple set\n\t                elts = [];\n\t                size = Math.floor((NCH(ch) + 1) / 2);\n\t                for (i = 0; i < NCH(ch); i += 2) {\n\t                    var expression = astForExpr(c, CHILD(ch, i));\n\t                    elts[i / 2] = expression;\n\t                }\n\t                return new Set(elts, n.lineno, n.col_offset);\n\t            } \n\t            else if (NCH(ch) !== 0 && CHILD(ch, 1).type == SYM.comp_for) {\n\t                //it's a set comprehension\n\t                return astForSetComp(c, ch);\n\t            } \n\t            else if (NCH(ch) > 3 && CHILD(ch, 3).type === SYM.comp_for) {\n\t                //it's a dict compr. I think.\n\t                return astForDictComp(c, ch);\n\t            } \n\t            else {\n\t                size = Math.floor((NCH(ch) + 1) / 4); // + 1 for no trailing comma case\n\t                for (i = 0; i < NCH(ch); i += 4) {\n\t                    keys[i / 4] = astForExpr(c, CHILD(ch, i));\n\t                    values[i / 4] = astForExpr(c, CHILD(ch, i + 2));\n\t                }\n\t                return new Dict(keys, values, n.lineno, n.col_offset);\n\t            }\n\t        case TOK.T_BACKQUOTE:\n\t            //throw new Sk.builtin.SyntaxError(\"backquote not supported, use repr()\", c.c_filename, n.lineno);\n\t            return new Repr(astForTestlist(c, CHILD(n, 1)), n.lineno, n.col_offset);\n\t        default:\n\t            goog.asserts.fail(\"unhandled atom\", ch.type);\n\n\t    }\n\t}\n\n\tfunction astForPower (c, n) {\n\t    /* power: atom trailer* ('**' factor)*\n\t     */\n\t    var f;\n\t    var tmp;\n\t    var ch;\n\t    var i;\n\t    var e;\n\t    REQ(n, SYM.power);\n\t    e = astForAtom(c, CHILD(n, 0));\n\t    if (NCH(n) === 1) {\n\t        return e;\n\t    }\n\t    for (i = 1; i < NCH(n); ++i) {\n\t        ch = CHILD(n, i);\n\t        if (ch.type !== SYM.trailer) {\n\t            break;\n\t        }\n\t        tmp = astForTrailer(c, ch, e);\n\t        tmp.lineno = e.lineno;\n\t        tmp.col_offset = e.col_offset;\n\t        e = tmp;\n\t    }\n\t    if (CHILD(n, NCH(n) - 1).type === SYM.factor) {\n\t        f = astForExpr(c, CHILD(n, NCH(n) - 1));\n\t        e = new BinOp(e, Pow, f, n.lineno, n.col_offset);\n\t    }\n\t    return e;\n\t}\n\n\tfunction astForExpr (c, n) {\n\t    /* handle the full range of simple expressions\n\t     test: or_test ['if' or_test 'else' test] | lambdef\n\t     or_test: and_test ('or' and_test)*\n\t     and_test: not_test ('and' not_test)*\n\t     not_test: 'not' not_test | comparison\n\t     comparison: expr (comp_op expr)*\n\t     expr: xor_expr ('|' xor_expr)*\n\t     xor_expr: and_expr ('^' and_expr)*\n\t     and_expr: shift_expr ('&' shift_expr)*\n\t     shift_expr: arith_expr (('<<'|'>>') arith_expr)*\n\t     arith_expr: term (('+'|'-') term)*\n\t     term: factor (('*'|'/'|'%'|'//') factor)*\n\t     factor: ('+'|'-'|'~') factor | power\n\t     power: atom trailer* ('**' factor)*\n\n\t     As well as modified versions that exist for backward compatibility,\n\t     to explicitly allow:\n\t     [ x for x in lambda: 0, lambda: 1 ]\n\t     (which would be ambiguous without these extra rules)\n\n\t     old_test: or_test | old_lambdef\n\t     old_lambdef: 'lambda' [vararglist] ':' old_test\n\n\t     */\n\n\t    var exp;\n\t    var cmps;\n\t    var ops;\n\t    var i;\n\t    var seq;\n\t    LOOP: while (true) {\n\t        switch (n.type) {\n\t            case SYM.test:\n\t            case SYM.old_test:\n\t                if (CHILD(n, 0).type === SYM.lambdef || CHILD(n, 0).type === SYM.old_lambdef) {\n\t                    return astForLambdef(c, CHILD(n, 0));\n\t                }\n\t                else if (NCH(n) > 1) {\n\t                    return astForIfexpr(c, n);\n\t                }\n\t            // fallthrough\n\t            case SYM.or_test:\n\t            case SYM.and_test:\n\t                if (NCH(n) === 1) {\n\t                    n = CHILD(n, 0);\n\t                    continue LOOP;\n\t                }\n\t                seq = [];\n\t                for (i = 0; i < NCH(n); i += 2) {\n\t                    seq[i / 2] = astForExpr(c, CHILD(n, i));\n\t                }\n\t                if (CHILD(n, 1).value === \"and\") {\n\t                    return new BoolOp(And, seq, n.lineno, n.col_offset);\n\t                }\n\t                goog.asserts.assert(CHILD(n, 1).value === \"or\");\n\t                return new BoolOp(Or, seq, n.lineno, n.col_offset);\n\t            case SYM.not_test:\n\t                if (NCH(n) === 1) {\n\t                    n = CHILD(n, 0);\n\t                    continue LOOP;\n\t                }\n\t                else {\n\t                    return new UnaryOp(Not, astForExpr(c, CHILD(n, 1)), n.lineno, n.col_offset);\n\t                }\n\t                break;\n\t            case SYM.comparison:\n\t                if (NCH(n) === 1) {\n\t                    n = CHILD(n, 0);\n\t                    continue LOOP;\n\t                }\n\t                else {\n\t                    ops = [];\n\t                    cmps = [];\n\t                    for (i = 1; i < NCH(n); i += 2) {\n\t                        ops[(i - 1) / 2] = astForCompOp(c, CHILD(n, i));\n\t                        cmps[(i - 1) / 2] = astForExpr(c, CHILD(n, i + 1));\n\t                    }\n\t                    return new Compare(astForExpr(c, CHILD(n, 0)), ops, cmps, n.lineno, n.col_offset);\n\t                }\n\t                break;\n\t            case SYM.expr:\n\t            case SYM.xor_expr:\n\t            case SYM.and_expr:\n\t            case SYM.shift_expr:\n\t            case SYM.arith_expr:\n\t            case SYM.term:\n\t                if (NCH(n) === 1) {\n\t                    n = CHILD(n, 0);\n\t                    continue LOOP;\n\t                }\n\t                return astForBinop(c, n);\n\t            case SYM.yield_expr:\n\t                exp = null;\n\t                if (NCH(n) === 2) {\n\t                    exp = astForTestlist(c, CHILD(n, 1));\n\t                }\n\t                return new Yield(exp, n.lineno, n.col_offset);\n\t            case SYM.factor:\n\t                if (NCH(n) === 1) {\n\t                    n = CHILD(n, 0);\n\t                    continue LOOP;\n\t                }\n\t                return astForFactor(c, n);\n\t            case SYM.power:\n\t                return astForPower(c, n);\n\t            default:\n\t                goog.asserts.fail(\"unhandled expr\", \"n.type: %d\", n.type);\n\t        }\n\t        break;\n\t    }\n\t}\n\n\tfunction astForPrintStmt (c, n) {\n\t    /* print_stmt: 'print' ( [ test (',' test)* [','] ]\n\t     | '>>' test [ (',' test)+ [','] ] )\n\t     */\n\t    var nl;\n\t    var i, j;\n\t    var seq;\n\t    var start = 1;\n\t    var dest = null;\n\t    REQ(n, SYM.print_stmt);\n\t    if (NCH(n) >= 2 && CHILD(n, 1).type === TOK.T_RIGHTSHIFT) {\n\t        dest = astForExpr(c, CHILD(n, 2));\n\t        start = 4;\n\t    }\n\t    seq = [];\n\t    for (i = start, j = 0; i < NCH(n); i += 2, ++j) {\n\t        seq[j] = astForExpr(c, CHILD(n, i));\n\t    }\n\t    nl = (CHILD(n, NCH(n) - 1)).type === TOK.T_COMMA ? false : true;\n\t    return new Print(dest, seq, nl, n.lineno, n.col_offset);\n\t}\n\n\tfunction astForStmt (c, n) {\n\t    var ch;\n\t    if (n.type === SYM.stmt) {\n\t        goog.asserts.assert(NCH(n) === 1);\n\t        n = CHILD(n, 0);\n\t    }\n\t    if (n.type === SYM.simple_stmt) {\n\t        goog.asserts.assert(numStmts(n) === 1);\n\t        n = CHILD(n, 0);\n\t    }\n\t    if (n.type === SYM.small_stmt) {\n\t        REQ(n, SYM.small_stmt);\n\t        n = CHILD(n, 0);\n\t        /* small_stmt: expr_stmt | print_stmt  | del_stmt | pass_stmt\n\t         | flow_stmt | import_stmt | global_stmt | exec_stmt\n\t         | assert_stmt\n\t         */\n\t        switch (n.type) {\n\t            case SYM.expr_stmt:\n\t                return astForExprStmt(c, n);\n\t            case SYM.print_stmt:\n\t                return astForPrintStmt(c, n);\n\t            case SYM.del_stmt:\n\t                return astForDelStmt(c, n);\n\t            case SYM.pass_stmt:\n\t                return new Pass(n.lineno, n.col_offset);\n\t            case SYM.flow_stmt:\n\t                return astForFlowStmt(c, n);\n\t            case SYM.import_stmt:\n\t                return astForImportStmt(c, n);\n\t            case SYM.global_stmt:\n\t                return astForGlobalStmt(c, n);\n\t            case SYM.exec_stmt:\n\t                return astForExecStmt(c, n);\n\t            case SYM.assert_stmt:\n\t                return astForAssertStmt(c, n);\n\t            case SYM.debugger_stmt:\n\t                return new Debugger_(n.lineno, n.col_offset);\n\t            default:\n\t                goog.asserts.fail(\"unhandled small_stmt\");\n\t        }\n\t    }\n\t    else {\n\t        /* compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt\n\t         | funcdef | classdef | decorated\n\t         */\n\t        ch = CHILD(n, 0);\n\t        REQ(n, SYM.compound_stmt);\n\t        switch (ch.type) {\n\t            case SYM.if_stmt:\n\t                return astForIfStmt(c, ch);\n\t            case SYM.while_stmt:\n\t                return astForWhileStmt(c, ch);\n\t            case SYM.for_stmt:\n\t                return astForForStmt(c, ch);\n\t            case SYM.try_stmt:\n\t                return astForTryStmt(c, ch);\n\t            case SYM.with_stmt:\n\t                return astForWithStmt(c, ch);\n\t            case SYM.funcdef:\n\t                return astForFuncdef(c, ch, []);\n\t            case SYM.classdef:\n\t                return astForClassdef(c, ch, []);\n\t            case SYM.decorated:\n\t                return astForDecorated(c, ch);\n\t            default:\n\t                goog.asserts.assert(\"unhandled compound_stmt\");\n\t        }\n\t    }\n\t}\n\n\tSk.astFromParse = function (n, filename, c_flags) {\n\t    var j;\n\t    var num;\n\t    var ch;\n\t    var i;\n\t    var c = new Compiling(\"utf-8\", filename, c_flags);\n\t    var stmts = [];\n\t    var k = 0;\n\t    switch (n.type) {\n\t        case SYM.file_input:\n\t            for (i = 0; i < NCH(n) - 1; ++i) {\n\t                ch = CHILD(n, i);\n\t                if (n.type === TOK.T_NEWLINE) {\n\t                    continue;\n\t                }\n\t                REQ(ch, SYM.stmt);\n\t                num = numStmts(ch);\n\t                if (num === 1) {\n\t                    stmts[k++] = astForStmt(c, ch);\n\t                }\n\t                else {\n\t                    ch = CHILD(ch, 0);\n\t                    REQ(ch, SYM.simple_stmt);\n\t                    for (j = 0; j < num; ++j) {\n\t                        stmts[k++] = astForStmt(c, CHILD(ch, j * 2));\n\t                    }\n\t                }\n\t            }\n\t            return new Module(stmts);\n\t        case SYM.eval_input:\n\t            goog.asserts.fail(\"todo;\");\n\t        case SYM.single_input:\n\t            goog.asserts.fail(\"todo;\");\n\t        default:\n\t            goog.asserts.fail(\"todo;\");\n\t    }\n\t};\n\n\tSk.astDump = function (node) {\n\t    var spaces = function (n) // todo; blurgh\n\t    {\n\t        var i;\n\t        var ret = \"\";\n\t        for (i = 0; i < n; ++i) {\n\t            ret += \" \";\n\t        }\n\t        return ret;\n\t    };\n\n\t    var _format = function (node, indent) {\n\t        var ret;\n\t        var elemsstr;\n\t        var x;\n\t        var elems;\n\t        var fieldstr;\n\t        var field;\n\t        var attrs;\n\t        var fieldlen;\n\t        var b;\n\t        var a;\n\t        var i;\n\t        var fields;\n\t        var namelen;\n\t        if (node === null) {\n\t            return indent + \"None\";\n\t        }\n\t        else if (node.prototype && node.prototype._astname !== undefined && node.prototype._isenum) {\n\t            return indent + node.prototype._astname + \"()\";\n\t        }\n\t        else if (node._astname !== undefined) {\n\t            namelen = spaces(node._astname.length + 1);\n\t            fields = [];\n\t            for (i = 0; i < node._fields.length; i += 2) // iter_fields\n\t            {\n\t                a = node._fields[i]; // field name\n\t                b = node._fields[i + 1](node); // field getter func\n\t                fieldlen = spaces(a.length + 1);\n\t                fields.push([a, _format(b, indent + namelen + fieldlen)]);\n\t            }\n\t            attrs = [];\n\t            for (i = 0; i < fields.length; ++i) {\n\t                field = fields[i];\n\t                attrs.push(field[0] + \"=\" + field[1].replace(/^\\s+/, \"\"));\n\t            }\n\t            fieldstr = attrs.join(\",\\n\" + indent + namelen);\n\t            return indent + node._astname + \"(\" + fieldstr + \")\";\n\t        }\n\t        else if (goog.isArrayLike(node)) {\n\t            //Sk.debugout(\"arr\", node.length);\n\t            elems = [];\n\t            for (i = 0; i < node.length; ++i) {\n\t                x = node[i];\n\t                elems.push(_format(x, indent + \" \"));\n\t            }\n\t            elemsstr = elems.join(\",\\n\");\n\t            return indent + \"[\" + elemsstr.replace(/^\\s+/, \"\") + \"]\";\n\t        }\n\t        else {\n\t            if (node === true) {\n\t                ret = \"True\";\n\t            }\n\t            else if (node === false) {\n\t                ret = \"False\";\n\t            }\n\t            else if (node instanceof Sk.builtin.lng) {\n\t                ret = node.tp$str().v;\n\t            }\n\t            else if (node instanceof Sk.builtin.str) {\n\t                ret = node[\"$r\"]().v;\n\t            }\n\t            else {\n\t                ret = \"\" + node;\n\t            }\n\t            return indent + ret;\n\t        }\n\t    };\n\n\t    return _format(node, \"\");\n\t};\n\n\tgoog.exportSymbol(\"Sk.astFromParse\", Sk.astFromParse);\n\tgoog.exportSymbol(\"Sk.astDump\", Sk.astDump);\n\n\n\n\t/* ---- /Users/rob/skulpty/lib/afterword.js ---- */ \n\n\tfunction wrapAstThing(fx, argpos, debug) {\n\t\targpos = argpos || 2;\n\t\treturn function(x) {\n\t\t\tvar n = arguments[argpos-1];\n\t\t\tvar result = fx.apply(undefined, arguments);\n\t\t\tresult.range = n.range;\n\t\t\tresult.str = n.str;\n\t\t\tresult.loc = n.loc;\n\t\t\tif ( debug ) {\n\t\t\t\tconsole.log(n);\n\t\t\t\tconsole.log(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t}\n\n\tastForAtom = wrapAstThing(astForAtom);\n\tastForCompOp = wrapAstThing(astForCompOp);\n\tastForSuite = wrapAstThing(astForSuite);\n\tastForExceptClause = wrapAstThing(astForExceptClause);\n\tastForDottedName = wrapAstThing(astForDottedName);\n\tastForDecorator = wrapAstThing(astForDecorator);\n\tastForDecorators = wrapAstThing(astForDecorators);\n\tastForDecorated = wrapAstThing(astForDecorated);\n\tastForWithVar = wrapAstThing(astForWithVar);\n\tastForWithStmt = wrapAstThing(astForWithStmt);\n\tastForExecStmt = wrapAstThing(astForExecStmt);\n\tastForIfStmt = wrapAstThing(astForIfStmt);\n\tastForExprlist = wrapAstThing(astForExprlist);\n\tastForDelStmt = wrapAstThing(astForDelStmt);\n\tastForGlobalStmt = wrapAstThing(astForGlobalStmt);\n\tastForAssertStmt = wrapAstThing(astForAssertStmt);\n\tastForImportStmt = wrapAstThing(astForImportStmt);\n\tastForTestlistComp = wrapAstThing(astForTestlistComp);\n\tastForListcomp = wrapAstThing(astForListcomp);\n\tastForFactor = wrapAstThing(astForFactor);\n\tastForForStmt = wrapAstThing(astForForStmt);\n\tastForTrailer = wrapAstThing(astForTrailer);\n\tastForFlowStmt = wrapAstThing(astForFlowStmt);\n\tastForArguments = wrapAstThing(astForArguments);\n\tastForFuncdef = wrapAstThing(astForFuncdef);\n\tastForClassBases = wrapAstThing(astForClassBases);\n\tastForClassdef = wrapAstThing(astForClassdef);\n\tastForLambdef = wrapAstThing(astForLambdef);\n\tastForComprehension = wrapAstThing(astForComprehension);\n\tastForIterComp = wrapAstThing(astForIterComp);\n\tastForDictComp = wrapAstThing(astForDictComp);\n\tastForGenExpr = wrapAstThing(astForGenExpr);\n\tastForSetComp = wrapAstThing(astForSetComp);\n\tastForWhileStmt = wrapAstThing(astForWhileStmt);\n\tastForAugassign = wrapAstThing(astForAugassign);\n\tastForBinop = wrapAstThing(astForBinop);\n\tastForTestlist = wrapAstThing(astForTestlist);\n\tastForExprStmt = wrapAstThing(astForExprStmt);\n\tastForIfexpr = wrapAstThing(astForIfexpr);\n\tastForExpr = wrapAstThing(astForExpr);\n\tSk.astFromParse = wrapAstThing(Sk.astFromParse, 1);\n\n\tSk.nameForToken = function(v) {\n\t\tif ( typeof v === \"string\" ) return v;\n\t\tfor ( var name in Sk.Tokenizer.Tokens ) {\n\t\t\tif ( Sk.Tokenizer.Tokens[name] == v ) return name;\n\t\t}\n\t\tif ( v in Sk.ParseTables.number2symbol ) {\n\t\t\treturn Sk.ParseTables.number2symbol[v];\n\t\t}\n\n\t\treturn '???:' + v;\n\t};\n\n\t//Sk.python3 = true;\n\tSk.Parser = Parser;\n\tSk.builtin.str.prototype.valueOf = function() { return this.v; };\n\tSk.builtin.str.prototype.toString = function() { return this.v; };\n\n\tSk.builtin.SyntaxError = function(str, file, line, ctx, extra) {\n\t\tvar err = new SyntaxError(str, file, line);\n\t\terr.context = ctx;\n\t\terr.extra = extra;\n\t\terr.line = line;\n\t\treturn err;\n\t};\n\n\tSk.builtin.IndentationError = function(str, file, line, row, extra) {\n\t\tvar err = new SyntaxError('Indentation Error: ' + str, file, line);\n\t\terr.context = [[line, row], [line, row]];\n\t\terr.extra = {\n\t\t};\n\t\terr.line = line;\n\t\treturn err;\n\t};\n\n\n\tmodule.exports = Sk;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tvar isArray = Array.isArray;\n\n\t//TODO: Find a way to not have to do this.\n\tfunction getOpName(op) {\n\t\tif (op.prototype._astname) {\n\t\t\treturn op.prototype._astname;\n\t\t}\n\t\tthrow new Error(\"Coudlnt decode operator name for: \" + (op.name || op.toString()));\n\t}\n\n\tfunction abort(why) {\n\t\tconsole.log(new Error(\"ABORT:\" + why).stack);\n\t\tthrow new Error(why);\n\t}\n\n\tfunction isExpression(n) {\n\t\treturn /Expression$/.test(n.type);\n\t}\n\n\tvar idx = 0;\n\tfunction createTempName(hint) {\n\t\treturn '__temp$' + hint + '$' + idx++;\n\t}\n\n\tfunction ensureStatement(s) {\n\t\tvar f = s;\n\t\tif ( !isArray(s) ) f = [f];\n\t\tfor ( var i = 0; i < f.length; ++i ) {\n\t\t\tvar v = f[i];\n\t\t\tif ( isExpression(v) ) {\n\t\t\t\tf[i] = {type: \"ExpressionStatement\", expression: v};\n\t\t\t}\n\t\t}\n\n\t\tif ( isArray(s) ) return s;\n\t\telse return f[0];\n\t}\n\n\tfunction ident(n) {\n\t\treturn {type: \"Identifier\", name: n.valueOf()};\n\t}\n\n\tfunction member(o, p) {\n\t\treturn {\n\t\t\ttype: \"MemberExpression\",\n\t\t\tobject: o,\n\t\t\tproperty: p,\n\t\t\tcomputed: false\n\t\t};\n\t}\n\n\tfunction literal(v) {\n\t\tif ( typeof v === 'object' ) v = v.valueOf();\n\n\t\tif ( typeof v === 'number' && (1 / v !== 1 / Math.abs(v)) ) {\n\t\t\treturn {type: \"UnaryExpression\", argument: literal(-v), operator: '-' };\n\t\t}\n\n\t\treturn {type: \"Literal\", value: v, raw: JSON.stringify(v)};\n\t}\n\n\tfunction binOp(left, op, right) {\n\t\treturn {\n\t\t\ttype: \"BinaryExpression\",\n\t\t\tleft: left,\n\t\t\tright: right,\n\t\t\toperator: op\n\t\t};\n\t}\n\n\tfunction logicOp(left, op, right) {\n\t\treturn {\n\t\t\ttype: \"LogicalExpression\",\n\t\t\tleft: left,\n\t\t\tright: right,\n\t\t\toperator: op\n\t\t};\n\t}\n\n\tfunction ternary(cond, a, b) {\n\t\treturn {\n\t\t\ttype: \"ConditionalExpression\",\n\t\t\ttest: cond,\n\t\t\tconsequent: a,\n\t\t\talternate: b\n\t\t};\n\t}\n\n\tfunction var_(name, init) {\n\t\treturn {\n\t\t\ttype: \"VariableDeclaration\",\n\t\t\tkind: 'var',\n\t\t\tdeclarations: [{\n\t\t\t\ttype: \"VariableDeclarator\",\n\t\t\t\tid: name,\n\t\t\t\tinit: init ? init : undefined\n\t\t\t}]\n\t\t};\n\t}\n\n\tfunction transform(node, ctx) {\n\t\t//console.log(node.lineno, node.col_offset);\n\t\tvar result = dispatch(node, ctx);\n\t\tif ( node.range ) result.range = [node.range[0], node.range[1]];\n\t\tif ( node.loc ) result.loc = node.loc;\n\t\tresult.str = node.str;\n\t\treturn result;\n\t}\n\n\tfunction dispatch(node, ctx) {\n\t\tif ( !ctx.locals ) ctx.locals = Object.create(null);\n\n\t\tif ( !node ) {\n\t\t\tconsole.log(\"WAT!\", new Error().stack);\n\t\t\tthrow new Error(\"What?\");\n\t\t}\n\t\tif ( isArray(node) ) {\n\t\t\tvar body = [];\n\t\t\tfor ( var i = 0; i < node.length; ++i ) {\n\t\t\t\tvar r = transform(node[i], ctx);\n\t\t\t\tif ( isArray(r) ) body.push.apply(body, r);\n\t\t\t\telse body.push(r);\n\t\t\t}\n\t\t\treturn body;\n\t\t}\n\t\tswitch (node._astname) {\n\t\t\tcase 'Attribute': return transformAttribute(node, ctx);\n\t\t\tcase 'Assign': return transformAssign(node, ctx);\n\t\t\tcase 'AugAssign': return transformAugAssign(node, ctx);\n\t\t\tcase 'BinOp': return transformBinOp(node, ctx);\n\t\t\tcase 'BoolOp': return transformBoolOp(node, ctx);\n\t\t\tcase 'Break': return transformBreak(node, ctx);\n\t\t\tcase 'Call': return transformCall(node, ctx);\n\t\t\tcase 'ClassDef': return transformClassDef(node, ctx);\n\t\t\tcase 'Continue': return tranformContinue(node, ctx);\n\t\t\tcase 'Compare': return transformCompare(node, ctx);\n\t\t\tcase 'Dict': return transformDict(node, ctx);\n\t\t\tcase 'Delete': return transformDel(node, ctx);\n\t\t\tcase 'Expr': return transformExpr(node, ctx);\n\t\t\tcase 'For': return transformFor(node, ctx);\n\t\t\tcase 'FunctionDef': return transformFunctionDef(node, ctx);\n\t\t\tcase 'GeneratorExp': return transformListComp(node, ctx); //TODO: Make this seperate\n\t\t\tcase 'Global': return transformGlobal(node, ctx);\n\t\t\tcase 'If': return transformIf(node, ctx);\n\t\t\tcase 'Import': return NoOp();\n\t\t\tcase 'Lambda': return transformLambda(node, ctx);\n\t\t\tcase 'List': return transformList(node, ctx);\n\t\t\tcase 'ListComp': return transformListComp(node, ctx);\n\t\t\tcase 'Module': return transformModule(node, ctx);\n\t\t\tcase 'Name': return transformName(node, ctx);\n\t\t\tcase 'Print': return transformPrint(node, ctx);\n\t\t\tcase 'Return': return transformReturn(node, ctx);\n\t\t\tcase 'Str': return transformStr(node, ctx);\n\t\t\tcase 'Subscript': return transformSubscript(node, ctx);\n\t\t\tcase 'Tuple': return transformTuple(node, ctx);\n\t\t\tcase 'Num': return transformNum(node, ctx);\n\t\t\tcase 'Pass': return transformPass(node, ctx);\n\t\t\tcase 'UnaryOp': return transformUnaryOp(node, ctx);\n\t\t\tcase 'While': return transformWhile(node, ctx);\n\t\t\tdefault:\n\t\t\t\tconsole.log(\"Dont know how to transform: \" + node._astname);\n\t\t\t\tconsole.log(JSON.stringify(node, null, '  '));\n\t\t\t\tthrow new Error(\"Dont know how to transform: \" + node._astname);\n\t\t}\n\t}\n\n\tfunction NoOp() { return []; }\n\n\n\n\tfunction makeVariableName(name) {\n\t\tvar parts = Array.isArray(name) ? name : name.split(/\\./g);\n\t\tif ( parts.length === 1 ) return ident(name);\n\t\tvar prop = parts.pop();\n\t\treturn member(makeVariableName(parts), ident(prop));\n\t}\n\n\tfunction transformAttribute(node, ctx) {\n\t\tvar n = node.attr;\n\t\tif ( n._astname ) n = transform(n, ctx);\n\t\telse n = {type: 'Identifier', name: n.valueOf()};\n\t\treturn member(transform(node.value, ctx), n);\n\t}\n\n\tfunction transformAugAssign(node, ctx) {\n\t\t//TODO: We need to not inject left into the code twice\n\t\t//as it could have side effects.\n\t\tvar right = transform(node.value, ctx);\n\t\tvar left = transform(node.target, ctx);\n\t\tvar tn = createTempName(\"left\");\n\t\tvar opName = getOpName(node.op);\n\t\treturn [\n\t\t\tvar_(ident(tn), left),\n\t\t\tensureStatement({\n\t\t\t\ttype: \"AssignmentExpression\",\n\t\t\t\toperator: '=',\n\t\t\t\tleft: left,\n\t\t\t\tright: createBinOp(left, opName, right)\n\t\t\t})\n\t\t];\n\t}\n\n\tfunction transformAssign(node, ctx) {\n\n\t\tvar results = [];\n\t\tfor ( var i = 0; i < node.targets.length; ++i ) {\n\t\t\tvar left = node.targets[i];\n\t\t\tif ( ctx.writeTarget ) {\n\t\t\t\tleft = member(ctx.writeTarget, transform(left,ctx));\n\t\t\t}\n\t\t\tresults.push.apply(results,createTupleUnpackingAssign(left, transform(node.value, ctx), ctx));\n\t\t\n\t\t}\n\t\tif ( results.length == 1 ) return results[0];\n\t\treturn {type: \"BlockStatement\", body: results}; \n\t}\n\n\tfunction createBinOp(left, op, right) {\n\n\t\tif ( op === 'FloorDiv' ) {\n\t\t\treturn {\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: makeVariableName('Math.floor'),\n\t\t\t\targuments: [{\n\t\t\t\t\ttype: \"BinaryExpression\",\n\t\t\t\t\tleft: left,\n\t\t\t\t\tright: right,\n\t\t\t\t\toperator: '/'\n\t\t\t\t}]\n\t\t\t};\n\t\t}\n\n\t\tvar fxOps = {\n\t\t\t\"Add\": \"__pythonRuntime.ops.add\",\n\t\t\t\"Mult\": \"__pythonRuntime.ops.multiply\",\n\t\t\t\"Pow\": \"Math.pow\"\n\t\t};\n\n\t\tif ( op in fxOps  ) {\n\t\t\tvar call = {\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: makeVariableName(fxOps[op]),\n\t\t\t\targuments: [left, right]\n\t\t\t};\n\t\t\treturn call;\n\t\t}\n\n\t\tvar operators = {\n\t\t\t\"Add\": \"+\",\n\t\t\t\"Sub\": \"-\",\n\t\t\t\"Mod\": \"%\",\n\t\t\t\"Div\": \"/\",\n\t\t\t\"BitAnd\": \"&\",\n\t\t\t\"BitOr\": \"|\",\n\t\t\t'BitXor': '^',\n\t\t\t\"LShift\": \"<<\",\n\t\t\t\"RShift\": \">>\"\n\n\t\t};\n\n\t\tif ( !(op in operators) ) abort(\"Unknown binary operator: \" + op);\n\n\t\treturn binOp(left, operators[op], right);\n\t}\n\n\tfunction transformBinOp(node, ctx) {\n\t\tvar left = transform(node.left, ctx);\n\t\tvar right = transform(node.right, ctx);\n\t\treturn createBinOp(left, getOpName(node.op), right);\n\t}\n\n\tfunction transformBoolOp(node, ctx) {\n\t\tvar fvals = new Array(node.values.length);\n\t\tfor ( var i = 0; i < node.values.length; ++i ) {\n\t\t\tfvals[i] = transform(node.values[i], ctx);\n\t\t}\n\t\tvar opName = getOpName(node.op);\n\t\tvar operators = {\n\t\t\t'And': '&&',\n\t\t\t'Or': '||'\n\t\t};\n\n\t\tif ( !(opName in operators ) ) abort(\"Unknown bool opeartor: \" + opName);\n\t\tvar opstr = operators[opName];\n\n\t\tvar result = fvals.pop();\n\t\twhile ( fvals.length > 0 ) {\n\t\t\tresult = logicOp(fvals.pop(), opstr, result);\n\t\t}\n\n\n\t\t//TODO: Support || as well?\n\t\treturn result;\n\t}\n\n\tfunction transformBreak(node, ctx) {\n\t\treturn {type: \"BreakStatement\"};\n\t}\n\n\tfunction transformCall(node, ctx) {\n\t\tvar builtins = ['len'];\n\t\tif ( node.func._astname == 'Name' ) {\n\t\t\tswitch ( node.func.id.v ) {\n\t\t\t\tcase 'len':\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"MemberExpression\",\n\t\t\t\t\t\tobject: transform(node.args[0], ctx),\n\t\t\t\t\t\tproperty: {type: \"Identifier\", name: \"length\"}\n\t\t\t\t\t};\n\t\t\t\tcase 'all': case 'ord':\n\t\t\t\tcase 'sum': case 'any':\n\t\t\t\tcase 'str': case 'chr':\n\t\t\t\tcase 'ascii': case 'divmod':\n\t\t\t\tcase 'range': case 'enumerate':\n\t\t\t\tcase 'round': case 'filter':\n\t\t\t\tcase 'abs': case 'float':\n\t\t\t\tcase 'int': case 'hex':\n\t\t\t\tcase 'tuple': case  'map':\n\t\t\t\tcase 'bool': case 'max':\n\t\t\t\tcase 'sorted': case 'min':\n\t\t\t\tcase 'list': case 'oct':\n\t\t\t\tcase 'pow': case  'reversed':\n\t\t\t\tcase 'repr':\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: 'CallExpression',\n\t\t\t\t\t\tcallee: makeVariableName('__pythonRuntime.functions.' + node.func.id.v),\n\t\t\t\t\t\targuments: transform(node.args, ctx)\n\t\t\t\t\t};\n\t\t\t\tcase 'dict':\n\t\t\t\t\tvar args = [];\n\t\t\t\t\tfor ( var i = 0; i < node.keywords.length; ++i ) {\n\t\t\t\t\t\targs.push({\n\t\t\t\t\t\t\ttype: \"ArrayExpression\",\n\t\t\t\t\t\t\telements: [\n\t\t\t\t\t\t\t\tliteral(node.keywords[i].arg.v),\n\t\t\t\t\t\t\t\ttransform(node.keywords[i].value, ctx)\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"NewExpression\",\n\t\t\t\t\t\tcallee: makeVariableName('__pythonRuntime.objects.dict'),\n\t\t\t\t\t\targuments: args\n\t\t\t\t\t};\n\n\t\t\t}\n\t\t}\n\n\t\tvar args = transform(node.args, ctx);\n\n\t\tif ( node.keywords.length > 0 ) {\n\t\t\tvar paramsDict = {\n\t\t\t\ttype: \"ObjectExpression\",\n\t\t\t\tproperties: [{\n\t\t\t\t\ttype: \"Property\",\n\t\t\t\t\tkey: ident(\"__kwp\"),\n\t\t\t\t\tvalue: literal(true)\n\t\t\t\t}]\n\t\t\t};\n\n\t\t\tfor ( var i = 0; i < node.keywords.length; ++i ) {\n\t\t\t\tvar k = node.keywords[i];\n\t\t\t\tparamsDict.properties.push({\n\t\t\t\t\ttype: \"Property\",\n\t\t\t\t\tkey: ident(k.arg.v),\n\t\t\t\t\tvalue: transform(k.value, ctx)\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar extraArg = {\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: makeVariableName('__pythonRuntime.utils.createParamsObj'),\n\t\t\t\targuments: [paramsDict]\n\t\t\t};\n\n\t\t\targs.push(extraArg);\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"CallExpression\",\n\t\t\tcallee: transform(node.func, ctx),\n\t\t\targuments: args\n\t\t};\n\t}\n\n\tfunction transformClassDef(node, ctx) {\n\t\tvar body = [];\n\t\tvar proto = member(ident(node.name), ident('prototype'));\n\t\tvar nctx = {\n\t\t\twriteTarget: proto,\n\t\t\tinClass: true,\n\t\t\tlocals: Object.create(null)\n\t\t};\n\n\t\tif ( node.bases.length > 1 ) alert(\"Multiple base classes not supported.\");\n\n\t\tvar base = (node.bases.length > 0) ? transform(node.bases[0], ctx) : undefined;\n\n\t\tvar ctorBody = [];\n\t\tctorBody.push({\n\t\t\ttype: \"VariableDeclaration\",\n\t\t\tkind: 'var',\n\t\t\tdeclarations: [{\n\t\t\t\ttype: \"VariableDeclarator\",\n\t\t\t\tid: ident('that'),\n\t\t\t\tinit: {type: \"ThisExpression\"}\n\t\t\t}]\n\t\t});\n\n\t\tctorBody.push({\n\t\t\ttype: \"IfStatement\",\n\t\t\ttest: {\n\t\t\t\ttype:\"UnaryExpression\",\n\t\t\t\targument: binOp(ident('that'), \"instanceof\", ident(node.name)),\n\t\t\t\toperator: \"!\"\n\t\t\t},\n\t\t\tconsequent: ensureStatement({\n\t\t\t\ttype: \"AssignmentExpression\",\n\t\t\t\tleft: ident('that'),\n\t\t\t\tright: {\n\t\t\t\t\ttype:  \"CallExpression\",\n\t\t\t\t\tcallee: makeVariableName('Object.create'),\n\t\t\t\t\targuments: [ proto ]\n\t\t\t\t},\n\t\t\t\toperator: '='\n\t\t\t})\n\t\t});\n\n\t\tctorBody.push({\n\t\t\ttype: \"IfStatement\",\n\t\t\ttest: {\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: member(proto, ident('hasOwnProperty')),\n\t\t\t\targuments: [literal('__init__')]\n\t\t\t},\n\t\t\tconsequent: ensureStatement({\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: member(member(proto, ident('__init__')), ident('apply')),\n\t\t\t\targuments: [ident('that'), ident('arguments')]\n\t\t\t})\n\t\t});\n\n\t\tif ( base ) {\n\t\t\tctorBody.push(ensureStatement({\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: {\n\t\t\t\t\ttype: \"MemberExpression\",\n\t\t\t\t\tobject: base,\n\t\t\t\t\tproperty: ident('apply'),\n\t\t\t\t\tcomputed: false\n\t\t\t\t},\n\t\t\t\targuments: [ident('that'), ident('arguments')]\n\t\t\t}));\n\t\t}\n\n\t\tctorBody.push({\n\t\t\ttype: \"ReturnStatement\",\n\t\t\targument: ident('that')\n\t\t});\n\n\n\t\tbody.push({\n\t\t\ttype: \"FunctionDeclaration\",\n\t\t\tid: ident(node.name),\n\t\t\tparams: [],\n\t\t\tbody: {type: \"BlockStatement\", body:ctorBody}\n\t\t});\n\n\t\tif ( base ) {\n\t\t\tbody.push({\n\t\t\t\ttype: \"AssignmentExpression\",\n\t\t\t\tleft: proto,\n\t\t\t\tright: {\n\t\t\t\t\ttype:  \"CallExpression\",\n\t\t\t\t\tcallee: makeVariableName('Object.create'),\n\t\t\t\t\targuments: [ member(base, ident('prototype')) ]\n\t\t\t\t},\n\t\t\t\toperator: \"=\"\n\t\t\t});\n\t\t}\n\n\t\tbody = body.concat(transform(node.body, nctx));\n\n\t\tbody.push({\n\t\t\ttype: \"ReturnStatement\",\n\t\t\targument: ident(node.name)\n\t\t});\n\n\t\treturn {\n\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\"declarations\": [\n\t\t\t{\n\t\t\t  \"type\": \"VariableDeclarator\",\n\t\t\t  \"id\": ident(node.name),\n\t\t\t  \"init\": {\n\t\t\t  \ttype: \"CallExpression\",\n\t\t\t  \tcallee: {\n\t\t\t  \t\ttype: \"FunctionExpression\",\n\t\t\t  \t\tparams: [],\n\t\t\t  \t\tbody: {type: \"BlockStatement\", body: ensureStatement(body)}\n\t\t\t  \t},\n\t\t\t  \targuments: []\n\t\t\t  }\n\t\t\t}],\n\t\t\t\"kind\": ctx.varType || 'var'\n\t\t};\n\t}\n\n\n\tfunction tranformContinue(node, ctx) {\n\t\treturn {type: \"ContinueStatement\"};\n\t}\n\n\tfunction makeCop(left, op, right) {\n\n\t\tvar fxOps = {\n\t\t\t\"In_\": \"in\",\n\t\t\t\"In\": \"in\",\n\t\t\t\"NotIn\": \"in\"\n\t\t};\n\t\tvar opName = getOpName(op);\n\t\tif ( opName in fxOps  ) {\n\t\t\tvar call = {\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: makeVariableName(\"__pythonRuntime.ops.\" + fxOps[opName]),\n\t\t\t\targuments: [left, right]\n\t\t\t};\n\n\t\t\tif ( opName == \"NotIn\" ) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"UnaryExpression\",\n\t\t\t\t\targument: call,\n\t\t\t\t\toperator: \"!\"\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn call;\t\n\t\t\t} \n\t\t}\n\n\t\t\n\t\tvar operators = {\n\t\t\t\"Eq\": \"===\",\n\t\t\t\"NotEq\": \"!==\",\n\t\t\t\"LtE\": \"<=\",\n\t\t\t\"Lt\": \"<\",\n\t\t\t\"GtE\": \">=\",\n\t\t\t\"Gt\": \">\",\n\t\t\t\"Is\": \"===\",\n\t\t\t\"IsNot\": \"!==\"\n\t\t};\n\t\t\n\t\tif ( !(opName in operators) ) abort(\"Unsuported Compare operator: \" + opName);\n\t\treturn binOp(left, operators[opName], right);\n\t}\n\n\tfunction transformCompare(node, ctx) {\n\t\tvar left = transform(node.left, ctx);\n\t\tvar result;\n\n\t\tfor ( var i = 0; i < node.comparators.length; ++i ) {\n\t\t\tvar right = transform(node.comparators[i], ctx);\n\t\t\tvar cop = makeCop(left, node.ops[i], right);\n\t\t\tif ( result ) {\n\t\t\t\tresult = binOp(result, '&&', cop);\n\t\t\t} else {\n\t\t\t\tresult = cop;\n\t\t\t}\n\t\t\tleft = right;\n\t\t}\n\n\t\t\n\n\t\treturn result;\n\t\t\n\t}\n\n\tfunction transformDel(node, ctx) {\n\t\tvar result = [];\n\t\tfor ( var i = 0; i < node.targets.length; ++i ) {\n\t\t\tvar st = node.targets[i];\n\t\t\tvar partial = transform(st, ctx);\n\t\t\tresult.push({\n\t\t\t\ttype: \"AssignmentExpression\",\n\t\t\t\toperator: \"=\",\n\t\t\t\tleft: partial,\n\t\t\t\tright: {\n\t\t\t\t\ttype: \"UnaryExpression\",\n\t\t\t\t\targument: literal(0),\n\t\t\t\t\toperator: 'void',\n\t\t\t\t\tprefix: true\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn ensureStatement({\n\t\t\ttype: \"SequenceExpression\",\n\t\t\texpressions: result\n\t\t});\n\t}\n\n\tfunction transformDict(node, ctx) {\n\t\tvar args = [];\n\t\tfor ( var i = 0; i < node.keys.length; ++i ) {\n\t\t\targs.push({\n\t\t\t\ttype: \"ArrayExpression\",\n\t\t\t\telements: [\n\t\t\t\t\ttransform(node.keys[i], ctx),\n\t\t\t\t\ttransform(node.values[i], ctx)\n\t\t\t\t]\n\t\t\t});\n\t\t}\n\t\treturn {\n\t\t\ttype: \"NewExpression\",\n\t\t\tcallee: makeVariableName(\"__pythonRuntime.objects.dict\"),\n\t\t\targuments: args\n\t\t};\n\t}\n\n\tfunction transformExpr(node, ctx) {\n\t\treturn {\n\t\t\ttype: \"ExpressionStatement\",\n\t\t\texpression: transform(node.value, ctx)\n\t\t};\n\t}\n\n\tfunction assignPossiblyWithDeclaration(target, value, ctx) {\n\t\tvar left = target._astname ? transform(target, ctx) : target;\n\t\tvar varible;\n\n\t\tif ( left.type === \"Identifier\" ) varible = left.name;\n\n\t\tif ( !varible || !ctx || !ctx.locals || ctx.locals[varible] ) {\n\t\t\treturn {type: \"ExpressionStatement\", expression: {\n\t\t\t\ttype: \"AssignmentExpression\",\n\t\t\t\toperator: \"=\",\n\t\t\t\tleft: left,\n\t\t\t\tright: value\n\t\t\t}};\n\t\t}\n\n\t\tctx.locals[varible] = true;\n\n\t\treturn {\n\t\t\ttype: \"VariableDeclaration\",\n\t\t\tdeclarations: [{\n\t\t\t\ttype: \"VariableDeclarator\",\n\t\t\t\tid: left,\n\t\t\t\tinit: value\n\t\t\t}],\n\t\t\tkind: ctx.varType || 'var'\n\t\t};\n\t}\n\n\tfunction createTupleUnpackingAssign(target, value, ctx) {\n\n\t\tif ( target._astname === 'Tuple' ) {\n\t\t\tvar result = [];\n\t\t\tvar tn = createTempName(\"right\");\n\t\t\tresult.push({\n\t\t\t\ttype: \"VariableDeclaration\",\n\t\t\t\tkind: \"var\",\n\t\t\t\tdeclarations: [{\n\t\t\t\t\ttype: \"VariableDeclarator\",\n\t\t\t\t\tid: ident(tn),\n\t\t\t\t\tinit: value\n\t\t\t\t}]\n\t\t\t});\n\t\t\tfor ( var i = 0; i < target.elts.length; ++i ) {\n\t\t\t\tresult.push.apply(result,createTupleUnpackingAssign(\n\t\t\t\t\ttarget.elts[i],\n\t\t\t\t\t{type: \"MemberExpression\", object: ident(tn), property: literal(i),  computed: true}\n\t\t\t\t,ctx));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\treturn [assignPossiblyWithDeclaration(target, value, ctx)];\n\t}\n\n\tfunction createForLoop(iident, tident, iter, target, body, ctx) {\n\n\t\tbody = createTupleUnpackingAssign(\n\t\t\ttarget, \n\t\t\t{type: \"MemberExpression\", object: tident, property: iident, computed: true},\n\t\t\tctx\n\t\t).concat(body);\n\n\t\tvar riter = ternary(\n\t\t\t{type: \"CallExpression\", callee: makeVariableName(\"Array.isArray\"), arguments:[iter]},\n\t\t\titer,\n\t\t\t{type: \"CallExpression\", callee: makeVariableName(\"Object.keys\"), arguments:[iter]}\n\t\t);\n\n\t\treturn {\n\t\t\ttype: \"ForStatement\",\n\t\t\tinit: {\n\t\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\t\"declarations\": [\n\t\t\t\t{\n\t\t\t\t  \"type\": \"VariableDeclarator\",\n\t\t\t\t  \"id\": iident,\n\t\t\t\t  \"init\": literal(0)\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t  \"type\": \"VariableDeclarator\",\n\t\t\t\t  \"id\": tident,\n\t\t\t\t  \"init\": riter\n\t\t\t\t}],\n\t\t\t\t\"kind\": ctx.varType\n\t\t\t},\n\t\t\ttest: binOp(iident, '<', {\n\t\t\t\ttype: \"MemberExpression\", object: tident, property: {type: \"Identifier\", name: \"length\"}\n\t\t\t}),\n\t\t\tupdate: {\n\t\t\t\t\"type\": \"UpdateExpression\",\n\t\t\t\t\"operator\": \"++\",\n\t\t\t\t\"prefix\": true,\n\t\t\t\t\"argument\": iident\n\t\t\t},\n\t\t\tbody: {type: \"BlockStatement\", body: body}\n\t\t};\n\t}\n\n\tfunction transformFor(node, ctx) {\n\t\tvar name = createTempName('idx');\n\t\tvar iident = ident(name);\n\t\tvar tname = createTempName('target');\n\t\tvar tident = {type: \"Identifier\", name: tname};\n\t\tvar iter = transform(node.iter, ctx);\n\t\tvar body = ensureStatement(transform(node.body, ctx));\n\n\t\tif ( node.orelse && node.orelse.length > 0 ) abort(\"else: for-else statement unsupported.\");\n\t\treturn createForLoop(iident, tident, iter, node.target, body, ctx);\n\t}\n\n\tfunction prepareFunctionBody(node, ctx) {\n\t\tvar args = node.args.args.slice(0);\n\t\tif  ( ctx.inClass ) {\n\t\t\t//TODO: Make sure it's named self, maybe?\n\t\t\targs.shift();\n\t\t}\n\t\tvar hasAnyArguments = args.length > 0 || node.args.vararg || node.args.kwarg;\n\t\tvar nctx = {\n\t\t\tlocals: Object.create(null),\n\t\t\tvarType: ctx.varType\n\t\t};\n\t\tvar body = ensureStatement(transform(node.body, nctx));\n\t\tvar premble = [];\n\n\t\tif ( ctx.inClass ) {\n\t\t\tpremble.push({\n\t\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\t\"declarations\": [{\n\t\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\t\"id\": ident('self'),\n\t\t\t\t\t\"init\": {type: \"ThisExpression\"}\n\t\t\t\t}],\n\t\t\t\t\"kind\": \"var\"\n\t\t\t});\n\t\t}\n\n\t\tif ( hasAnyArguments ) {\n\t\t\t\n\t\t\tvar hasParams = createTempName('hasParams');\n\t\t\tvar param0 = createTempName('param0');\n\t\t\tvar realArgCount = createTempName('realArgCount');\n\t\t\tvar argLen = makeVariableName('arguments.length');\n\t\t\tvar argN = {type: \"MemberExpression\", object: ident('arguments'), property: binOp(argLen, '-', literal(1)), computed: true};\n\t\t\tvar argNKeywords = {type: \"MemberExpression\", object: argN, property: ident('keywords'), computed: false};\n\n\t\t\tpremble.push({\n\t\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\t\"declarations\": [\n\t\t\t\t{\n\t\t\t\t  \"type\": \"VariableDeclarator\",\n\t\t\t\t  \"id\": ident(hasParams),\n\t\t\t\t  \"init\": logicOp(binOp(argLen, '>', literal(0)), '&&', logicOp(argN, '&&', argNKeywords))\n\t\t\t\t}],\n\t\t\t\t\"kind\":  \"var\"\n\t\t\t});\n\n\t\t\tvar main = [];\n\t\t\tmain.push({\n\t\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\t\"declarations\": [{\n\t\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\t\"id\": ident(param0),\n\t\t\t\t\t\"init\": ternary(ident(hasParams), argNKeywords, {type: \"ObjectExpression\", properties: []})\n\t\t\t\t},{\n\t\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\t\"id\": ident(realArgCount),\n\t\t\t\t\t\"init\": binOp(argLen, '-', ternary(ident(hasParams), literal(1), literal(0)))\n\t\t\t\t}],\n\t\t\t\t\"kind\": \"var\"\n\t\t\t});\n\n\t\t\tfor ( var i = 0; i < args.length; ++i ) {\n\t\t\t\tvar a = node.args.args[i];\n\t\t\t\tvar didx = i - (node.args.args.length - node.args.defaults.length);\n\t\t\t\tvar def = didx >= 0 ? transform(node.args.defaults[didx], ctx) : ident('undefined');\n\n\t\t\t\tmain.push({\n\t\t\t\t\ttype: \"IfStatement\",\n\t\t\t\t\ttest: binOp(ident(realArgCount), '<', literal(i+1)),\n\t\t\t\t\tconsequent: ensureStatement({\n\t\t\t\t\t\ttype: \"AssignmentExpression\",\n\t\t\t\t\t\toperator: \"=\",\n\t\t\t\t\t\tleft: ident(a.id),\n\t\t\t\t\t\tright: ternary(\n\t\t\t\t\t\t\tbinOp(literal(a.id), 'in', ident(param0)),\n\t\t\t\t\t\t\t{type: \"MemberExpression\", object: ident(param0), property: ident(a.id), computed: false},\n\t\t\t\t\t\t\tdef\n\t\t\t\t\t\t)\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( node.args.vararg ) {\n\t\t\t\tmain.push({\n\t\t\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\t\t\"declarations\": [{\n\t\t\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\t\t\"id\": ident(node.args.vararg),\n\t\t\t\t\t\t\"init\": {\n\t\t\t\t\t\t\ttype: \"CallExpression\",\n\t\t\t\t\t\t\tcallee: makeVariableName(\"Array.prototype.slice.call\"),\n\t\t\t\t\t\t\targuments: [ident('arguments'), literal(node.args.args.length), hasAnyArguments ? ident(realArgCount) : undefined]\n\t\t\t\t\t\t}\n\t\t\t\t\t}],\n\t\t\t\t\t\"kind\": \"var\"\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( node.args.kwarg ) {\n\t\t\t\tfor ( var i = 0; i < node.args.args.length; ++i ) {\n\t\t\t\t\tmain.push(ensureStatement({\n\t\t\t\t\t\ttype: \"UnaryExpression\",\n\t\t\t\t\t\toperator: \"delete\",\n\t\t\t\t\t\targument: {\n\t\t\t\t\t\t\ttype: \"MemberExpression\",\n\t\t\t\t\t\t\tobject: ident(param0),\n\t\t\t\t\t\t\tproperty: ident(node.args.args[i].id),\n\t\t\t\t\t\t\tcomputed: false\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t\tmain.push({\n\t\t\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\t\t\"declarations\": [{\n\t\t\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\t\t\"id\": ident(node.args.kwarg),\n\t\t\t\t\t\t\"init\": ident(param0)\n\t\t\t\t\t}],\n\t\t\t\t\t\"kind\": \"var\"\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tpremble = premble.concat(main); //TODO: If we dont have defauts, we can guard this with __hasParams\t\n\t\t}\n\n\n\t\tbody = premble.concat(body);\n\t\tvar params = transform(args, ctx);\n\t\treturn {\n\t\t\tpremble: premble,\n\t\t\tbody: body,\n\t\t\tparams: params\n\t\t};\n\n\t}\n\n\tfunction transformFunctionDef(node, ctx) {\n\t\tvar data = prepareFunctionBody(node, ctx);\n\n\n\n\t\tif ( ctx.writeTarget ) {\n\t\t\treturn ensureStatement({\n\t\t\t\ttype: \"AssignmentExpression\",\n\t\t\t\tleft: {type: \"MemberExpression\", object: ctx.writeTarget, property: ident(node.name)},\n\t\t\t\tright: {\n\t\t\t\t\ttype: \"FunctionExpression\",\n\t\t\t\t\tname: ident(node.name),\n\t\t\t\t\tparams: data.params,\n\t\t\t\t\tbody: {type: \"BlockStatement\", body: data.body}\n\t\t\t\t},\n\t\t\t\toperator: '='\n\t\t\t});\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: \"FunctionDeclaration\",\n\t\t\t\tid: {type: \"Identifier\", name: node.name.v},\n\t\t\t\tparams: data.params,\n\t\t\t\tbody: {type: \"BlockStatement\", body: data.body}\n\t\t\t};\n\t\t}\n\t}\n\n\tfunction transformGlobal(node, ctx) {\n\t\tfor ( var i = 0; i < node.names.length; ++i ) {\n\t\t\tctx.locals[node.names[i].v] = true;\n\t\t}\n\t\treturn [];\n\t}\n\n\tfunction transformIf(node, ctx) {\n\t\tvar body = ensureStatement(transform(node.body, ctx));\n\t\treturn {\n\t\t\ttype: \"IfStatement\",\n\t\t\ttest: transform(node.test, ctx),\n\t\t\tconsequent: {type: \"BlockStatement\", body: body},\n\t\t\talternate: (node.orelse && node.orelse.length > 0) ? {type: \"BlockStatement\", body: ensureStatement(transform(node.orelse, ctx))} : undefined\n\t\t};\n\t}\n\n\tfunction transformLambda(node, ctx) {\n\t\tvar data = prepareFunctionBody(node, ctx);\n\t\t\n\t\t//TODO: This is pretty sketchy.\n\t\tvar last = data.body[data.body.length - 1];\n\t\tdata.body[data.body.length - 1] = {type: \"ReturnStatement\", argument: last.expression};\n\n\t\treturn {\n\t\t\ttype: \"FunctionExpression\",\n\t\t\tparams: data.params,\n\t\t\tbody: {type: \"BlockStatement\", body: data.body}\n\t\t};\n\t}\n\n\tfunction transformList(node, ctx) {\n\t\tvar call = {\n\t\t\ttype: \"CallExpression\",\n\t\t\tcallee: makeVariableName(\"__pythonRuntime.objects.list\"),\n\t\t\targuments: transform(node.elts, ctx)\n\t\t};\n\t\treturn call;\n\t}\n\n\tfunction transformListComp(node, ctx) {\t\n\t\tvar body = [];\n\t\tvar aggrigator = createTempName('result');\n\n\t\tbody.push({\n\t\t\t\"type\": \"VariableDeclaration\",\n\t\t\t\"declarations\": [{\n\t\t\t\t\"type\": \"VariableDeclarator\",\n\t\t\t\t\"id\": ident(aggrigator),\n\t\t\t\t\"init\": {\n\t\t\t\t\ttype: \"NewExpression\",\n\t\t\t\t\tcallee: makeVariableName('__pythonRuntime.objects.list'),\n\t\t\t\t\targuments: []\n\t\t\t\t}\n\t\t\t}],\n\t\t\t\"kind\": \"var\"\n\t\t});\n\n\t\tvar insideBody = [];\n\n\t\tinsideBody.push(ensureStatement({\n\t\t\ttype: \"CallExpression\",\n\t\t\tcallee: {type: \"MemberExpression\", object: ident(aggrigator), property: ident('push'), computed: false},\n\t\t\targuments: [transform(node.elt, ctx)]\n\t\t}));\n\n\t\t//if ( node.generators.length !== 1 ) abort(\"Unsuported number of generators\");\n\t\tvar gen = node.generators[0];\n\n\t\tfor ( var g = node.generators.length - 1; g >= 0; --g ) {\n\t\t\tvar idxName = createTempName('idx');\n\t\t\tvar listName = createTempName(\"list\" + g);\n\t\t\tvar iterName = createTempName('iter');\n\t\t\tvar gen = node.generators[g];\n\t\t\tfor ( var i = 0; i < gen.ifs.length; ++i ) {\n\t\t\t\tinsideBody.unshift({\n\t\t\t\t\ttype: \"IfStatement\",\n\t\t\t\t\ttest: {type: \"UnaryExpression\", argument: transform(gen.ifs[i], ctx), operator: \"!\"},\n\t\t\t\t\tconsequent: {type: \"ContinueStatement\"}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tinsideBody = [\n\t\t\t\t{\n\t\t\t\t\ttype: \"VariableDeclaration\",\n\t\t\t\t\tkind: \"var\",\n\t\t\t\t\tdeclarations: [{\n\t\t\t\t\t\ttype: \"VariableDeclarator\",\n\t\t\t\t\t\tid: ident(listName),\n\t\t\t\t\t\tinit: transform(gen.iter, ctx)\n\t\t\t\t\t}]\n\t\t\t\t},\n\t\t\t\tcreateForLoop(ident(idxName), ident(iterName), ident(listName), gen.target, insideBody, ctx)\n\t\t\t];\n\t\t}\n\n\t\tbody.push.apply(body, insideBody);\n\t\tbody.push({\n\t\t\ttype: \"ReturnStatement\",\n\t\t\targument: ident(aggrigator)\n\t\t});\n\n\t\tvar expr = {\n\t\t\ttype: \"FunctionExpression\",\n\t\t\tparams: [],\n\t\t\tbody: {type: \"BlockStatement\", body: body}\n\t\t};\n\n\t\treturn {\n\t\t\ttype: \"CallExpression\",\n\t\t\tcallee: expr,\n\t\t\targuments: []\n\t\t};\n\t}\n\n\tfunction transformModule(node, ctx) {\n\t\treturn {\n\t\t\ttype: \"Program\",\n\t\t\tbody: ensureStatement(transform(node.body, ctx))\n\t\t};\n\t}\n\n\tfunction transformName(node, ctx) {\n\t\tif ( node.id.v === 'True' ) return {type: \"Literal\", value: true, raw: \"true\"};\n\t\tif ( node.id.v === 'False' ) return {type: \"Literal\", value: false, raw: \"false\"};\n\t\tif ( node.id.v === 'None' ) return {type: \"Literal\", value: null, raw: \"null\"};\n\n\t\tif ( node.id.v === 'random' ) return makeVariableName('__pythonRuntime.imports.random');\n\t\treturn ident(node.id);\n\t}\n\n\tfunction transformNum(node, ctx) {\n\t\treturn literal(node.n);\n\t}\n\n\tfunction transformPrint(node, ctx) {\n\t\treturn {\n\t\t\ttype: \"CallExpression\",\n\t\t\tcallee: makeVariableName(\"console.log\"),\n\t\t\targuments: transform(node.values, ctx)\n\t\t};\n\t}\n\n\tfunction transformReturn(node, ctx) {\n\t\treturn {\n\t\t\ttype: \"ReturnStatement\",\n\t\t\targument: node.value ? transform(node.value, ctx) : undefined\n\t\t};\n\t}\n\n\tfunction transformStr(node, ctx) {\n\t\treturn literal(node.s.valueOf());\n\t}\n\n\tfunction transformTuple(node, ctx) {\n\t\tvar call = {\n\t\t\ttype: \"CallExpression\",\n\t\t\tcallee: makeVariableName(\"__pythonRuntime.objects.tuple\"),\n\t\t\targuments: transform(node.elts, ctx)\n\t\t};\n\t\treturn call;\n\t}\n\n\tfunction transformSubscript(node, ctx) {\n\t\t//TODO: Do silly pythonic list offset logic\n\t\tvar val = transform(node.value, ctx);\n\t\tif ( node.slice.value ) {\n\t\t\tvar lu = transform(node.slice.value, ctx);\n\t\t\tlu = {\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: makeVariableName(\"__pythonRuntime.ops.subscriptIndex\"),\n\t\t\t\targuments: [val, lu]\n\t\t\t};\n\t\t\treturn {\n\t\t\t\ttype: \"MemberExpression\",\n\t\t\t\tcomputed: true,\n\t\t\t\tobject: val,\n\t\t\t\tproperty: lu\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"CallExpression\",\n\t\t\tcallee: makeVariableName('__pythonRuntime.internal.slice'),\n\t\t\targuments:[\n\t\t\t\tval,\n\t\t\t\tnode.slice.lower ? transform(node.slice.lower, ctx) : ident('undefined'),\n\t\t\t\tnode.slice.upper ? transform(node.slice.upper, ctx) : ident('undefined'),\n\t\t\t\tnode.slice.step ? transform(node.slice.step, ctx) : ident('undefined'),\n\t\t\t]\n\t\t};\n\t}\n\n\tfunction transformPass(node, ctx) {\n\t\treturn {type: \"EmptyStatement\"};\n\t}\n\n\tfunction transformUnaryOp(node, ctx) {\n\t\tvar argument = transform(node.operand, ctx);\n\n\t\tvar fxOps = {\n\t\t\t\"Add\": \"add\",\n\t\t\t\"Mult\": \"multiply\",\n\t\t};\n\t\tvar opName = getOpName(node.op);\n\n\t\tif ( opName in fxOps  ) {\n\t\t\tvar call = {\n\t\t\t\ttype: \"CallExpression\",\n\t\t\t\tcallee: makeVariableName(\"__pythonRuntime.ops.\" + fxOps[opName]),\n\t\t\t\targuments: [argument]\n\t\t\t};\n\t\t\treturn call;\n\t\t}\n\n\t\tvar operators = {\n\t\t\t\"Not\": \"!\",\n\t\t\t\"USub\": \"-\",\n\t\t\t\"Invert\": \"~\"\n\t\t};\n\n\t\tif ( !(opName in operators) ) abort(\"Unknown unary operator: \" + opName);\n\n\t\treturn {\n\t\t\ttype: \"UnaryExpression\",\n\t\t\targument: argument,\n\t\t\toperator: operators[opName]\n\t\t};\n\t\t\n\t}\n\n\tfunction transformWhile(node, ctx) {\n\t\tif ( node.orelse && node.orelse.length > 0 ) abort(\"else: statement for while unsupported.\");\n\t\treturn {\n\t\t\ttype: \"WhileStatement\",\n\t\t\ttest: transform(node.test, ctx),\n\t\t\tbody: {type: \"BlockStatement\", body: ensureStatement(transform(node.body, ctx))}\n\t\t};\t\n\t}\n\n\tmodule.exports = transform;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar Sk = __webpack_require__(1);\n\n\tfunction splat(e) {\n\t\tconsole.log(\"GOT ERROR!\");\n\t\tconsole.log(e, e.extra);\n\t\tconsole.log(JSON.stringify(e.extra.node, function(k,  o) {\n\t\t\tif ( k == 'type' ) return Sk.nameForToken(o);\n\t\t\telse if ( k == 'children' ) return o;\n\t\t\telse if ( k ===  '' ) return o;\n\t\t\telse if ( !isNaN(parseInt(k)) ) return o;\n\t\t\telse return undefined;\n\t\t}, '  '));\n\t}\n\n\tfunction improveError(e, options, code) {\n\t\tvar r;\n\t\tif ( e.context && e.context.length >0 ) {\n\t\t\tr = e.context[0];\t\n\t\t}\n\n\t\tif ( e.extra && e.extra.node ) {\n\t\t\tif ( !r ) {\n\t\t\t\tr = [e.extra.node.loc.start.line,e.extra.node.loc.start.column];\n\t\t\t}\n\t\t}\n\n\t\tif ( r ) {\n\t\t\tsetErrorPos(e, r[0], r[1]);\n\t\t}\n\n\t\tif ( options.friendlyErrors && e.extra ) {\n\t\t\te.message = makeErrorFriendly(e, code);\n\t\t}\n\t}\n\n\tfunction setErrorPos(e, line, col) {\n\t\te.loc = {line: line, column: col};\n\t\te.line = line;\n\t\te.column = col;\n\t}\n\n\tfunction friendlyString(s) {\n\t\tswitch (s) {\n\t\tcase 'if_stmt': return 'if statement';\n\t\tcase 'while_stmt': return 'while statement';\n\t\tcase 'funcdef': return 'function';\n\t\tdefault: return '?' + s + '?';\n\t\t} \n\t}\n\n\tfunction nodeToType(n) {\n\t\tvar type = Sk.nameForToken(n.type);\n\t\tif ( type === 'suite' ) return nodeToType(n.children[0]);\n\t\treturn friendlyString(type);\n\t}\n\n\tfunction makeErrorFriendly(e, code) {\n\t\t//console.log(\"EX\", e.message, e.extra);\n\t\tif ( e.extra.kind == \"DAG_MISS\" ) {\n\t\t\tif ( e.extra.expected.indexOf('T_COLON') !== -1 ) {\n\t\t\t\t//We might be missing a colon.\n\t\t\t\tvar after = (e.context && e.context[2] ? e.context[2] : e.extra.found_val).replace(/\\s+$/,'');\n\t\t\t\tvar lc = e.extra.node.children[e.extra.node.children.length-1];\n\t\t\t\tif ( lc.value === 'else' ) after = 'else';\n\n\t\t\t\tif ( e.extra.found == 'T_SEMI' ) {\n\t\t\t\t\treturn \"Replace the `;` at the end of `\" + after + \"` with a `:`\";\n\t\t\t\t} else if ( e.extra.found == 'T_NEWLINE' ) {\n\t\t\t\t\treturn \"Need a `:` on the end of the line following `\" + after + \"`.\";\n\t\t\t\t} else if ( e.extra.found == 'T_NAME' ) {\n\t\t\t\t\treturn \"Need a `:` after `\" + after + \"`.\";\n\t\t\t\t} else if ( e.extra.found == 'T_EQUAL' ) {\n\t\t\t\t\treturn \"Can't assign to a variable within the condition of an \" + friendlyString(e.extra.inside) + \".  Did you mean to use `==` instead of `=`?\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( e.extra.expected.indexOf('T_DEDENT') !== -1 ) {\n\t\t\t\tif ( e.extra.found_val.toLowerCase() === 'else' ) {\n\t\t\t\t\treturn \"`else` needs to line up with its `if`.\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"Indentation error.\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( e.extra.expected.indexOf('T_INDENT') !== -1 ) {\n\t\t\t\tvar lc = e.extra.parent || e.extra.node;\n\t\t\t\tvar name  = nodeToType(lc);\n\t\t\t\tif ( name === 'if statement' ) {\n\t\t\t\t\t//Scan for the most recent part of the ifstatement.\n\t\t\t\t\tfor ( var i = 0; i < lc.children.length; ++i ) {\n\t\t\t\t\t\tif ( [\"if\", \"elif\", \"else\"].indexOf(lc.children[i].value) !== -1 ) {\n\t\t\t\t\t\t\tname = lc.children[i].value + ' statement';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( lc.value === 'else' ) name = 'else statement';\n\t\t\t\treturn 'Empty ' + name + '. Put 4 spaces in front of statements inside the ' + name + '.';\n\t\t\t}\n\n\t\t\tif ( e.extra.found === 'T_NAME' ) {\n\t\t\t\tswitch ( e.extra.found_val ) {\n\t\t\t\t\tcase 'else':\n\t\t\t\t\tcase 'elif':\n\t\t\t\t\t\treturn '`' + e.extra.found_val + '` must be paired with an `if`';\n\t\t\t\t\tcase 'elseif':\n\t\t\t\t\t\treturn '`elseif` should be shortened to `elif`';\n\t\t\t\t} \n\t\t\t}\n\n\t\t\tif ( e.extra.found === 'T_AMPER' && e.extra.inside == 'and_expr' ) {\n\t\t\t\treturn 'Python uses the word `and` instead of `&&` for boolean AND expressions.';\n\t\t\t}\n\n\n\t\t\tif ( e.extra.inside === 'trailer' ) {\n\t\t\t\t//We are parsing either an arglist or a subscript.\n\t\t\t\tif ( e.extra.expected.indexOf('T_RPAR') === 0 ) {\n\t\t\t\t\t//Expected ), must be a arglsit;\n\t\t\t\t\tif ( e.line > e.extra.node.lineno ) {\n\t\t\t\t\t\t//Our arglist is incomplete, and we have made it to the next line,.\n\t\t\t\t\t\t//Likely they just forgot to close their ()'s\n\t\t\t\t\t\tsetErrorPos(e, e.extra.node.lineno, e.extra.node.col_offset);\n\t\t\t\t\t\tvar t = e.extra.node.loc;\n\t\t\t\t\t\te.context = [\n\t\t\t\t\t\t\t[t.start.line,t.start.column],\n\t\t\t\t\t\t\t[t.end.line,t.end.column]\n\t\t\t\t\t\t];\n\t\t\t\t\t\treturn 'Unclosed `(` in function arguments.' + e.extra.node.lineno;\n\n\t\t\t\t\t}\n\t\t\t\t\treturn 'Function calls paramaters must be seperated by `,`s';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( e.extra.found === 'T_INDENT' ) {\n\t\t\t\tif ( e.extra.expected.indexOf('stmt') !== -1 ) {\n\t\t\t\t\treturn 'Too much indentation at the beginning of this line.';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( e.extra.expected.indexOf('subscriptlist') === 0 ) {\n\t\t\t\treturn \"Malformed subscript\";\n\t\t\t}\n\n\t\t\tif ( e.extra.expected.indexOf('T_NEWLINE') !== -1 ) {\n\t\t\t\tvar n = e.extra.node;\n\t\t\t\t\n\t\t\t\tif ( e.extra.node.children[0] ) {\n\t\t\t\t\tvar n = e.extra.node.children[0];\n\t\t\t\t\tvar previousType = Sk.nameForToken(n.type);\n\t\t\t\t\n\t\t\t\t\tif ( previousType == 'small_stmt' ) {\n\t\t\t\t\t\twhile ( n.children && n.children.length == 1 ) n = n.children[0];\n\t\t\t\t\t\tvar what = code.substring(n.range[0], n.range[1]);\n\t\t\t\t\t\treturn 'If you want to call `' + what +'` as function, you need `()`\\'s';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 'Unexpected token: ' + e.message;\n\t\t} else if ( e.extra.kind == \"CLASSIFY\" ) {\n\t\t\tif ( e.extra.value === '\"' ) return 'Unterminated string. Add a matching `\"` at the end of your string.';\n\t\t\treturn 'Unterminated `' + e.extra.value + '`';\n\t\t} else if ( e.extra.kind == \"STRING_EOF\" ) {\n\t\t\treturn 'Unterminated muti-line string. Add a matching `\"\"\"` at the end of your string.';\n\t\t} else if ( e.extra.kind == \"STATEMENT_EOF\" ) {\n\t\t\tif ( e.extra.parenlev > 0 ) {\n\t\t\t\tvar top = e.extra.parenstack[e.extra.parenstack.length-1];\n\t\t\t\tvar kind = top[0];\n\t\t\t\tvar types = '([{';\n\t\t\t\tvar pair = ')]}';\n\t\t\t\tvar close = pair[types.indexOf(kind)];\n\t\t\t\tsetErrorPos(e, top[1], top[2]-1);\n\t\t\t\treturn 'Unmatched `' + kind + '`.  Every opening `' + kind + '` needs a closing `' + close + '` to match it.';\n\t\t\t}\n\t\t\treturn e.message;\n\t\t}\n\n\t\treturn e.message;\n\t\t\n\t\t\n\t}\n\n\tmodule.exports = improveError;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (root, factory) {\n\t  'use strict';\n\t  if(true)\n\t    module.exports = factory();\n\t  else if(typeof define === 'function' && define.amd)\n\t    define([], factory);\n\t  else if(typeof exports === 'object')\n\t    exports[\"__pythonRuntime\"] = factory();\n\t  else\n\t    root[\"__pythonRuntime\"] = factory();\n\t}(this, function() {\n\t  'use strict';\n\t  var pythonRuntime = {\n\t    internal: {\n\t      // Only used within runtime\n\t      isSeq: function (a) { return a && (a._type === \"list\" || a._type === \"tuple\"); },\n\t      slice: function (obj, start, end, step) {\n\t        var slice;\n\t        if ( typeof obj === 'string' ) slice = function(x,y) { return obj.substring(x,y); }\n\t        else slice = obj.slice.bind(obj);\n\n\t        if (step == null || step === 0) step = 1; // TODO: step === 0 is a runtime error\n\t        if (start == null) {\n\t          if (step < 0) start = obj.length - 1;\n\t          else start = 0;\n\t        } else if (start < 0) start += obj.length;\n\t        if (end == null) {\n\t          if (step < 0) end = -1;\n\t          else end = obj.length;\n\t        } else if (end < 0) end += obj.length;\n\n\t        var ret = new pythonRuntime.objects.list(), tmp, i;\n\t        if (step < 0) {\n\t          tmp = slice(end + 1, start + 1);\n\t          for (i = tmp.length - 1; i >= 0; i += step) ret.append(tmp[i]);\n\t        } else {\n\t          tmp = slice(start, end);\n\t          if (step === 1 && typeof tmp !== 'string') ret = pythonRuntime.utils.createList(tmp);\n\t          else for (i = 0; i < tmp.length; i += step) ret.append(tmp[i]);\n\t        }\n\t        if ( typeof obj === 'string' ) return ret.join('');\n\t        return ret;\n\t      },\n\t      isJSArray: Array.isArray || function(obj) {\n\t        return toString.call(obj) === '[object Array]';\n\t      }\n\t    },\n\n\t    utils: {\n\t      createDict: function () {\n\t        var ret = new pythonRuntime.objects.dict();\n\t        if (arguments.length === 1 && arguments[0] instanceof Object)\n\t          for (var k in arguments[0]) ret[k] = arguments[0][k];\n\t        else\n\t          throw TypeError(\"createDict expects a single JavaScript object\");\n\t        return ret;\n\t      },\n\t      createParamsObj: function () {\n\t        // In: expr, expr, ..., {id:expr, __kwp:true}, {id:expr, __kwp:true}, ...\n\t        // Out: {formals:[expr, expr, ...], keywords:{id:expr, id:expr, ...}}\n\t        var params = { formals: new pythonRuntime.objects.list(), keywords: new PythonDict() };\n\t        for (var i = 0; i < arguments.length; i++) {\n\t          if (arguments[i] && arguments[i].__kwp === true) {\n\t            for (var k in arguments[i])\n\t              if (k !== '__kwp') params.keywords[k] = arguments[i][k];\n\t          }\n\t          else params.formals.push(arguments[i]);\n\t        }\n\t        return params;\n\t      },\n\t      convertToList: function (list) {\n\t        Object.defineProperties(list, pythonRuntime.utils.listPropertyDescriptor);\n\t        return list;\n\t      },\n\t      convertToDict: function (dict) {\n\t        Object.defineProperties(dict, pythonRuntime.utils.dictPropertyDescriptor);\n\t        return dict;\n\t      }, \n\t      listPropertyDescriptor: {\n\t          \"_type\": {\n\t            get: function () { return 'list'; },\n\t            enumerable: false\n\t          },\n\t          \"_isPython\": {\n\t            get: function () { return true; },\n\t            enumerable: false\n\t          },\n\t          \"append\": {\n\t            value: function (x) {\n\t              this.push(x);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"clear\": {\n\t            value: function () {\n\t              this.splice(0, this.length);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"copy\": {\n\t            value: function () {\n\t              return this.slice(0);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"count\": {\n\t            value: function (x) {\n\t              var c = 0;\n\t              for (var i = 0; i < this.length; i++)\n\t                if (this[i] === x) c++;\n\t              return c;\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"equals\": {\n\t            value: function (x) {\n\t              try {\n\t                if (this.length !== x.length) return false;\n\t                for (var i = 0; i < this.length; i++) {\n\t                  if (this[i].hasOwnProperty(\"equals\")) {\n\t                    if (!this[i].equals(x[i])) return false;\n\t                  } else if (this[i] !== x[i]) return false;\n\t                }\n\t                return true;\n\t              }\n\t              catch (e) { }\n\t              return false;\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"extend\": {\n\t            value: function (L) {\n\t              for (var i = 0; i < L.length; i++) this.push(L[i]);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"index\": {\n\t            value: function (x) {\n\t              return this.indexOf(x);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"indexOf\": {\n\t            value: function (x, fromIndex) {\n\t              try {\n\t                for (var i = fromIndex ? fromIndex : 0; i < this.length; i++) {\n\t                  if (this[i].hasOwnProperty(\"equals\")) {\n\t                    if (this[i].equals(x)) return i;\n\t                  } else if (this[i] === x) return i;\n\t                }\n\t              }\n\t              catch (e) { }\n\t              return -1;\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"insert\": {\n\t            value: function (i, x) {\n\t              this.splice(i, 0, x);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"pop\": {\n\t            value: function (i) {\n\t              if (arguments.length<1) i = this.length - 1;\n\t              var item = this[i];\n\t              this.splice(i, 1);\n\t              return item;\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"_pySlice\": {\n\t            value: function (start, end, step) {\n\t              return pythonRuntime.internal.slice(this, start, end, step);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"remove\": {\n\t            value: function (x) {\n\t              this.splice(this.indexOf(x), 1);\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"sort\": {\n\t            value: function(x, reverse) {\n\t              var list2 = this.slice(0);\n\t              var apply_key = function(a, numerical) {\n\t                var list3 = list2.map(x);\n\t                // construct a dict that maps the listay before and after the map\n\t                var mapping = {}\n\t                for(var i in list3) mapping[list3[i]] = list2[i];\n\t                if(numerical)\n\t                  list3.sort(function(a, b) { return a - b; });\n\t                else\n\t                  list3.sort()\n\t                for(var i in a) a[i] = mapping[list3[i]];\n\t              }\n\t              for(var i in this) {\n\t                if(typeof this[i] !== 'number' || !isFinite(this[i])) {\n\t                  if(typeof x != 'undefined') {\n\t                    apply_key(this, false);\n\t                  }\n\t                  else {\n\t                    list2.sort();\n\t                    for (var j in this) this[j] = list2[j];\n\t                  }\n\t                  if(reverse)\n\t                    this.reverse();\n\t                  return;\n\t                }\n\t              }\n\t              if(typeof x != 'undefined') {\n\t                apply_key(this, true);\n\t              }\n\t              else {\n\t                list2.sort(function(a, b) { return a - b; });\n\t                for(var i in this) this[i] = list2[i];\n\t              }\n\t              if(reverse)\n\t                this.reverse();\n\t            },\n\t            enumerable: false\n\t          },\n\t          \"toString\": {\n\t            value: function () {\n\t              return '[' + this.join(', ') + ']';\n\t            },\n\t            enumerable: false\n\t          }\n\t      },\n\t      createList: function () {\n\t        var ret = new pythonRuntime.objects.list();\n\t        if (arguments.length === 1 && arguments[0] instanceof Array)\n\t          for (var i in arguments[0]) ret.push(arguments[0][i]);\n\t        else\n\t          for (var i in arguments) ret.push(arguments[i]);\n\t        return ret;\n\t      },\n\t      dictPropertyDescriptor: {\n\t        \"_type\": {\n\t          get: function () { return 'dict';},\n\t          enumerable: false\n\t        },\n\t        \"_isPython\": {\n\t          get: function () { return true; },\n\t          enumerable: false\n\t        },\n\t        \"items\": {\n\t          value: function () {\n\t            var items = new pythonRuntime.objects.list();\n\t            for (var k in this) items.append(new pythonRuntime.objects.tuple(k, this[k]));\n\t            return items;\n\t          },\n\t          enumerable: false\n\t        },\n\t        \"length\": {\n\t          get: function () {\n\t            return Object.keys(this).length;\n\t          },\n\t          enumerable: false\n\t        },\n\t        \"clear\": {\n\t          value: function () {\n\t            for (var i in this) delete this[i];\n\t          },\n\t          enumerable: false\n\t        },\n\t        \"get\": {\n\t          value: function (key, def) {\n\t            if (key in this) return this[key];\n\t            else if (def !== undefined) return def;\n\t            return null;\n\t          },\n\t          enumerable: false\n\t        },\n\t        \"keys\": {\n\t          value: function () {\n\t            return Object.keys(this);\n\t          },\n\t          enumerable: false\n\t        },\n\t        \"pop\": {\n\t          value: function (key, def) {\n\t            var value;\n\t            if (key in this) {\n\t              value = this[key];\n\t              delete this[key];\n\t            } else if (def !== undefined) value = def;\n\t            else return new Error(\"KeyError\");\n\t            return value;\n\t          },\n\t          enumerable: false\n\t        }, \"values\": {\n\t          value: function () {\n\t            var values = new pythonRuntime.objects.list();\n\t            for (var key in this) values.append(this[key]);\n\t            return values;\n\t          },\n\t          enumerable: false\n\t        }\n\t      }\n\t    },\n\t    ops: {\n\t      add: function (a, b) {\n\t        if (typeof a === 'object' && pythonRuntime.internal.isSeq(a) && pythonRuntime.internal.isSeq(b)) {\n\t          if (a._type !== b._type)\n\t            throw TypeError(\"can only concatenate \" + a._type + \" (not '\" + b._type + \"') to \" + a._type);\n\t          var ret;\n\t          if (a._type === 'list') ret = new pythonRuntime.objects.list();\n\t          else if (a._type === 'tuple') ret = new pythonRuntime.objects.tuple();\n\t          if (ret) {\n\t            for (var i = 0; i < a.length; i++) ret.push(a[i]);\n\t            for (var i = 0; i < b.length; i++) ret.push(b[i]);\n\t            return ret;\n\t          }\n\t        }\n\t        return a + b;\n\t      },\n\t      in: function (a, b, n) {\n\t        var r = b.hasOwnProperty('indexOf') ? b.indexOf(a) >= 0 : a in b;\n\t        return n ? !r : r;\n\t      },\n\t      multiply: function (a, b) {\n\t        // TODO: non-sequence operand must be an integer\n\t        if ( typeof a === 'object' ) {\n\t          if (pythonRuntime.internal.isSeq(a) && !isNaN(parseInt(b))) {\n\t            var ret;\n\t            if (a._type === 'list') ret = new pythonRuntime.objects.list();\n\t            else if (a._type === 'tuple') ret = new pythonRuntime.objects.tuple();\n\t            if (ret) {\n\t              for (var i = 0; i < b; i++)\n\t                for (var j = 0; j < a.length; j++) ret.push(a[j]);\n\t              return ret;\n\t            }\n\t          } else if (pythonRuntime.internal.isSeq(b) && !isNaN(parseInt(a))) {\n\t            var ret;\n\t            if (b._type === 'list') ret = new pythonRuntime.objects.list();\n\t            else if (b._type === 'tuple') ret = new pythonRuntime.objects.tuple();\n\t            if (ret) {\n\t              for (var i = 0; i < a; i++)\n\t                for (var j = 0; j < b.length; j++) ret.push(b[j]);\n\t              return ret;\n\t            }\n\t          }\n\t        }\n\t        return a * b;\n\t      },\n\t      subscriptIndex: function (o, i) {\n\t        if ( i >= 0 ) return i;\n\t        if ( pythonRuntime.internal.isSeq(o) ) return o.length + i;\n\t        if ( pythonRuntime.internal.isJSArray(o) ) return o.length + i;\n\t        if ( typeof o === \"string\" ) return o.length + i;\n\t        return i;\n\t      }\n\t    },\n\n\t    objects: {\n\t      dict: function () {\n\t        var obj = new PythonDict();\n\t        for (var i = 0; i < arguments.length; ++i ) obj[arguments[i][0]] = arguments[i][1];\n\t        return obj;\n\t      },\n\t      list: function () {\n\t        var arr = [];\n\t        arr.push.apply(arr, arguments);\n\t        pythonRuntime.utils.convertToList(arr);\n\t        return arr;\n\t      },\n\t      tuple: function () {\n\t        var arr = [];\n\t        arr.push.apply(arr, arguments);\n\t        Object.defineProperty(arr, \"_type\",\n\t        {\n\t          get: function () { return 'tuple'; },\n\t          enumerable: false\n\t        });\n\t        Object.defineProperty(arr, \"_isPython\",\n\t        {\n\t          get: function () { return true; },\n\t          enumerable: false\n\t        });\n\t        Object.defineProperty(arr, \"count\",\n\t        {\n\t          value: function (x) {\n\t            var c = 0;\n\t            for (var i = 0; i < this.length; i++)\n\t              if (this[i] === x) c++;\n\t            return c;\n\t          },\n\t          enumerable: false\n\t        });\n\t        Object.defineProperty(arr, \"equals\",\n\t        {\n\t          value: function (x) {\n\t            try {\n\t              if (this.length !== x.length) return false;\n\t              for (var i = 0; i < this.length; i++) {\n\t                if (this[i].hasOwnProperty(\"equals\")) {\n\t                  if (!this[i].equals(x[i])) return false;\n\t                } else if (this[i] !== x[i]) return false;\n\t              }\n\t              return true;\n\t            }\n\t            catch (e) { }\n\t            return false;\n\t          },\n\t          enumerable: false\n\t        });\n\t        Object.defineProperty(arr, \"index\",\n\t        {\n\t          value: function (x) {\n\t            return this.indexOf(x);\n\t          },\n\t          enumerable: false\n\t        });\n\t        Object.defineProperty(arr, \"indexOf\",\n\t        {\n\t          value: function (x, fromIndex) {\n\t            try {\n\t              for (var i = fromIndex ? fromIndex : 0; i < this.length; i++) {\n\t                if (this[i].hasOwnProperty(\"equals\")) {\n\t                  if (this[i].equals(x)) return i;\n\t                } else if (this[i] === x) return i;\n\t              }\n\t            }\n\t            catch (e) { }\n\t            return -1;\n\t          },\n\t          enumerable: false\n\t        });\n\t        Object.defineProperty(arr, \"_pySlice\",\n\t        {\n\t          value: function (start, end, step) { \n\t            return pythonRuntime.internal.slice(this, start, end, step);\n\t          },\n\t            enumerable: false\n\t        });\n\t        Object.defineProperty(arr, \"toString\",\n\t        {\n\t          value: function () {\n\t            var s = '(' + this.join(', ');\n\t            if (this.length === 1) s += ',';\n\t            s += ')';\n\t            return s;\n\t          },\n\t          enumerable: false\n\t        });\n\t        return arr;\n\t      }\n\t    },\n\n\t    // Python built-in functions\n\n\t    functions: {\n\t      abs: function(x) {\n\t        return Math.abs(x);\n\t      },\n\t      all: function(iterable) {\n\t        for (var i in iterable) if (pythonRuntime.functions.bool(iterable[i]) !== true) return false;\n\t        return true;\n\t      },\n\t      any: function(iterable) {\n\t        for (var i in iterable) if (pythonRuntime.functions.bool(iterable[i]) === true) return true;\n\t        return false;\n\t      },\n\t      ascii: function(obj) {\n\t        var s = pythonRuntime.functions.repr(obj),\n\t            asc = \"\",\n\t            code;\n\t        for (var i = 0; i < s.length; i++) {\n\t          code = s.charCodeAt(i);\n\t          if (code <= 127) asc += s[i];\n\t          else if (code <= 0xFF) asc += \"\\\\x\" + code.toString(16);\n\t          else if (0xD800 <= code && code <= 0xDBFF) { // UCS-2 for the astral chars\n\t            // if (i+1 >= s.length) throw \"High surrogate not followed by low surrogate\"; // Is this needed?\n\t            code = ((code-0xD800)*0x400)+(s.charCodeAt(++i)-0xDC00)+0x10000;\n\t            asc += \"\\\\U\" + (\"000\"+code.toString(16)).slice(-8);\n\t          } else if (code <= 0xFFFF) asc += \"\\\\u\" + (\"0\"+code.toString(16)).slice(-4);\n\t          else if (code <= 0x10FFFF) asc += \"\\\\U\" + (\"000\"+code.toString(16)).slice(-8);\n\t          else; // Invalid value, should probably throw something. It should never get here though as strings shouldn't contain them in the first place\n\t        }\n\t        return asc;\n\t      },\n\t      bool: function(x) {\n\t        return !(x === undefined || // No argument\n\t                 x === null || // None\n\t                 x === false || // False\n\t                 x === 0 || // Zero\n\t                 x.length === 0 || // Empty Sequence\n\t                 // TODO: Empty Mapping, needs more support for python mappings first\n\t                 (x.__bool__ !== undefined && x.__bool__() === false) || // If it has bool conversion defined\n\t                 (x.__len__ !== undefined && (x.__len__() === false || x.__len__() === 0))); // If it has length conversion defined\n\t      },\n\t      chr: function(i) {\n\t        return String.fromCharCode(i); // TODO: Error code for not 0 <= i <= 1114111\n\t      },\n\t      divmod: function(a, b) {\n\t        return pythonRuntime.objects.tuple(Math.floor(a/b), a%b);\n\t      },\n\t      enumerate: function(iterable, start) {\n\t        start = start || 0;\n\t        var ret = new pythonRuntime.objects.list();\n\t        for (var i in iterable) ret.push(new pythonRuntime.objects.tuple(start++, iterable[i]));\n\t        return ret;\n\t      },\n\t      filter: function(fn, iterable) {\n\t        fn = fn || function () { return true; };\n\t        var ret = new pythonRuntime.objects.list();\n\t        for (var i in iterable) if (fn(iterable[i])) ret.push(iterable[i]);\n\t        return ret;\n\t      },\n\t      float: function(x) {\n\t        if (x === undefined) return 0.0;\n\t        else if (typeof x == \"string\") { // TODO: Fix type check\n\t          x = x.trim().toLowerCase();\n\t          if ((/^[+-]?inf(inity)?$/i).exec(x) !== null) return Infinity*(x[0]===\"-\"?-1:1);\n\t          else if ((/^nan$/i).exec(x) !== null) return NaN;\n\t          else return parseFloat(x);\n\t        } else if (typeof x == \"number\") { // TODO: Fix type check\n\t          return x; // TODO: Get python types working right so we can return an actual float\n\t        } else {\n\t          if (x.__float__ !== undefined) return x.__float__();\n\t          else return null; // TODO: Throw TypeError: float() argument must be a string or a number, not '<type of x>'\n\t        }\n\t      },\n\t      hex: function(x) {\n\t        return x.toString(16);\n\t      },\n\t      int: function (s) {\n\t        return parseInt(s);\n\t      },\n\t      len: function (o) {\n\t        return o.length;\n\t      },\n\t      list: function (iterable) {\n\t        var ret = new pythonRuntime.objects.list();\n\t        if ( arguments.length == 0 ) return ret;\n\t        if ( arguments.length > 1 ) throw new TypeError('list() takes at most 1 argument (' + arguments.length + ' given)');\n\t        if (iterable instanceof Array) for (var i in iterable) ret.push(iterable[i]);\n\t        else for (var i in iterable) ret.push(i);\n\t        return ret;\n\t      },\n\t      map: function(fn, iterable) {\n\t        // TODO: support additional iterables passed\n\t        var ret = new pythonRuntime.objects.list();\n\t        for (var i in iterable) ret.push(fn(iterable[i]));\n\t        return ret;\n\t      },\n\t      max: function(arg1, arg2) {\n\t        // TODO: support optional keyword-only arguments\n\t        // TODO: empty iterable raises Python ValueError\n\t        if (!arg2) { // iterable\n\t          var max = null;\n\t          for (var i in arg1) if (max === null || arg1[i] > max) max = arg1[i];\n\t          return max;\n\t        } else return arg1 >= arg2 ? arg1 : arg2;\n\t      },\n\t      min: function(arg1, arg2) {\n\t        // TODO: support optional keyword-only arguments\n\t        // TODO: empty iterable raises Python ValueError\n\t        if (!arg2) { // iterable\n\t          var max = null;\n\t          for (var i in arg1) if (max === null || arg1[i] < max) max = arg1[i];\n\t          return max;\n\t        } else return arg1 <= arg2 ? arg1 : arg2;\n\t      },\n\t      oct: function(x) {\n\t        return x.toString(8);\n\t      },\n\t      ord: function(c) {\n\t        return c.charCodeAt(0);\n\t      },\n\t      pow: function(x, y, z) {\n\t        return z ? Math.pow(x, y) % z : Math.pow(x, y);\n\t      },\n\t      print: function () {\n\t        var s = \"\";\n\t        for (var i = 0; i < arguments.length; i++)\n\t          s += i === 0 ? arguments[i] : \" \" + arguments[i];\n\t        console.log(s);\n\t      },\n\t      range: function (start, stop, step) {\n\t        if (stop === undefined) {\n\t          stop = start;\n\t          start = 0;\n\t          step = 1;\n\t        }\n\t        else if (step === undefined) step = 1;\n\t        var len = ~~((stop - start) / step); //~~ is a fast floor\n\t        if ( len < 0 ) return pythonRuntime.utils.convertToList([]);\n\t        var r = new Array(len);\n\t        var element = 0;\n\n\t        var i = start;\n\t        while (i < stop && step > 0 || i > stop && step < 0) {\n\t          r[element++] = i;\n\t          i += step;\n\t        }\n\n\t        pythonRuntime.utils.convertToList(r);\n\t        return r;\n\t      },\n\t      repr: function (obj) {\n\t        if (typeof obj === 'string') return \"'\" + obj + \"'\"; // TODO: Patch until typesystem comes up.\n\t        if (obj.__repr__ !== undefined) return obj.__repr__();\n\t        else if (obj.__class__ !== undefined && obj.__class__.module !== undefined && obj.__class__.__name__) {\n\t          return '<'+obj.__class__.__module__+'.'+obj.__class__.__name__+' object>';\n\t        } else return obj.toString(); // Raise a please report warning here, we should never reach this piece of code\n\t      },\n\t      reversed: function (seq) {\n\t        var ret = new pythonRuntime.objects.list();\n\t        for (var i in seq) ret.push(seq[i]);\n\t        return ret.reverse();\n\t      },\n\t      round: function (num, ndigits) {\n\t        if (ndigits) {\n\t          var scale = Math.pow(10, ndigits);\n\t          return Math.round(num * scale) / scale;\n\t        }\n\t        return Math.round(num);\n\t      },\n\t      sorted: function (iterable, key, reverse) {\n\t        var ret = new pythonRuntime.objects.list();\n\t        for (var i in iterable) ret.push(iterable[i]);\n\t        if(key) ret.sort(key); else ret.sort();\n\t        if (reverse) ret.reverse();\n\t        return ret;\n\t      },\n\t      str: function (obj) {\n\t        return obj.toString();\n\t      },\n\t      sum: function (iterable, start) {\n\t        // TODO: start can't be a string\n\t        var ret = start || 0;\n\t        for (var i in iterable) ret += iterable[i];\n\t        return ret;\n\t      },\n\t      tuple: function (iterable) {\n\t        var ret = new pythonRuntime.objects.tuple();\n\t        for (var i in iterable) ret.push(iterable[i]);\n\t        return ret;\n\t      }\n\t    },\n\n\t    // Python imports\n\t    // TODO: from x import y, z\n\n\t    imports: {\n\t      random: {\n\t        random: function () { return Math.random(); }\n\t      }\n\t    }\n\t  };\n\n\t  function PythonDict() {\n\n\t  }\n\n\t  Object.defineProperties(PythonDict.prototype, pythonRuntime.utils.dictPropertyDescriptor);\n\t  return pythonRuntime;\n\t}));\n\n\n\n/***/ }\n/******/ ])\n});\n;\n},{}],2:[function(require,module,exports){\nwindow.aetherFilbert = require('skulpty');\nwindow.aetherFilbertLoose = require('skulpty');\n\n},{\"skulpty\":1}]},{},[2]);"]}